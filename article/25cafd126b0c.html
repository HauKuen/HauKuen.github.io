

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon-32x32-next.png">
  <link rel="icon" href="/img/favicon-32x32-next.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="HauKuen">
  <meta name="keywords" content="">
  
    <meta name="description" content="三年前暑假学习算法的总结笔记，先全部放上来，之后根据自己现在的理解再慢慢修改。  并查集 基础模板  查找">
<meta property="og:type" content="article">
<meta property="og:title" content="基础算法总结">
<meta property="og:url" content="https://exusiai.top/article/25cafd126b0c.html">
<meta property="og:site_name" content="时砾逐光">
<meta property="og:description" content="三年前暑假学习算法的总结笔记，先全部放上来，之后根据自己现在的理解再慢慢修改。  并查集 基础模板  查找">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:%5CUsers%5CHiroshi%5CDesktop%5C%E6%8D%95%E8%8E%B7.PNG">
<meta property="og:image" content="c:%5CUsers%5CHiroshi%5CDesktop%5Ctopo.png">
<meta property="og:image" content="c:\Users\Hiroshi\Desktop\trie1.png">
<meta property="og:image" content="c:%5CUsers%5CHiroshi%5CDesktop%5C%E6%8D%95%E8%8E%B7.PNG">
<meta property="og:image" content="c:%5CUsers%5CHiroshi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815212021791.png">
<meta property="article:published_time" content="2024-03-13T07:07:29.000Z">
<meta property="article:modified_time" content="2024-03-13T07:16:03.078Z">
<meta property="article:author" content="HauKuen">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:%5CUsers%5CHiroshi%5CDesktop%5C%E6%8D%95%E8%8E%B7.PNG">
  
  
  
  <title>基础算法总结 - 时砾逐光</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/font.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"exusiai.top","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":"fales","default":"text"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.1.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>时砾逐光</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/42.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="基础算法总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-13 15:07" pubdate>
          2024年3月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          89 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">基础算法总结</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    本文最后更新于 2024年3月13日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>三年前暑假学习算法的总结笔记，先全部放上来，之后根据自己现在的理解再慢慢修改。</p>
<hr>
<h3 id="并查集">并查集</h3>
<h5 id="基础模板">基础模板</h5>
<blockquote>
<p>查找</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x)	
&#123;
	while(pre[x] !&#x3D; x)	
		x &#x3D; pre[x];	
	return x;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<blockquote>
<p>合并</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void join(int x,int y)
&#123;
    int fx&#x3D;find(x), fy&#x3D;find(y);
    if(fx !&#x3D; fy)    
        pre[fx]&#x3D;fy;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h5 id="优化模板">优化模板</h5>
<blockquote>
<p>路径压缩之优化函数</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x) 
    &#123;
        if (pre[x] &#x3D;&#x3D; x)
            return x; 
        return pre[x] &#x3D; find(pre[x]);  &#x2F;&#x2F;此代码相当于先找到根结点rootx，然后pre[x]&#x3D;rootx  
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>小缺陷：只有当查找了某个节点的根节点后，才能对该查找路径上的各节点进行路径压缩。换言之，<strong>第一次</strong>执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。</p>
<blockquote>
<p>路径压缩之加权标记法</p>
<p>主要思想：加权标记法的核心在于对rank数组的逻辑控制，其主要的情况有：<br>
1、如果rank[x] &lt; rank[y]，则令pre[x] = y；<br>
2、如果rank[x] == rank[y]，则可任意指定上级；<br>
3、如果rank[x] &gt; rank[y]，则令pre[y] = x；</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void join(int x, int y)
    &#123;
        x &#x3D; find(x);
        y &#x3D; find(y);
        if (x &#x3D;&#x3D; y)   &#x2F;&#x2F;如果 x和 y的根节点一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑
            return;
        if (rank[x] &gt; rank[y])
            pre[y] &#x3D; x;
        else
        &#123;
            if (rank[x] &#x3D;&#x3D; rank[y]) 
                rank[y]++;  &#x2F;&#x2F;&#x2F;&#x2F;如果 x的高度和 y的高度相同，则令 y的高度加1  (这里是随便选的x或者y增加)
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>以上两种方法不能同时使用</strong></p>
<hr>
<h3 id="带权并查集">带权并查集</h3>
<blockquote>
<p>路径压缩</p>
<p>原理：先记录下原本父节点的编号，因为在路径压缩后父节点就变为根节点了，再将当前节点的权值加上原本父节点的权值，此时父节点的权值已经是父节点到根节点的权值了，因此加上这个权值就会得到当前节点到根节点的权值。</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(int x)
    &#123;
        if (x !&#x3D; parent[x])
        &#123;
            int t &#x3D; parent[x];
            parent[x] &#x3D; find(parent[x]);
            value[x] +&#x3D; value[t];
        &#125;
        return parent[x];
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>带权合并</p>
<blockquote>
<p>现在是已知x所在的并查集根节点为px，y所在的并查集根节点为py，如果有了x、y之间的关系，要将px并到py上，如果不考虑权值直接修改parent就行了，但是现在是带权并查集，必须得求出px与py这条边的权值是多少，很显然x到py两条路径的权值之和应该相同。</p>
</blockquote>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int px &#x3D; find(x);
int py &#x3D; find(y);
if (px !&#x3D; py)
&#123;
	parent[px] &#x3D; py;
	value[px] &#x3D; -value[x] + value[y] + s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h4 id="二分函数">二分函数</h4>
<p>头文件<code>&lt;algorithm&gt;</code></p>
<hr>
<p>1.binary_search(arrfirst,arrlast,value)</p>
<p>arrlast为<strong>数组末地址后一个位置</strong>，相当于左闭右开，value为具体值.</p>
<p>功能：函数返回值为真或假.</p>
<hr>
<p>2.lower_bound(arrfirst , arrlast, value)   (仍为<strong>左闭右开</strong>区间)</p>
<p>功能：返回指向<strong>大于或等于</strong>value的第一个元素的指针。如果所有元素都小于value，则返回arrlast.</p>
<p>重载：lower_bound(arrfist , arrlast, value, greater<int>())</p>
<p>功能：返回<strong>小于或等于</strong>value的元素地址.</p>
<hr>
<p>3.upper_bound(arrfirst , arrlast, value)</p>
<p>功能：在<strong>左闭右开</strong>区间进行二分查找，返回指向<strong>大于</strong>value的第一个元素的指针。如果所有元素都小于value，则返回arrlast.</p>
<p>重载：upper_bound(arrfist , arrlast, value, greater<int>())</p>
<p>功能：返回<strong>小于</strong>value的元素地址.</p>
<hr>
<p>4.equal_range(arrfirst,arrlast,value)</p>
<p>功能：返回一个迭代器(i,j),其中i是在不破坏次序的前提下，value可插入的第一个位置，j则是在不破坏次序的前提下，value可插入的最后一个位置.因此，[i,j)内的每个元素都等同于value，而且[i,j)是[arrfirst,arrlast)之中符合此一性质的最大子区间.</p>
<p><em>以上函数在对容器使用时会返回迭代器，无需减去初始地址.</em></p>
<hr>
<p>5.includes(beg,end,searchBeg,searchEnd)</p>
<p>功能：返回一个bool变量，两种形式都用来判断有序序列[beg,end)是否包含另一个有序序列[searchBeg,searchEnd)的全部元素.即<strong>判断子集</strong>.</p>
<hr>
<h4 id="折半枚举">折半枚举</h4>
<p>最小化最大值</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (l &lt; r)
    &#123;
        int mid &#x3D; (l + r + 1) &gt;&gt; 1;
        if (check())
            l &#x3D; mid;
            else
                r &#x3D; mid - 1;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>最大化最小值</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">while (l &lt; r)
    &#123;
        int mid &#x3D; (l + r) &gt;&gt; 1;
        if (check())
            r &#x3D; mid;
            else
                l &#x3D; mid + 1;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="二分进阶">二分进阶</h4>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hebtu666/article/details/115066499?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162720368716780274146053%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162720368716780274146053&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-115066499.first_rank_v2_pc_rank_v29&amp;utm_term=%E4%BA%8C%E5%88%86&amp;spm=1018.2226.3001.4187">二分深入剖析</a></p>
<hr>
<h4 id="哈夫曼树">哈夫曼树</h4>
<p>​	给定n个权值，作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为哈夫曼树。</p>
<p>​    哈夫曼树是带权路径长度最短的树，权值较<strong>大</strong>的结点离根较<strong>近</strong>。</p>
<p>​	WPL:树的带权路径长度所有叶子结点的带权路径长度之和，即为树的带权路径长度，记为<strong>WPL</strong>。</p>
<p><strong>构造哈夫曼树</strong></p>
<blockquote>
<p>给定n个权值，作为n个叶子结点，构造哈夫曼树。设n个权值分别为w1、w2、······wn，哈夫曼树的构造方式如下：</p>
<p>（1）将n个结点加入小根堆。</p>
<p>（2）从小根堆中取出权值最小的两个结点合并为一棵树，树的根结点的权值即为两个子结点的权值之和。</p>
<p>（3）将(2)中合成的根结点加入小根堆，保持堆仍为小根堆。</p>
<p>（4）重复(2) (3)步骤，直到小根堆中只剩一个结点，即完成一棵哈夫曼树。</p>
</blockquote>
<p>设六个结点的权值分别是{6，3，8，2，10，4}，构造哈夫曼树</p>
<p><img src="C:%5CUsers%5CHiroshi%5CDesktop%5C%E6%8D%95%E8%8E%B7.PNG" srcset="/img/loading.gif" lazyload alt="哈夫曼树"></p>
<h5 id="WPL的三种求法">WPL的三种求法</h5>
<p>1.所有叶子结点的带权路径长度之和</p>
<p>WPL=2<em>4+3</em>4+4<em>3+6</em>2+8<em>2+2</em>10=80</p>
<p>2.除根结点外的所有结点的权值之和</p>
<p>WPL=2+3+4+5+6+8+9+10+14+19=80</p>
<p>3.除叶子结点的所有结点的权值之和</p>
<p>WPL=33+19+14+9+5=80</p>
<h5 id="哈夫曼树的特性">哈夫曼树的特性</h5>
<p>1.哈夫曼树并不唯一（即左右子树可以交换），但带权路径长度是相同的。</p>
<p>2.权值越大的结点越靠近根结点。</p>
<p>3.哈夫曼树中只有叶子结点（度为0）和度为2的结点，没有度为1的结点。</p>
<p>4.一棵有n个叶子结点的哈夫曼树共有2n-1个结点。</p>
<hr>
<h5 id="BFS用队列实现的思路：">BFS用队列实现的思路：</h5>
<p>​		每遇到一个元素，就把这个元素的所有邻接元素放入队列，当队列不为空的时候，不断从队首拿出元素进行操作，直到队列为空。</p>
<p>​		PS:<em>一般情况下，用递归实现BFS比较为难，所以常用队列实现。</em></p>
<h5 id="基本模型">基本模型</h5>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
 * @param Vs 起点 
 * @param Vd 终点 
 *&#x2F;
bool BFS(Node&amp; Vs, Node&amp; Vd)&#123;  
    queue&lt;Node&gt; Q;  
    Node Vn, Vw;  
    int i;  

    &#x2F;&#x2F;初始状态将起点放进队列Q  
    Q.push(Vs);  
    hash(Vw) &#x3D; true;&#x2F;&#x2F;设置节点已经访问过了！  

    while (!Q.empty())&#123;&#x2F;&#x2F;队列不为空，继续搜索！  
        &#x2F;&#x2F;取出队列的头Vn  
        Vn &#x3D; Q.front();  

        &#x2F;&#x2F;从队列中移除  
        Q.pop();  

        while(Vw &#x3D; Vn通过某规则能够到达的节点)&#123;  
            if (Vw &#x3D;&#x3D; Vd)&#123;&#x2F;&#x2F;找到终点了！  
                &#x2F;&#x2F;把路径记录  
                return true;&#x2F;&#x2F;返回  
            &#125;  

            if (isValid(Vw) &amp;&amp; !visit[Vw])&#123;  
                &#x2F;&#x2F;Vw是一个合法的节点并且为白色节点  
                Q.push(Vw);&#x2F;&#x2F;加入队列Q  
                hash(Vw) &#x3D; true;&#x2F;&#x2F;设置节点颜色  
            &#125;  
        &#125;  
    &#125;  
    return false; 
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1562">BFS基础题-连通块问题</a>(也可以用dfs解决)</p>
<p><strong>AC代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
char a[102][102];
int row, col;
int dir[8][2] &#x3D;
    &#123;&#123;1, 0&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;;
using namespace std;
void dfs(int i, int j)
&#123;
    a[i][j]&#x3D;&#39;*&#39;;
    for (int k &#x3D; 0; k &lt; 8; k++)
    &#123;
        int x &#x3D; i + dir[k][0];
        int y &#x3D; j + dir[k][1];
        if (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col &amp;&amp; a[x][y] &#x3D;&#x3D; &#39;@&#39;)
            dfs(x, y);
    &#125;
    return;
&#125;
int main()
&#123;
    while ((cin &gt;&gt; row &gt;&gt; col) &amp;&amp; (row !&#x3D; 0 || col !&#x3D; 0))
    &#123;
        int c &#x3D; 0;
        getchar();
        for (int i &#x3D; 1; i &lt;&#x3D; row; i++)
            for (int j &#x3D; 1; j &lt;&#x3D; col; j++)
                cin &gt;&gt; a[i][j];
        for (int i &#x3D; 1; i &lt;&#x3D; row; i++)
            for (int j &#x3D; 1; j &lt;&#x3D; col; j++)
                if (a[i][j] &#x3D;&#x3D; &#39;@&#39;)
                &#123;
                    dfs(i, j);
                    c++;
                &#125;
        cout &lt;&lt; c &lt;&lt; endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">八皇后问题</a></p>
<h5 id="三维BFS">三维BFS</h5>
<p><a target="_blank" rel="noopener" href="https://vjudge.net/problem/POJ-2251#author=0">Dungeon Master</a></p>
<p><strong>AC代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
 
const int inf &#x3D; 0x3f3f3f3f;
int l, r, c, ans;
int sx, sy, sz;
char mp[35][35][35];
int vis[35][35][35];
 
struct node &#123;
    int x, y, z, step;
&#125;nw, nxt;
 
int dx[6] &#x3D; &#123;1, -1, 0, 0, 0, 0&#125;, dy[6] &#x3D; &#123;0, 0, 1, -1, 0, 0&#125;, 
    dz[6] &#x3D; &#123;0, 0, 0, 0, 1, -1&#125;;
 
void bfs(int z, int x, int y) &#123;
    vis[z][x][y] &#x3D; 1;
    nw.z &#x3D; z, nw.x &#x3D; x, nw.y &#x3D; y, nw.step &#x3D; 0;
    queue&lt;node&gt; q;
    q.push(nw);
    while(!q.empty()) &#123;
        nw &#x3D; q.front(), q.pop();
        if(mp[nw.z][nw.x][nw.y] &#x3D;&#x3D; &#39;E&#39;) &#123;
            ans &#x3D; nw.step;
            return;
        &#125;
        for(int i &#x3D; 0; i &lt; 6; i++) &#123;
            nxt.z &#x3D; nw.z + dz[i];
            nxt.x &#x3D; nw.x + dx[i];
            nxt.y &#x3D; nw.y + dy[i];
            if(nxt.z &gt;&#x3D; 0 &amp;&amp; nxt.z &lt; l &amp;&amp; nxt.x &gt;&#x3D; 0 &amp;&amp; nxt.x &lt; r &amp;&amp; nxt.y &gt;&#x3D;0 &amp;&amp; nxt.y &lt; c &amp;&amp; vis[nxt.z][nxt.x][nxt.y] &#x3D;&#x3D; 0 &amp;&amp; mp[nxt.z][nxt.x][nxt.y] !&#x3D; &#39;#&#39;) &#123; 		&#x2F;&#x2F;到其它层时相对位置不能为&#39;#&#39;
                nxt.step &#x3D; nw.step + 1;
                vis[nxt.z][nxt.x][nxt.y] &#x3D; 1;
                q.push(nxt);
            &#125;
        &#125;
    &#125;
&#125;
 
int main() &#123;
    while(~scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c) &amp;&amp; (l + r + c)) &#123;
        for(int i &#x3D; 0; i &lt; l; i++) &#123;
            for(int j &#x3D; 0; j &lt; r; j++) &#123;
                scanf(&quot;%s&quot;, mp[i][j]);			 &#x2F;&#x2F;三维存图第一维是层数！！！ 
                for(int k &#x3D; 0; k &lt; c; k++) &#123;	 &#x2F;&#x2F;第二维是行数，第三维是列数
                    if(mp[i][j][k] &#x3D;&#x3D; &#39;S&#39;) &#123;
                        sx &#x3D; j, sy &#x3D; k, sz &#x3D;i;
                    &#125;
                &#125;
            &#125;
        &#125;
        memset(vis, 0, sizeof(vis));
        ans &#x3D; inf;
        bfs(sz, sx, sy);
        if(ans &gt;&#x3D; inf) &#123;
            printf(&quot;Trapped!\n&quot;);
        &#125; else &#123;
            printf(&quot;Escaped in %d minute(s).\n&quot;, ans);
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="DFS">DFS</h3>
<p>​		DFS也可用栈实现(比较小众)</p>
<p>​		思路：每遇到一个元素，就把这个元素所有的邻接元素入栈，当栈不为空时，不断的从栈顶拿出元素进行操作，直到栈为空。</p>
<p>​		优点:DFS能够做到使用一个状态变量去搜索所有的状态空间，这对空间的消耗来说，<strong>是非常节约空间的</strong>（通常使用递归实现）。主要应用于回溯的搜索问题中，比如迷宫问题，岛屿问题。</p>
<h5 id="基本模型-2">基本模型</h5>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int check(参数)
&#123;
    if(满足条件)
        return 1;
    return 0;
&#125;
 
void dfs(int step)
&#123;
        判断边界
        &#123;
            相应操作
        &#125;
        尝试每一种可能
        &#123;
               满足check条件
               标记
               继续下一步dfs(step+1)
               恢复初始状态（回溯的时候要用到）
        &#125;
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h5 id="模板例题">模板例题</h5>
<p>P1605-迷宫 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">链接</a></p>
<h5 id="进阶">进阶</h5>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yanweiqi1754989931/article/details/109603384?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">DFS算法+剪枝+优化总结 </a></p>
<h3 id="图论基础">图论基础</h3>
<p><strong>图的基本概念</strong></p>
<p>1.若一个图的边数接近完全图，则称这样的图为稠密图。</p>
<p>2.若一个图的边数远小于完全图，则称这样的图为稀疏图。</p>
<p><strong>顶点的度</strong></p>
<p>在无向图中，是指依附于该点的边数，在有向图中还分入度和出度。</p>
<p><strong>图的存储方式</strong></p>
<p>邻接矩阵——适合稠密图</p>
<p>邻接表——适合稀疏图</p>
<p>链式前向星(静态邻接表)</p>
<p>通常情况下，邻接表是O(n+e)的复杂程度（n表示节点数，e表示边长），邻接矩阵则是O(n^2)的复杂程度。</p>
<h4 id="邻接矩阵">邻接矩阵</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

const int maxn&#x3D;105;
int G[maxn][maxn]&#x3D;&#123;0&#125;;    &#x2F;&#x2F;定义邻接矩阵 
int x,y;    &#x2F;&#x2F;输入两条边
int n,m;    &#x2F;&#x2F;供输入n对边 ,m个顶点 (x,y &lt;&#x3D; m)

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        cin &gt;&gt; x &gt;&gt; y;
        G[x][y] &#x3D; 1;
        G[y][x] &#x3D; 1;	&#x2F;&#x2F;有向图去掉就可
    &#125;
    
    for (int i &#x3D; 0; i &lt; m; i++)		&#x2F;&#x2F;输出邻接矩阵
    &#123;
        for (int j &#x3D; 0; j &lt; m; j++)
        &#123;
            cout &lt;&lt; G[i][j] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="邻接表-vector">邻接表(vector)</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int MAXN &#x3D; 1e3 + 5;
const int INF &#x3D; 0x3f3f3f3f;		&#x2F;&#x2F; 仅存储
vector&lt;int&gt; edge[MAXN];
int main()
&#123;
    int n, m, u, v;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); &#x2F;&#x2F; n个点，m条边
    while (m--)
    &#123;
        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
        &#x2F;&#x2F; 无向图
        edge[u].push_back(v);
        edge[v].push_back(u);
        &#x2F;&#x2F; 有向图
        &#x2F;&#x2F; edge[u].push_back(v);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="拓扑排序">拓扑排序</h3>
<p>概念：拓扑排序要解决的问题是给一个图的所有节点排序。</p>
<h4 id="Kahn-算法">Kahn 算法</h4>
<p>算法的核心思想是维持一个入度为 0 的顶点的集合。</p>
<p>从图中取出入度为0的顶点放入集合，并在图中删除与该顶点相关的所有边，如此往复，最后检查图中是否存在任何边，若存在，那么这个图一定有环路，否则返回集合中的顶点，返回的顺序就是拓扑排序的顺序。</p>
<p><img src="C:%5CUsers%5CHiroshi%5CDesktop%5Ctopo.png" srcset="/img/loading.gif" lazyload alt="图"></p>
<p>对其排序的结果就是：2 -&gt; 8 -&gt; 0 -&gt; 3 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 6 -&gt; 9 -&gt; 4 -&gt; 11 -&gt; 10 -&gt; 12</p>
<p>代码实现</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
 
bool TopSort(vector&lt;vector&lt;int&gt;&gt; &amp;G, int n, vector&lt;int&gt; &amp;inDegree) &#123;
	int num &#x3D; 0;				&#x2F;&#x2F;记录加入拓扑排序的顶点数
	queue&lt;int&gt; q;
	for (int i &#x3D; 0; i &lt; n; i++)
		if (inDegree[i] &#x3D;&#x3D; 0)
			q.push(i);		&#x2F;&#x2F;将所有入度为0的顶点入队
	while (!q.empty()) &#123;
		int u &#x3D; q.front();		&#x2F;&#x2F;取队首顶点u
		cout &lt;&lt; u &lt;&lt; &quot; &quot;;		
		q.pop();
		for (int i &#x3D; 0; i &lt; G[u].size(); i++) &#123;
			int v &#x3D; G[u][i];		&#x2F;&#x2F;u的后继节点
			inDegree[v]--;			&#x2F;&#x2F;v的入度减1
			if (inDegree[v] &#x3D;&#x3D; 0)		&#x2F;&#x2F;顶点v的入度减为0则入队
				q.push(v);
		&#125;
		G[u].clear();			&#x2F;&#x2F;清空顶点u的所有出边
		num++;
	&#125;
	if (num &#x3D;&#x3D; n)				&#x2F;&#x2F;加入拓扑序列的顶点数为n，说明拓扑排序成功，否则，失败
		return true;
	else
		return false;
&#125;
 
int main() &#123;
	int n, m;
	cout &lt;&lt; &quot;请输入顶点数和边数:&quot;;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;int&gt;&gt; G(n);
	for (int i &#x3D; 0; i &lt; m; i++) &#123;
		int x, y;
		cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i+1 &lt;&lt; &quot;条边的顶点:&quot;;
		cin &gt;&gt; x &gt;&gt; y;
		G[x].push_back(y);
	&#125;
	cout &lt;&lt; &quot;拓扑排序为:&quot;;
	vector&lt;int&gt; inDegree(n);
	for (auto x : G) &#123;
		for (auto y : x)
			inDegree[y]++;
	&#125;
	bool res &#x3D; TopSort(G, n, inDegree);
 
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="DFS算法">DFS算法</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; G[MAXN];  &#x2F;&#x2F; vector 实现的邻接表
int c[MAXN];          &#x2F;&#x2F; 标志数组
vector&lt;int&gt; topo;     &#x2F;&#x2F; 拓扑排序后的节点

bool dfs(int u) &#123;
  c[u] &#x3D; -1;
  for (int v : G[u]) &#123;
    if (c[v] &lt; 0)
      return false;
    else if (!c[v])
      if (!dfs(v)) return false;
  &#125;
  c[u] &#x3D; 1;
  topo.push_back(u);
  return true;
&#125;

bool toposort() &#123;
  topo.clear();
  memset(c, 0, sizeof(c));
  for (int u &#x3D; 0; u &lt; n; u++)
    if (!c[u])
      if (!dfs(u)) return false;
  reverse(topo.begin(), topo.end());
  return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="前缀和-差分">前缀和&amp;差分</h3>
<h4 id="前缀和">前缀和</h4>
<p>即为数列的前n项和。</p>
<p>C++ 标准库中实现了前缀和函数 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/partial_sum"><code>std::partial_sum</code></a>，定义于头文件 <code>&lt;numeric&gt;</code> 中。</p>
<p>注意：一般写前缀和遍历的时候令<strong>i=1</strong>，因为递推公式是<strong>B[i]=A[i]+B[i-1]</strong>,要保证第一位存在所以不能让i=0。</p>
<p>求前缀和区间值:<strong>sum[l,r]=B[r]-B[l-1]</strong></p>
<h5 id="二维前缀和">二维前缀和</h5>
<p>假定一个矩阵</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1 2 4 3
5 1 2 4
6 3 5 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>
<p>它的二维前缀和矩阵为</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1   3   7   10
6   9   15  22
12  18  29  45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>
<p>公式：<strong>sum[i] [j]=sum[i] [j-1]+sum[i-1] [j]-sum[i-1] [j-1]+a[i] [j]</strong></p>
<h5 id="子矩阵之和">子矩阵之和</h5>
<p>求(x1,y1)到(x2,y2)的子矩阵之和</p>
<p>**sum[x2] [y2] – sum[x2] [y1-1] – sum[x1-1] [y2] + sum[x1-1] [y1-1] **</p>
<h4 id="差分">差分</h4>
<p>差分是一种和前缀和相对的策略，可以当做是求和的逆运算。</p>
<p><strong>b[i]=a[i]-a[i-1]</strong></p>
<hr>
<h3 id="单调栈-单调队列">单调栈&amp;单调队列</h3>
<p>概念：单调栈和单调队列都是满足单调性的数据结构。两者不同之处在于单调队列只能在<strong>一端进出</strong>，而单调队列是<strong>一端入一端出</strong>。</p>
<h4 id="单调栈">单调栈</h4>
<p><strong>插入</strong></p>
<blockquote>
<p>将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下<strong>弹出最少</strong>的元素。</p>
</blockquote>
<p>使用样例：栈中自顶向下的元素为 1,3,5,20,30,插入元素10时为了保证单调性需要依次弹出元素1,3,5，最后操作后栈中元素为10,20,30。</p>
<h4 id="单调队列">单调队列</h4>
<p>概念：从队列头部到队列的尾部严格保持递增(或递减)，与普通队列不同的是，单调队列要求可以在队尾进行操作，<code>&lt;queue&gt;</code>无法做到，可以手动模拟或者使用stl的<strong>双端队列</strong><code>&lt;deque&gt;</code> 。</p>
<p>例题<a target="_blank" rel="noopener" href="http://poj.org/problem?id=2823"><strong>Sliding Window</strong></a></p>
<p>分析</p>
<blockquote>
<p>要求的是每连续的 个数中的最大（最小）值，很明显，当一个数进入所要 “寻找” 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。也就是说——当满足以上条件时，可将前面的数 “弹出”，再将该数真正 push 尾。</p>
<p>这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。</p>
</blockquote>
<p>题解</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#define maxn 1000100
using namespace std;
int q[maxn], a[maxn];
int n, k;
void getmin() &#123;
  int head &#x3D; 0, tail &#x3D; 0;
  for (int i &#x3D; 1; i &lt; k; i++) &#123;
    while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &gt;&#x3D; a[i]) tail--;
    q[++tail] &#x3D; i;
  &#125;
  for (int i &#x3D; k; i &lt;&#x3D; n; i++) &#123;
    while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &gt;&#x3D; a[i]) tail--;
    q[++tail] &#x3D; i;
    while (q[head] &lt;&#x3D; i - k) head++;
    printf(&quot;%d &quot;, a[q[head]]);
  &#125;
&#125;

void getmax() &#123;
  int head &#x3D; 0, tail &#x3D; 0;
  for (int i &#x3D; 1; i &lt; k; i++) &#123;
    while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &lt;&#x3D; a[i]) tail--;
    q[++tail] &#x3D; i;
  &#125;
  for (int i &#x3D; k; i &lt;&#x3D; n; i++) &#123;
    while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &lt;&#x3D; a[i]) tail--;
    q[++tail] &#x3D; i;
    while (q[head] &lt;&#x3D; i - k) head++;
    printf(&quot;%d &quot;, a[q[head]]);
  &#125;
&#125;

int main() &#123;
  scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
  for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
  getmin();
  printf(&quot;\n&quot;);
  getmax();
  printf(&quot;\n&quot;);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="线段树">线段树</h3>
<p>概念：线段树是算法竞赛中常用的用来维护 <strong>区间信息</strong> 的数据结构。</p>
<p>线段树可以在***O(logN)***的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<h4 id="模板代码">模板代码</h4>
<p>建树</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void build(int *a, int q, int l, int r)
&#123;
  if (l &#x3D;&#x3D; r)
  &#123;
    st[q] &#x3D; a[l];
    return;
  &#125;
  int mid &#x3D; (l + r) &#x2F; 2;
  build(a, q * 2 + 1, l, mid);
  build(a, q * 2 + 2, mid + 1, r);
  st[q] &#x3D; st[q * 2 + 1] + st[q * 2 + 2];
&#125;

&#x2F;&#x2F;build(a, 1, 1, n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>单点更新</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void update_single(int q, int l, int r, int x, int num)
&#123;		&#x2F;&#x2F;q为初始节点(一般默认为1)，l，r为线段树范围，x为具体节点，num为更新值
  if (l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; x)
  &#123;
    st[q] +&#x3D; num;
    return;
  &#125;
  int mid &#x3D; (l + r) &#x2F; 2;
  if (mid &gt;&#x3D; x)
    update(q * 2 + 1, l, mid, x, num);
  else
    update(q * 2 + 2, mid + 1, r, x, num);
  st[q] &#x3D; st[q * 2 + 1] + st[q * 2 + 2];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>只单点更新的区间求和</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int query(int q, int l, int r, int tl, int tr)
&#123;			&#x2F;&#x2F;tl,tr为求和区间
  if (tl &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; tr)
    return st[q];
  int mid &#x3D; (l + r) &#x2F; 2, sum &#x3D; 0;
  if (tl &lt;&#x3D; mid)
    sum +&#x3D; query(q * 2 + 1, l, mid, tl, tr);
  if (tr &gt; mid)
    sum +&#x3D; query(q * 2 + 2, mid + 1, r, tl, tr);
  return sum;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>区间更新</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;区间[tl,tr]的值全部加num
void update_region(int q, int l, int r, int tl, int tr, int num)
&#123;
    if (l &gt;&#x3D; tl &amp;&amp; r &lt;&#x3D; tr)
    &#123;
        st[q] +&#x3D; num * (r - l + 1);
        lazy[q] +&#x3D; num;
        return;
    &#125;
    if (lazy[q])
        pushdown(q, l, r);
    int mid &#x3D; (l + r) &#x2F; 2;
    if (tl &lt;&#x3D; mid)
        update_region(q * 2, l, mid, tl, tr, num);
    if (tr &gt; mid)
        update_region(q * 2 + 1, mid + 1, r, tl, tr, num);
    st[q] &#x3D; st[q * 2] + st[q * 2 + 1];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>延迟标记</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将下标k的节点lazy向下传递
void pushdown(int k, int l, int r)
&#123;
    int mid &#x3D; (l + r) &#x2F; 2;
    lazy[2 * k] +&#x3D; lazy[k];
    st[2 * k] +&#x3D; ((mid - l) + 1) * lazy[k];
    lazy[2 * k + 1] +&#x3D; lazy[k];
    st[2 * k + 1] +&#x3D; (r - mid) * lazy[k];
    lazy[k] &#x3D; 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>区间更新的区间求和</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">int query(int q, int l, int r, int tl, int tr)
&#123;
    if(l&gt;&#x3D;tl&amp;&amp;r&lt;&#x3D;tr)
        return st[q];
    if(lazy[q])
        pushdown(q, l, r);&#x2F;&#x2F;下放标记
    int sum &#x3D; 0;
    int mid &#x3D; (l + r) &#x2F; 2;
    if (tl &lt;&#x3D; mid)
        sum +&#x3D; query(q * 2, l, mid, tl, tr);
    if (tr &gt; mid)
        sum +&#x3D; query(q * 2 + 1, mid + 1, r, tl, tr);
    return sum;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>经典例题<a target="_blank" rel="noopener" href="https://blog.csdn.net/hurmishine/article/details/51959077?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&amp;spm=1001.2101.3001.4242">敌兵布阵+思路+题解</a></p>
<hr>
<h3 id="字典树">字典树</h3>
<img src="C:\Users\Hiroshi\Desktop\trie1.png" srcset="/img/loading.gif" lazyload alt="字典树" style="zoom: 80%;" />
<p>概念：字典树<strong>用边来代表字母</strong>，而从根结点到树上某一结点的路径就代表了一个字符串。</p>
<h4 id="模板代码-2">模板代码</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn&#x3D;1e7;
int trie[maxn][26];
string s;
int ind&#x3D;1;
int flag[maxn];
void insert(string s)&#x2F;&#x2F;插入操作
&#123;
	int t &#x3D; 0;
	for (int i &#x3D; 0; s[i]; i++)
	&#123;
		int x &#x3D; s[i] - &#39;a&#39;;			&#x2F;&#x2F;x是t节点的第x个孩子
		if (trie[t][x] &#x3D;&#x3D; 0)		&#x2F;&#x2F;如果没有就添加节点
			trie[t][x] &#x3D; ind++;		&#x2F;&#x2F;ind为节点编号
		t &#x3D; trie[t][x];
		ans[t]++;
	&#125;
    &#x2F;&#x2F; flag[t]&#x3D;1;		&#x2F;&#x2F;用flag标记字符串的最后一个节点位置，查询的时候可以防止出错，如树中有cart，不添加标记如果查询car就会出现错误
&#125;


bool query(string s) &#x2F;&#x2F;查询是否存在目标字符串
&#123;
	int t &#x3D; 0;
	for (int i &#x3D; 0; s[i]; i++)
	&#123;
		int x &#x3D; s[i] - &#39;a&#39;;
		if (trie[t][x] &#x3D;&#x3D; 0)		&#x2F;&#x2F;中途没有查询到就返回false
            return 0;
		t &#x3D; trie[t][x];				&#x2F;&#x2F;前往下一个节点
	&#125;
    return flag[t];		&#x2F;&#x2F;插入时的标记在此发挥作用
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="最短路问题">最短路问题</h3>
<p><strong>四种算法</strong></p>
<ul>
<li>Floyd算法</li>
<li>Dijkstra算法</li>
<li>Bellman-Ford算法</li>
<li>SPFA算法</li>
</ul>
<h4 id="Floyd算法">Floyd算法</h4>
<p>用来求任意两个节点之间的最短路</p>
<p>缺点：复杂度较高为<em><strong>O(n^3)</strong></em>，一般只适合三位数的数据大小。</p>
<p>优点：适用于任何图，代码简单，边权可以为<strong>负</strong>，但是<strong>不能有负环</strong>(必须存在最短路)。</p>
<p>核心代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;
  for (x &#x3D; 1; x &lt;&#x3D; n; x++) &#123;
    for (y &#x3D; 1; y &lt;&#x3D; n; y++) &#123;
      f[x][y] &#x3D; min(f[x][y], f[x][k] + f[k][y]);
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>原本f数组是有三维的，但是第一维可以省略不会产生影响，这里不进行深究。</p>
<h4 id="Dijkstra算法">Dijkstra算法</h4>
<p>用来求<strong>单源最短路的算法</strong>，图的<strong>边权不能为负</strong>，时间复杂度为<strong>O(N^2)</strong>，堆优化为O(mlogn)。</p>
<p>模板代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;
#include&lt;queue&gt;
#include&lt;map&gt;
#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;math.h&gt;
using namespace std;
const int inf&#x3D;0x3f3f3f3f;
const int maxn &#x3D; 1e3 + 10;
int n,m;&#x2F;&#x2F;n个顶点，m条边。
bool visited[maxn];&#x2F;&#x2F;判断是否确定到源点的最终最短距离。
int graph[maxn][maxn];
int dis[maxn];&#x2F;&#x2F;顶点到源点的最短距离。
int start,goal;

void init()
&#123;
    memset(visited, false, sizeof(visited));
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        dis[i] &#x3D; graph[start][i]; &#x2F;&#x2F;从start点到i点的距离
    &#125;
&#125;

void dijkstra()
&#123;
	int minn;&#x2F;&#x2F;记录每趟最短路径中最小的路径值。
    int pos &#x3D; 0; &#x2F;&#x2F;记录得到的minn所对应的下标。 
    init();
    visited[start] &#x3D; true;	&#x2F;&#x2F;因为pos为0，所以这里标不标记都一样
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        &#x2F;&#x2F;将n个顶点依次加入判断。
        minn &#x3D; inf;
        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
        &#123;
            if (!visited[j] &amp;&amp; dis[j] &lt; minn)
            &#123;
                minn &#x3D; dis[j];
                pos &#x3D; j;
            &#125;
        &#125;
        &#x2F;&#x2F;经过这趟for循环后找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。
        visited[pos] &#x3D; true; &#x2F;&#x2F;将此点并入已知集合。
        &#x2F;&#x2F;接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。
        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
        &#123;
            if (!visited[j] &amp;&amp; dis[j] &gt; dis[pos] + graph[pos][j])
                dis[j] &#x3D; dis[pos] + graph[pos][j];
        &#125;
    &#125;
    &#x2F;&#x2F;退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。
    if (dis[goal] &#x3D;&#x3D; inf)
        cout &lt;&lt; -1 &lt;&lt; endl;
        else
        cout &lt;&lt; dis[goal] &lt;&lt; endl; &#x2F;&#x2F;输出目标点到源点的最短路径长度。
&#125;

int main()
&#123;
    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)
    &#123;
        memset(graph, inf, sizeof(graph));
    int u, v, w;
    for (int i &#x3D; 0; i &lt; m; i++)
    &#123;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        if (w &lt; graph[u][v])&#x2F;&#x2F; 判断重边，取最小值
            graph[u][v] &#x3D; w;
        if (w &lt; graph[v][u])
            graph[v][u] &#x3D; w;
    &#125;
        start &#x3D; 1, goal &#x3D; n;
        dijkstra();
    &#125;
    
    
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="Bellman-Ford算法">Bellman-Ford算法</h4>
<p>能找到<strong>某个结点</strong>出发到所有结点的最短路，或者报告某些最短路不存在</p>
<p>可以在<strong>负权图</strong>中使用，可以用来寻找是否有负环</p>
<p><strong>核心代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for(int k &#x3D; 1 ; k &lt;&#x3D; n - 1 ; k ++) &#x2F;&#x2F;n为点
&#123;
    for(int i &#x3D; 1 ; i &lt; m ; i ++) &#x2F;&#x2F;m为边，枚举每一条边
    &#123;
        if(dis[v[i]] &gt; dis[u[i]] + w[i])&#x2F;&#x2F;尝试对每一条边进行松弛
            dis[v[i]] &#x3D; dis[u[i]] + w[i] ;&#x2F;&#x2F;dis数组记录源点到其余各个顶点的最短路径  
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>模板例题+代码</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<p>第1行输入n,m，其中n为顶点，m为边的关系</p>
<p>第2-m+1行给出两个点和之间的距离</p>
<p>求1号点到每个点的最短路</p>
</blockquote>
<p><strong>题解</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
const int INF &#x3D; 0x3f3f3f;
using namespace std;
int main()
&#123;
    int u[100] , v[100] , w[100] , dis[100] , n , m ;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++)
    &#123;
      cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];
    &#125;
    for(int i &#x3D; 1 ; i  &lt;&#x3D; n ; i ++)
    dis[i] &#x3D; INF;
    dis[1] &#x3D; 0;
    for(int k &#x3D; 1 ; k &lt;&#x3D; n - 1 ; k ++)
        for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++)
            if(dis[v[i]] &gt; dis[u[i]] + w[i])
                dis[v[i]] &#x3D; dis[u[i]] + w[i];
            for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++)
              cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;
    return 0 ;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="SPFA算法">SPFA算法</h4>
<p>是Bellman-Ford的<strong>队列优化</strong></p>
<p>优化原理：Bellman-Ford算法会进行很多次无用的松弛操作，但是易知，只有上次被松弛过得节点所连接的边才会引起下一次的松弛，所以用队列维护可能引起松弛操作的节点就可以省略操作不必要的边。</p>
<p>思想：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。</p>
<p><strong>模板代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 200010;
struct edge
&#123;
  int to, next, w;
&#125; e[maxn];

int n, m, cnt, p[maxn], Dis[maxn];
int In[maxn];
bool visited[maxn];

void add(const int x, const int y, const int z)
&#123;
  e[++cnt].to &#x3D; y;
  e[cnt].next &#x3D; p[x];
  e[cnt].w &#x3D; z;
  p[x] &#x3D; cnt;
  return;
&#125;
bool Spfa(const int S)
&#123;
  int i, t, temp;
  queue&lt;int&gt; Q;
  memset(visited, 0, sizeof(visited));
  memset(Dis, 0x3f, sizeof(Dis));
  memset(In, 0, sizeof(In));
  Q.push(S);
  visited[S] &#x3D; true;
  Dis[S] &#x3D; 0;
  while (!Q.empty())
  &#123;
    t &#x3D; Q.front();
    Q.pop();
    visited[t] &#x3D; false;
    for (i &#x3D; p[t]; i; i &#x3D; e[i].next)
    &#123;
      temp &#x3D; e[i].to;
      if (Dis[temp] &gt; Dis[t] + e[i].w)
      &#123;
        Dis[temp] &#x3D; Dis[t] + e[i].w;
        if (!visited[temp])
        &#123;
          Q.push(temp);
          visited[temp] &#x3D; true;
          if (++In[temp] &gt; n)
            return false;
        &#125;
      &#125;
    &#125;
    &#125;
    return true;
&#125;
int main ( )
&#123;
  int s, t;
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
  for (int i &#x3D; 1; i &lt;&#x3D; m; ++i)
  &#123;
    int a, b, c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    add(a, b, c);
  &#125;
    if (!Spfa(s))
      cout &lt;&lt; &quot;fail&lt;&lt;endl&quot;;
    else
      cout &lt;&lt; Dis[t] &lt;&lt; endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="最小生成树">最小生成树</h3>
<h4 id="Kruskal算法">Kruskal算法</h4>
<p>知识点：对边贪心，并查集</p>
<p>思想：从最小边权的边开始，按边权<strong>从小到大</strong>依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了<strong>n-1</strong>条边，即形成了一棵树。</p>
<p>模板代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int N &#x3D; 5010;
struct node
&#123;
    int u, v, w;
&#125; edge[N];

int n, m, num, ans;
int pre[N];

bool cmp(node a, node b)&#x2F;&#x2F;按照边的距离排序
&#123;
    return a.w &lt; b.w;
&#125;

void init()
&#123;
    num &#x3D; 0, ans &#x3D; 0;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        pre[i] &#x3D; i;&#x2F;&#x2F;初始化，父节点为自己
&#125;

int find(int x)
&#123;
    if (x !&#x3D; pre[x])	&#x2F;&#x2F;路径压缩
        return pre[x] &#x3D; find(pre[x]);
    return x;
&#125;

void merge(int x,int y)&#x2F;&#x2F;合并函数
&#123;
    int a &#x3D; find(x);
    int b &#x3D; find(y);
    if (a !&#x3D; b)
        pre[a] &#x3D; b;
&#125;

void krusal()
&#123;
    sort(edge, edge + m, cmp);&#x2F;&#x2F;排序
    for (int i &#x3D; 0; i &lt; m; i++)
    &#123;
        int x &#x3D; edge[i].u;
        int y &#x3D; edge[i].v;
        if (find(x) !&#x3D; find(y))	&#x2F;&#x2F;两个点的父节点不是同一个就直接合并，如果是同一个的话就直接丢弃这个边，继续下一个边
        &#123;
            merge(x, y);
            num++;
            ans +&#x3D; edge[i].w;
            if (num &#x3D;&#x3D; n - 1)&#x2F;&#x2F;根据性质，最小生成树的边是结点数-1,，如果边数够了就表明满足条件
            &#123;
                cout &lt;&lt; ans &lt;&lt; endl;
                return;
            &#125;
        &#125;
    &#125;&#x2F;&#x2F;循环结束边数都不够说明无法构成最小生成树
    cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl;
    return;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    init();
    for (int i &#x3D; 0; i &lt; m; i++)
    &#123;
        cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w;
    &#125;
    krusal();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="Prim算法">Prim算法</h4>
<p>知识点：对点贪心</p>
<p>思想：每次选择距离当前节点最近的一个节点，并用这条边更新其它节点的距离。</p>
<p><strong>模板代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int inf&#x3D;0x3f3f3f;
const int maxx&#x3D;500+10;
int e[maxx][maxx], dis[maxx];
bool book[maxx];
int n,m;
void init()&#x2F;&#x2F;初始化，自己到自己初始化为0，到其他点为inf
&#123;
    for (int i &#x3D; 0; i &lt; m; i++)
        for (int j &#x3D; 0; j &lt; m; j++)
            if (i &#x3D;&#x3D; j)
                e[i][j] &#x3D; 0;
            else
                e[i][j] &#x3D; inf;
&#125;

int prim(int e[][maxx], int n)
&#123;
    int ans &#x3D; 0;
    memset(book, false, sizeof(book));	
    for (int i &#x3D; 0; i &lt; n; i++)
        dis[i] &#x3D; e[0][i];
    for (int i &#x3D; 0; i &lt; n; i++)
    &#123;
        int minn &#x3D; inf, u &#x3D; -1;
        for (int j &#x3D; 0; j &lt; n; j++)
        &#123;
            if (!book[j] &amp;&amp; dis[j] &lt; minn)	&#x2F;&#x2F;未被标记且距离更小
            &#123;
                minn &#x3D; dis[j];
                u &#x3D; j;
            &#125;
        &#125;
        if (u &#x3D;&#x3D; -1)
            return 0;
        ans +&#x3D; minn;
        book[u] &#x3D; true;&#x2F;&#x2F;访问后进行标记
        for (int v &#x3D; 0; v &lt; n; v++)
            if (!book[v] &amp;&amp; e[u][v] !&#x3D; inf)
                dis[v] &#x3D; min(dis[v], e[u][v]);
    &#125;
    return ans;
&#125;

int main()
&#123;
    
    cin &gt;&gt; m &gt;&gt; n;
    init();
    for (int i &#x3D; 0; i &lt; n; i++)
    &#123;
        int a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        if (e[a][b] &gt; c)
            e[a][b] &#x3D; e[b][a] &#x3D; c;&#x2F;&#x2F;无向图
    &#125;
    int cnt &#x3D; prim(e, m);
    if (cnt)
        cout &lt;&lt; cnt &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl;&#x2F;&#x2F;没有最小生成树
   
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>Prim参考代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*prim算法求最小生成树
邻接矩阵法构造图 
算法思想：首先从顶点0出发，然后找到下一个距离顶点0最近的顶点i，也进入集合U
此算法是从进入了集合U的顶点中找到个各顶点与其他未进入集合U的顶点之间的一条最短的边去连接的 
*&#x2F;
# include&lt;stdio.h&gt;
#include&lt;iostream&gt;
using namespace std;
int inf&#x3D;0x3f3f3f3f;
int s[100][100];&#x2F;&#x2F;存储图 
 
bool selected[100];&#x2F;&#x2F;判断顶点是否被选中 
int minCost[100];&#x2F;&#x2F;保存已选顶点中到该顶点的最小的路径 
int parent[100];&#x2F;&#x2F;保存父节点 
 
void prim(int n,int k)&#123;
	&#x2F;&#x2F;第一步，第K个顶点被选中 
	selected[k]&#x3D;true;
	minCost[k]&#x3D;-1;
	&#x2F;&#x2F;开始更新minCost数组和parent数组 
	for(int i&#x3D;0;i&lt;n;i++)&#123;
		if(s[k][i]!&#x3D;inf&amp;&amp;s[k][i]&lt;minCost[i]) &#123;
			minCost[i]&#x3D;s[k][i];
			parent[i]&#x3D;k;
		&#125;
	&#125;
	&#x2F;&#x2F;在minCost数组中找到最小的那个值，然后选择对应的点
	int min&#x3D;inf;int f&#x3D;-1;
	 for(int j&#x3D;0;j&lt;n;j++) &#123;
	 	if(minCost[j]!&#x3D;-1&amp;&amp;minCost[j]&lt;min)&#123;
	 		min&#x3D;minCost[j];
	 		f&#x3D;j;
		 &#125;
	 &#125;
	 if(f&#x3D;&#x3D;-1) return;&#x2F;&#x2F;全部都已经被选了 
	 prim(n,f);
&#125;
int main(void)&#123;
	&#x2F;&#x2F;输入图的顶点个数
	int n;
	cin&gt;&gt;n;
	for(int i&#x3D;0;i&lt;n;i++)&#123;
		for(int j&#x3D;0;j&lt;n;j++)&#123;
			cin&gt;&gt;s[i][j];
			if(s[i][j]&#x3D;&#x3D;0)
			s[i][j]&#x3D;inf;
		&#125;
		selected[i]&#x3D;false; 
		minCost[i]&#x3D;inf;
		parent[i]&#x3D;-1;
	&#125; 
	&#x2F;&#x2F; cout&lt;&lt;&quot;图输入完成！&quot;; 
	 prim(n,0);
	 int sum&#x3D;0;
	 for(int i&#x3D;1;i&lt;n;i++)
	 &#123;
	 	sum&#x3D;sum+s[i][parent[i]];
	 &#125;
	 cout&lt;&lt;sum&lt;&lt;endl;
	 
&#125;
&#x2F;*6
0 6 1 5 0 0
6 0 5 0 3 0
1 5 0 5 6 4
5 0 5 0 0 2
0 3 6 0 0 6
0 0 4 2 6 0*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="倍增求LCA">倍增求LCA</h3>
<h4 id="朴素算法">朴素算法</h4>
<p>让节点一层一层在树上跳，预处理时需要dfs整棵树，时间复杂度为O(n)，<strong>单次查询O(logN)</strong>,如果是单次查询的话可以考虑朴素算法，应该比倍增快。</p>
<p><strong>BFS求节点深度</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#define MXN 50007
using namespace std;
vector&lt;int&gt; v[MXN];
vector&lt;int&gt; w[MXN];
int fa[MXN][31], cost[MXN][31], dep[MXN];
int n, m;
int a, b, c;
&#x2F;&#x2F; 接受两个参数：dfs 起始节点和它的父亲节点。
void dfs(int root, int fno) &#123;
  &#x2F;&#x2F; 初始化：第 2^0 &#x3D; 1 个祖先就是它的父亲节点，dep 也比父亲节点多 1。
  fa[root][0] &#x3D; fno;
  dep[root] &#x3D; dep[fa[root][0]] + 1;
  &#x2F;&#x2F; 初始化：其他的祖先节点：第 2^i 的祖先节点是第 2^(i-1) 的祖先节点的第
  &#x2F;&#x2F; 2^(i-1) 的祖先节点。
  for (int i &#x3D; 1; i &lt; 31; ++i) &#123;
    fa[root][i] &#x3D; fa[fa[root][i - 1]][i - 1];
    cost[root][i] &#x3D; cost[fa[root][i - 1]][i - 1] + cost[root][i - 1];
  &#125;
  &#x2F;&#x2F; 遍历子节点来进行 dfs。
  int sz &#x3D; v[root].size();
  for (int i &#x3D; 0; i &lt; sz; ++i) &#123;
    if (v[root][i] &#x3D;&#x3D; fno) continue;
    cost[v[root][i]][0] &#x3D; w[root][i];
    dfs(v[root][i], root);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="倍增算法">倍增算法</h4>
<p><img src="C:%5CUsers%5CHiroshi%5CDesktop%5C%E6%8D%95%E8%8E%B7.PNG" srcset="/img/loading.gif" lazyload alt="倍增"></p>
<p>时间复杂度为<strong>O(nlogn)</strong></p>
<p><strong>基础模板代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 5e5 + 5;
int n, m, s;
int lg[maxn];
int dep[maxn];
int fa[maxn][25];
vector&lt;int&gt; G[maxn];

void getdep(int u)   
&#123;       &#x2F;&#x2F;求祖先数组
    for (int i &#x3D; 1; i &lt;&#x3D; lg[dep[u]]; i++)
        fa[u][i] &#x3D; fa[fa[u][i - 1]][i - 1];
    for (int i &#x3D; 0; i &lt; G[u].size(); i++)
    &#123;
        &#x2F;&#x2F;遍历u所有边
        int e &#x3D; G[u][i];
        if (e !&#x3D; fa[u][0])
        &#123;
            fa[e][0] &#x3D; u;
            dep[e] &#x3D; dep[u] + 1;
            getdep(e);
        &#125;
    &#125;
&#125;

int lca(int u,int v)
&#123;
    if (dep[u] &lt; dep[v])
        swap(u, v);
    while (dep[u] !&#x3D; dep[v])
        u &#x3D; fa[u][lg[dep[u] - dep[v]]];
    if (u &#x3D;&#x3D; v)
        return u;
    for (int j &#x3D; lg[dep[u]]; j &gt;&#x3D; 0; j--)
    &#123;
        if (fa[u][j] !&#x3D; fa[v][j])
        &#123;
            u &#x3D; fa[u][j];
            v &#x3D; fa[v][j];
        &#125;
    &#125;
    return fa[u][0];
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        lg[i] &#x3D; lg[i - 1];
        if (i &#x3D;&#x3D; (1 &lt;&lt; lg[i - 1]))
            lg[i]++;
    &#125;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        lg[i]--;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    &#123;
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        G[u].push_back(v);&#x2F;&#x2F;无向图 
        G[v].push_back(u);
    &#125;
    &#x2F;&#x2F;无向图可以用任意一个节点当做根节点
    &#x2F;&#x2F;选择初始化1的深度为1，以1为根节点建树
    dep[1] &#x3D; 1;
    getdep(1);
    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)
    &#123;
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        cout &lt;&lt; lca(x, y) &lt;&lt; endl;
    &#125;
        return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>例题<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2586">HDU 2586 How far away?</a></p>
<p>思路:只需要在LCA中执行上跳的操作时，加上对应的长度，就可以求得需要距离。</p>
<p>题解</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn&#x3D;4e4+5;
int n,m;
int lg[maxn];
int dep[maxn];  &#x2F;&#x2F;深度
int f[maxn][25];
int value[maxn][25];
vector&lt;int&gt; a[maxn],w[maxn];
void init()
&#123;
  memset(dep, 0, sizeof dep);
  memset(f, 0, sizeof f);
  memset(value, 0, sizeof value);
  for (int i &#x3D; 0; i &lt; maxn; i++)
  &#123;
    a[i].clear();
    w[i].clear();
  &#125;
&#125;
void getdep(int u)
&#123;
  &#x2F;&#x2F;完善祖先数组和到这个祖先长度的数组
  for (int i &#x3D; 1; i &lt;&#x3D; lg[dep[u]]; i++)
  &#123;
    f[u][i] &#x3D; f[f[u][i - 1]][i - 1];
    value[u][i] &#x3D; value[u][i - 1] + value[f[u][i - 1]][i - 1];
  &#125;
  &#x2F;&#x2F;遍历所有u的边
  for (int i &#x3D; 0; i &lt; a[u].size(); i++)
  &#123;
    int e &#x3D; a[u][i];
    &#x2F;&#x2F;不遍历父亲的边
    if (e !&#x3D; f[u][0])
    &#123;
      &#x2F;&#x2F;无向图不能在录入边时记录父亲，所以在这记录
      f[e][0] &#x3D; u;
      &#x2F;&#x2F;记录的点是到父亲的长度
      value[e][0] &#x3D; w[u][i];
      dep[e] &#x3D; dep[u] + 1;
      getdep(e);
    &#125;
  &#125;
&#125;
int lca(int u, int v)
&#123;
  int sum &#x3D; 0;
  if (dep[u] &lt; dep[v])
  &#123;
    swap(u, v);
  &#125;
  while (dep[u] !&#x3D; dep[v])
  &#123;
    &#x2F;&#x2F;u节点上跳的同时，更新总长度
    sum +&#x3D; value[u][lg[dep[u] - dep[v]]];
    u &#x3D; f[u][lg[dep[u] - dep[v]]];
  &#125;
  &#x2F;&#x2F;如果v是u祖先；直接返回现在的总长度；
  if (u &#x3D;&#x3D; v)
    return sum;
  for (int j &#x3D; lg[dep[u]]; j &gt;&#x3D; 0; j--)
  &#123;
    if (f[u][j] !&#x3D; f[v][j])
    &#123;
      &#x2F;&#x2F;节点上跳的同时，更新总长度
      sum +&#x3D; value[u][j];
      sum +&#x3D; value[v][j];
      u &#x3D; f[u][j];
      v &#x3D; f[v][j];
    &#125;
  &#125;
  &#x2F;&#x2F;u和v离LCA还差一步，加上这两个距离。
  sum +&#x3D; value[u][0];
  sum +&#x3D; value[v][0];
  return sum;
&#125;
int main()
&#123;
  &#x2F;&#x2F;lg[i]中是i内最大的2的幂次数，如lg【5】中值为2，代表2^2是5内最大2的幂次数。
  for (int i &#x3D; 1; i &lt; maxn; i++)
  &#123;
    lg[i] &#x3D; lg[i - 1];
    if (i &#x3D;&#x3D; (1 &lt;&lt; lg[i - 1]))
      lg[i]++;
  &#125;
  for (int i &#x3D; 1; i &lt; maxn; i++)
  &#123;
    lg[i]--;
  &#125;
  &#x2F;&#x2F;t组样例
  int t;
  cin &gt;&gt; t;
  while (t--)
  &#123;
    &#x2F;&#x2F;初始化
    init();
    &#x2F;&#x2F;n个节点，m次询问
    cin &gt;&gt; n &gt;&gt; m;
    for (int i &#x3D; 1; i &lt; n; i++)
    &#123;
      int u, v, k;
      cin &gt;&gt; u &gt;&gt; v &gt;&gt; k;
      &#x2F;&#x2F;无向图建边两次
      &#x2F;&#x2F;都加上边权
      a[u].push_back(v);
      w[u].push_back(k);
      a[v].push_back(u);
      w[v].push_back(k);
    &#125;
    &#x2F;&#x2F;无向图任意节点都可以为根节点，这里选了1做根节点
    dep[1] &#x3D; 1;
    getdep(1);
    for (int i &#x3D; 0; i &lt; m; i++)
    &#123;
      int x, y;
      cin &gt;&gt; x &gt;&gt; y;
      cout &lt;&lt; lca(x, y) &lt;&lt; endl;
    &#125;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>LCA还可以用tarjan算法求,这里不拓展总结。</p>
<hr>
<h3 id="Tarjan算法">Tarjan算法</h3>
<h4 id="Tarjan求强连通分量">Tarjan求强连通分量</h4>
<p>在 Tarjan 算法中为每个结点<strong>u</strong>维护了以下几个变量：</p>
<ul>
<li>dfn[u]:深度优先搜索遍历时结点<strong>u</strong>被搜索的次序</li>
<li>low[u]:<strong>u</strong>在图中可以到达最小的dfn</li>
</ul>
<p>性质:</p>
<ul>
<li>每个结点的dfn都是不一样的</li>
<li>每次在dfn中找到新结点时，该结点的dfn和low赋相同值</li>
<li>一个结点的子树内结点的 dfn 都大于该结点的 dfn从根开始的一条路径上的<strong>dfn 严格递增</strong>，<strong>low 严格非降</strong>。</li>
</ul>
<p><strong>伪代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">tarjan(u)&#123;
    DFN[u]&#x3D;Low[u]&#x3D;++Index	&#x2F;&#x2F;为节点u设定次序编号和Low初值
    Stack.push(u)			&#x2F;&#x2F;将节点u压入栈中
 	
    foreach(u,v) in E		&#x2F;&#x2F;枚举每一条边
	if(v is not visted)	&#x2F;&#x2F;如果节点v未被访问过
	    tarjan(v)		&#x2F;&#x2F;继续向下找
	    Low[u]&#x3D;min(Low[u],Low[v])
	else if(v in S)		&#x2F;&#x2F;如果节点v还在栈内
		Low[u]&#x3D;min(Low[u],DFN[v])
    if(DFN[u]&#x3D;&#x3D;Low[u])	&#x2F;&#x2F;如果节点u是强连通分量的根
	repeat
		v&#x3D;S.pop&#x2F;&#x2F;将v退栈，为该强连通分量中一个顶点
		print v
	until(u&#x3D;&#x3D;v)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为<strong>O(N+M)</strong>。N为点数，M为边数。</p>
<p><strong>模板代码（手动模拟栈）</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
const int MAX &#x3D; 10005;
#define ll long long

vector&lt;ll&gt; g[MAX];
ll color[MAX], vis[MAX], stack[MAX], dfn[MAX], low[MAX], cnt[MAX];
&#x2F;&#x2F;deep:节点编号 top：栈顶  sum：强连通分量数目
ll deep, top, sum, res &#x3D; 0;

void tanjan(ll v)
&#123;
  dfn[v] &#x3D; ++deep;
	low[v] &#x3D; deep;   &#x2F;&#x2F;(1)初始化dfn数组，同时将low设置为相同值
	vis[v] &#x3D; 1;
	stack[++top] &#x3D; v;&#x2F;&#x2F;(2)入栈，作为栈顶元素，同时更新vis数组

  for (unsigned i &#x3D; 0; i &lt; g[v].size(); i++)
  &#123; &#x2F;&#x2F;(3)遍历所有可能到达的点
    ll id &#x3D; g[v][i];
		if (!dfn[id]) &#123;&#x2F;&#x2F;如果这个点从没访问过，则先访问它更新low[v]的值
			tanjan(id);
      low[v] &#x3D; min(low[v], low[id]); &#x2F;&#x2F;他的儿子如果能连到更小的祖先节点，显然他也可以
    &#125;
		else &#123;
      if (vis[id])
      &#123; &#x2F;&#x2F;不在栈中的点，要么没有访问，要么不能到达id，所以只需要判断栈中的
        low[v] &#x3D; min(low[v], low[id]);
      &#125;
    &#125;
  &#125;

  if (low[v] &#x3D;&#x3D; dfn[v])
  &#123; &#x2F;&#x2F;(4)自己和子节点形成了强连通分量，或者只有自己孤身一人
    color[v] &#x3D; ++sum;
		vis[v] &#x3D; 0;
    while (stack[top] !&#x3D; v)
    &#123;                         &#x2F;&#x2F;将从v开始所有的点取出
      color[stack[top]] &#x3D; sum;&#x2F;&#x2F;给予同一颜色
			vis[stack[top--]] &#x3D; 0;&#x2F;&#x2F;出栈要顺便修改vis
    &#125;
    top--;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="Tarjan缩点">Tarjan缩点</h4>
<p>仍使用了求强连通分量的方法，适用于<strong>具有传递性</strong>的题面，如路径权值之类。</p>
<p>原理：一个强连通分量中的每两个点都是强连通的，可以将一个强连通分量缩小成一个点，点权如何计算根据题意而定。</p>
<p><strong>部分代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; g[MAX];
int color[MAX], vis[MAX], stack[MAX], dfn[MAX], low[MAX], cnt[MAX], num[MAX];
int ind[MAX], outd[MAX];&#x2F;&#x2F;每个点的出度入度
&#x2F;&#x2F;deep:节点编号 top：栈顶  sum：强连通分量数目
int deep, top, sum, res &#x3D; 0;

void tanjan(int v) &#123;
	dfn[v] &#x3D; ++deep;
	low[v] &#x3D; deep;   &#x2F;&#x2F;(1)初始化dfn数组，同时将low设置为相同值
	vis[v] &#x3D; 1;
	stack[++top] &#x3D; v;&#x2F;&#x2F;(2)入栈，作为栈顶元素，同时更新vis数组

	for (unsigned i &#x3D; 0; i &lt; g[v].size(); i++) &#123;&#x2F;&#x2F;(3)遍历所有可能到达的点
		int id &#x3D; g[v][i];
		if (!dfn[id]) &#123;&#x2F;&#x2F;如果这个点从没访问过，则先放问它，再用它更新low[v]的值
			tanjan(id);
			low[v] &#x3D; min(low[v], low[id]); &#x2F;&#x2F;他的儿子如果能连到更小的祖先节点，显然他也可以
		&#125;
		else &#123;
			if (vis[id]) &#123;&#x2F;&#x2F;不在栈中的点，要么没有访问，要么不能到达id，所以只需要判断栈中的
				low[v] &#x3D; min(low[v], low[id]);
			&#125;
		&#125;
	&#125;

	if (low[v] &#x3D;&#x3D; dfn[v]) &#123;&#x2F;&#x2F;(4)自己和子节点形成了强连通分量，或者只有自己孤身一人
		color[v] &#x3D; ++sum; num[sum]++; &#x2F;&#x2F;num统计该颜色有多少点
		vis[v] &#x3D; 0;
		while (stack[top] !&#x3D; v) &#123;&#x2F;&#x2F;将从v开始所有的点取出
			color[stack[top]] &#x3D; sum;&#x2F;&#x2F;给予同一颜色
			vis[stack[top--]] &#x3D; 0;&#x2F;&#x2F;出栈要顺便修改vis
			num[sum]++;
		&#125;
		top--;
	&#125;
&#125;
int main()&#123;
	for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123;
		for (unsigned k &#x3D; 0; k &lt; g[i].size(); k++) &#123;
			int v &#x3D; g[i][k];
			if (color[v] !&#x3D; color[i]) &#123;&#x2F;&#x2F;二者分属于不同的联通集
				outd[color[i]] +&#x3D; 1; &#x2F;&#x2F;以颜色作为点，更新相应点的出度
			&#125;
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="Tarjan割点、割桥">Tarjan割点、割桥</h4>
<p>能力不足，日后再补</p>
<hr>
<h3 id="欧拉图">欧拉图</h3>
<p>定义</p>
<ul>
<li>
<p>在图上用<strong>一种走法</strong>，能够经过所有的边一次，且每条边只经过一次的路径，即为<strong>欧拉路径</strong></p>
</li>
<li>
<p>通过图中所有边恰好一次且行遍所有顶点的<strong>通路</strong>称为<strong>欧拉通路</strong></p>
</li>
<li>
<p>通过图中所有边恰好一次且行遍所有顶点的<strong>回路</strong>(回到起点)称为<strong>欧拉回路</strong>(所有点的入度等于出度)</p>
</li>
<li>
<p>具有欧拉回路的无向图或有向图称为欧拉图</p>
</li>
<li>
<p>具有欧拉通路但不具有欧拉回路的无向图或有向图称为半欧拉图</p>
</li>
</ul>
<p>性质</p>
<ul>
<li><strong>欧拉图</strong>中所有顶点的度数都是<strong>偶数</strong></li>
</ul>
<h4 id="Hierholzer-算法">Hierholzer 算法</h4>
<p>思想：</p>
<ul>
<li>判断奇点数，为0则随意指定起点，若为2则其一为起点</li>
<li>从一个起点出发，进行DFS，每次从一个顶点到另一个顶点时，都要删除两顶点之间的边，如果没有可移动的边，则将该顶点加入栈中</li>
<li>输出栈中顶点，该顺序即是从起点出发的欧拉路径</li>
</ul>
<p>例题  <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2731">骑马修栅栏</a></p>
<p>题解</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
using namespace std;

struct edge &#123;
  int to;
  bool exists;
  int revref;
  bool operator&lt;(const edge &amp;b) const
  &#123;
    return to &lt; b.to;
  &#125;
&#125;;

vector&lt;edge&gt; beg[505];
int cnt[505];

const int dn &#x3D; 500;
stack&lt;int&gt; ans;

void Hierholzer(int x)
&#123;
  for (int &amp;i &#x3D; cnt[x]; i &lt; (int)beg[x].size();)
  &#123;
    if (beg[x][i].exists)
    &#123;
      edge e &#x3D; beg[x][i];
      beg[x][i].exists &#x3D; 0;
      beg[e.to][e.revref].exists &#x3D; 0;
      ++i;
      Hierholzer(e.to);
    &#125; else &#123;
      ++i;
    &#125;
  &#125;
  ans.push(x);
&#125;

int deg[505];
int reftop[505];

int main()
&#123;
  for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i)
  &#123;
    beg[i].reserve(1050);
  &#125;

  int m;
  scanf(&quot;%d&quot;, &amp;m);
  for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) 
  &#123;
    int a, b;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    beg[a].push_back((edge)&#123;b, 1, 0&#125;);
    beg[b].push_back((edge)&#123;a, 1, 0&#125;);
    ++deg[a];
    ++deg[b];
  &#125;

  for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i)
  &#123;
    if (!beg[i].empty())
    &#123;
      sort(beg[i].begin(), beg[i].end());  &#x2F;&#x2F; 为了要按字典序贪心，必须排序
    &#125;
  &#125;

  for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i)
  &#123;
    for (int j &#x3D; 0; j &lt; (int)beg[i].size(); ++j)
    &#123;
      beg[i][j].revref &#x3D; reftop[beg[i][j].to]++;
    &#125;
  &#125;

  int bv &#x3D; 0;
  for (int i &#x3D; 1; i &lt;&#x3D; dn; ++;i)
  &#123;
    if (!deg[bv] &amp;&amp; deg[i])
    &#123;
      bv &#x3D; i;
    &#125;
    else if (!(deg[bv] &amp; 1) &amp;&amp; (deg[i] &amp; 1))
    &#123;
      bv &#x3D; i;
    &#125;
  &#125;

  Hierholzer(bv);

  while (!ans.empty())
  &#123;
    printf(&quot;%d\n&quot;, ans.top());
    ans.pop();
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>题解2</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
int map[10001][10001];&#x2F;&#x2F;记录两个点之间的路径个数 
int du[10001];&#x2F;&#x2F;辅助记录奇点 
int lu[10001];&#x2F;&#x2F;记录路径 
int n,x,y,js&#x3D;0;
int maxn&#x3D;0;
void find(int i)&#x2F;&#x2F;
&#123;
	int j;
	for(j&#x3D;1;j&lt;&#x3D;maxn;++j)&#x2F;&#x2F;而且这里不是n而是maxn因为n不是点的个数而是下面有多少行 
	&#123;
		if(map[i][j]&gt;&#x3D;1)
		&#123;
			map[i][j]--;&#x2F;&#x2F;删去边一次吗避免重复 
			map[j][i]--;&#x2F;&#x2F;z这里和一笔画不一样这里是累减而一笔画直接变成0 
			find(j);
		&#125;
	&#125;
	lu[++js]&#x3D;i;
&#125;
int main()
&#123;
	scanf(&quot;%d&quot;,&amp;n);
	for(int i&#x3D;1;i&lt;&#x3D;n;++i)
	&#123;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		map[x][y]++;
		map[y][x]++;
		du[x]++;
		du[y]++;&#x2F;&#x2F;记录出现的次数 
		maxn&#x3D;max(maxn,max(x,y));
	&#125;
	int start&#x3D;1;&#x2F;&#x2F;默认奇点是1 
	for(int i&#x3D;1;i&lt;&#x3D;maxn;++i)
	&#123;
		if(du[i]%2)&#x2F;&#x2F;找到奇点 
		&#123;
			start&#x3D;i;&#x2F;&#x2F;记录奇点
			break;&#x2F;&#x2F;然后结束循环 
		&#125;
	&#125;
	find(start);&#x2F;&#x2F;从奇点开始找 
	for(int i&#x3D;js;i&gt;&#x3D;1;i--)
	&#123;
		printf(&quot;%d\n&quot;,lu[i]);&#x2F;&#x2F;挨个输出路径并且换行 
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>注意，不能在递归的同时进行输出，输出的路径是错误的</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int x)&#x2F;&#x2F;错误输出
&#123;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(a[i][x])
	&#123;
		printf(&quot;%d\n&quot;,x);
		a[i][x]--;a[x][i]--;
		dfs(i);
	&#125;
&#125;
int main()
&#123;
	&#x2F;&#x2F;……
    printf(&quot;%d&quot;,&amp;s);&#x2F;&#x2F;s是起点
    dfs(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int x)&#x2F;&#x2F;正确输出
&#123;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(a[i][x])
	&#123;
		a[i][x]--;a[x][i]--;
		dfs(i);
	&#125;
	p[size++]&#x3D;x;
&#125;
int main()
&#123;
	&#x2F;&#x2F;……
	dfs(s);
	for(int i&#x3D;size-1;i&gt;&#x3D;0;i--)printf(&quot;%d\n&quot;,p[i]);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="二分图">二分图</h3>
<p>定义：节点由两个集合组成，且两个集合内部没有边的图。</p>
<p>性质</p>
<ul>
<li>如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。</li>
<li>二分图不存在长度为奇数的环</li>
</ul>
<h4 id="二分图判定">二分图判定</h4>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/11/">AcWing-860染色法判定二分图</a></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;dfs染色法
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;
const int N &#x3D; 1e5 + 10, M &#x3D; 2e5 + 10;
int n, m;
int h[N], e[M], ne[M], idx; &#x2F;&#x2F;邻接表的存储
int color[N];

void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

bool dfs(int u, int c)
&#123;
    color[u] &#x3D; c; &#x2F;&#x2F;当前这个点u的颜色是 c

    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])
    &#123;
        int j &#x3D; e[i];
        if (!color[j]) &#x2F;&#x2F;u 的邻接点 j 未被染色
        &#123;
            dfs(j, 3 - c); &#x2F;&#x2F; u的颜色如果是1，j就是3-1&#x3D;2；u的颜色如果是2，j就是3-2&#x3D;1
        &#125;
        else if (color[j] &#x3D;&#x3D; c)
            return false; &#x2F;&#x2F;两邻接点染相同颜色
    &#125;
    return true;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));

    while (m--)
    &#123;
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a); &#x2F;&#x2F; 无向图建两条相反方向的边
    &#125;

    bool flag &#x3D; true;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;遍历图的所有点
        if (!color[i])
        &#123;
            if (!dfs(i, 1))
            &#123;
                flag &#x3D; false;
                break;
            &#125;
        &#125;

    if (flag)
        cout &lt;&lt; &quot;Yes&quot;;
    else
        cout &lt;&lt; &quot;No&quot;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;bfs染色法
&#x2F;&#x2F;不建议使用
&#x2F;&#x2F;太玄幻了根本看不懂还是把代码粘贴进来吧
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
typedef pair&lt;int, int&gt; PII; &#x2F;&#x2F;first存点编号，second存颜色
const int N &#x3D; 1e5 + 10, M &#x3D; 2e5 + 10;
int n, m;
int h[N], e[M], ne[M], idx; &#x2F;&#x2F;邻接表的存储
int color[N];

void add(int a, int b)
&#123;
    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;
&#125;

bool bfs(int u)
&#123;
    queue&lt;PII&gt; q;
    q.push(&#123;u, 1&#125;);
    color[u] &#x3D; 1; &#x2F;&#x2F;当前这个点u的颜色是 c

    while (q.size()) &#x2F;&#x2F;队列不空
    &#123;
        PII t &#x3D; q.front();
        q.pop();

        int ver &#x3D; t.first, c &#x3D; t.second;
        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])
        &#123;
            int j &#x3D; e[i];

            if (!color[j]) &#x2F;&#x2F;未被染色
            &#123;
                color[j] &#x3D; 3 - c;
                q.push(&#123;j, 3 - c&#125;);
            &#125;
            else if (color[j] &#x3D;&#x3D; c)
                return false; &#x2F;&#x2F;两邻接点染相同颜色
        &#125;
    &#125;
    return true;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    memset(h, -1, sizeof(h));

    while (m--)
    &#123;
        int a, b;
        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
        add(a, b), add(b, a); &#x2F;&#x2F; 无向图建两条相反方向的边
    &#125;

    bool flag &#x3D; true;
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;遍历图的所有点
        if (!color[i])
        &#123;
            if (!bfs(i))
            &#123;
                flag &#x3D; false;
                break;
            &#125;
        &#125;

    if (flag)
        cout &lt;&lt; &quot;Yes&quot;;
    else
        cout &lt;&lt; &quot;No&quot;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="增广路算法">增广路算法</h4>
<p><strong>匹配</strong>：一个边集中的<strong>任意两条边</strong>都不依附于<strong>同一个顶点</strong>，则称这个边集是一个匹配。</p>
<p><strong>最大匹配</strong>：在匹配的基础上让边最大。</p>
<p><em>通俗理解可以看成<strong>左边</strong>一个集合是所有<strong>男孩</strong>，<strong>右边</strong>一个集合是所有<strong>女孩</strong>，我们需要求<strong>最多可以凑成几对情侣</strong>。</em></p>
<p><strong>增广路</strong>：增广路径是指，由一个<strong>未匹配</strong>的顶点开始，经过若干个<strong>匹配</strong>顶点，最后到达对面集合的一个未匹配顶点的路径，即这条路径将两个不同集合的两个未匹配顶点通过一系列匹配顶点相连。</p>
<p><strong>增广路算法例题</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 600 + 5;
bool line[maxn][maxn];
&#x2F;&#x2F;line[x][y]&#x3D;true表示x号女生喜欢y男生(边）
int boy[maxn];
&#x2F;&#x2F;存储y号男生匹配边另一端的匹配点女生，如果是未覆盖点则为0
bool falg[maxn];
&#x2F;&#x2F;存储y号男生是否在这条交替路上被使用过,男生是否被别人喜欢
int k, n, m;
bool dfs(int x)
&#123;

    for (int j &#x3D; 1; j &lt;&#x3D; m; j++)
    &#123;
        if (line[x][j] &amp;&amp; !falg[j])
        &#123;
            falg[j] &#x3D; true;
            if (!boy[j] || dfs(boy[j]))
            &#123;
                &#x2F;&#x2F;满足上面的判断语句说明找到了增广路
                &#x2F;&#x2F;即终点是未覆盖点的交替路
                boy[j] &#x3D; x;
                return true;
            &#125;
        &#125;
        &#x2F;&#x2F;该条路不是增广路
    &#125;

    return false;
&#125;
int main()
&#123;
    while (cin &gt;&gt; k)
    &#123;
        if (!k)
            break;
        cin &gt;&gt; n &gt;&gt; m;
        int x, y;
        int ans &#x3D; 0;
        memset(line, false, sizeof(line));&#x2F;&#x2F;初始化
        memset(boy, 0, sizeof(boy));
        while (k--)
        &#123;
            cin &gt;&gt; x &gt;&gt; y;
            line[x][y] &#x3D; true;
        &#125;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        &#123;
            memset(falg, false, sizeof(falg));&#x2F;&#x2F;每次循环都要初始化flag
            if (dfs(i))
                ans++;
        &#125;
        cout &lt;&lt; ans &lt;&lt; endl;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="C-高精度">C++高精度</h3>
<p><strong>高精度四则运算</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

struct bign &#x2F;&#x2F;大整数数组
&#123;
    int len; &#x2F;&#x2F;位数
    int num[1000];
&#125;;
&#x2F;&#x2F;大整数转换
bign change(char a[])
&#123;
    bign c;
    c.len &#x3D; strlen(a);
    for (int i &#x3D; 0; i &lt; c.len; i++)
    &#123;
        c.num[i] &#x3D; a[c.len - i - 1] - &#39;0&#39;;
    &#125;
    return c;
&#125;
&#x2F;&#x2F;大整数比较
int compare(bign a, bign b)
&#123;                      &#x2F;&#x2F;大于返回1，小于返回-1，相等返回0
    if (a.len &gt; b.len) &#x2F;&#x2F;位数多的数比位数少的数大
        return 1;
    if (a.len &lt; b.len)
        return -1;
    for (int i &#x3D; a.len - 1; i &gt;&#x3D; 0; i--)
    &#123; &#x2F;&#x2F;位数相同，高位到低位逐位比较
        if (a.num[i] &gt; b.num[i])
            return 1;
        else if (a.num[i] &lt; b.num[i])
            return -1;
    &#125;
    return 0; &#x2F;&#x2F;执行到最后肯定相等
&#125;

bign add_bign(bign a, bign b)
&#123;
    bign c;
    for (int i &#x3D; 0; i &lt; a.len || i &lt; b.len; i++)
    &#123;                                  &#x2F;&#x2F;以位数长的结束条件
        c.num[c.len] +&#x3D; a.num[i] + b.num[i]; &#x2F;&#x2F;对应位置相加再加上进位
        if (c.num[c.len] &gt;&#x3D; 10)
        &#123;                     &#x2F;&#x2F;大于等于10需要进位
            c.num[c.len + 1]++; &#x2F;&#x2F;进位加到前一位上
            c.num[c.len] -&#x3D; 10; &#x2F;&#x2F;更新原位置的值
        &#125;
        c.len++;
    &#125;
    if (c.num[c.len]) &#x2F;&#x2F;最高位不为零长度加一
        c.len++;
    return c;
&#125;

bign sub_bign(bign a, bign b)
&#123;
    bign c;
    for (int i &#x3D; 0; i &lt; a.len || i &lt; b.len; i++)
    &#123; &#x2F;&#x2F;以位数长的结束条件
        if (a.num[i] &lt; b.num[i])
        &#123; &#x2F;&#x2F;如果同位的被减数比减数小需要借位
            a.num[i] +&#x3D; 10;
            a.num[i + 1]--;
        &#125;
        c.num[c.len++] &#x3D; a.num[i] - b.num[i];
    &#125;
    while (c.len &gt; 1 &amp;&amp; !c.num[c.len - 1]) &#x2F;&#x2F;消除前缀零
        c.len--;
    return c;
&#125;

bign mutli_bign(bign a, bign b)
&#123;
    bign c;
    for (int i &#x3D; 0; i &lt; a.len; i++) &#x2F;&#x2F;大数a逐位乘大数b
        for (int j &#x3D; 0; j &lt; b.len; j++)
        &#123;
            c.num[i + j] +&#x3D; a.num[i] * b.num[j]; &#x2F;&#x2F;a的第i位乘b的第j位加上进位
            if (c.num[i + j] &gt;&#x3D; 10)
            &#123; &#x2F;&#x2F;大于等于十进位
                c.num[i + j + 1] +&#x3D; c.num[i + j] &#x2F; 10;
                c.num[i + j] %&#x3D; 10;
            &#125;
        &#125;
    c.len &#x3D; a.len + b.len;                   &#x2F;&#x2F;两个数乘积的位数不超过两个数位数之和
    while (c.len &gt; 1 &amp;&amp; c.num[c.len - 1] &#x3D;&#x3D; 0) &#x2F;&#x2F;取出前导零
        c.len--;
    return c;
&#125;

bign div_bign(bign a, bign b)
&#123;
    bign c;
    c.len &#x3D; a.len - b.len + 1; &#x2F;&#x2F;求商的位置
    for (int i &#x3D; c.len - 1; i &gt;&#x3D; 0; i--)
    &#123;
        bign temp;
        for (int j &#x3D; 0; j &lt; b.len; j++) &#x2F;&#x2F;b补零存在临时数组
            temp.num[j + i] &#x3D; b.num[j];
        temp.len &#x3D; b.len + i;
        while (compare(a, temp) &gt;&#x3D; 0)
        &#123;                      &#x2F;&#x2F;a的高b.len位比temp小重新补零
            c.num[i]++;          &#x2F;&#x2F;累计减的次数
            sub_bign(a, temp); &#x2F;&#x2F;大整数减法
        &#125;
    &#125;
    while (c.len &gt; 1 &amp;&amp; !c.num[c.len - 1]) &#x2F;&#x2F;消去前导零
        c.len--;
    return c;
&#125;

char a[1000], b[1000];

int main()
&#123;
    &#x2F;*cin &gt;&gt; a &gt;&gt; b;
    bign a1 &#x3D; change(a);
    bign b1 &#x3D; change(b);
    bign c &#x3D; add_bign(a1, b1);
    for (int i &#x3D; c.len - 1; i &gt;&#x3D; 0; --i)
        cout &lt;&lt; c.num[i];*&#x2F;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="JAVA高精度">JAVA高精度</h3>
<p><strong>高精度加法</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;package com.company;交题的时候不需要这一行

import java.math.BigInteger;
import java.util.Scanner;

public class Main&#123;
    public static void main(String[] args)&#123;
        Scanner in&#x3D;new Scanner(System.in);
        BigInteger a&#x3D;in.nextBigInteger();
        BigInteger b&#x3D;in.nextBigInteger();
        System.out.println(a.add(b));
    &#125;&#x2F;&#x2F;减法换成subtract，乘法换成multiply，除法换成divide
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>求大整数的阶乘</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;package com.company;

import java.math.BigInteger;
import java.util.Scanner;

public class Mai n&#123;

    public static void main(String[] args)&#123;
        &#x2F;&#x2F; write your code here
        Scanner in&#x3D;new Scanner(System.in);
        BigInteger ans&#x3D;BigInteger.ONE;
        int n&#x3D;in.nextInt();
        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;
            ans&#x3D;ans.multiply(BigInteger.valueOf(i));
        &#125;
        System.out.println(ans);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="高精度整数BigInteger">高精度整数BigInteger</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String temp1 &#x3D; &quot;-1000000000000000000000000000000000000&quot;;
BigInteger bg1 &#x3D; new BigInteger(temp1);          &#x2F;&#x2F;注意初始化的方式,使用字符串来初始化
System.out.println(bg1.abs());                   &#x2F;&#x2F;绝对值方法    object.abs()

String temp2 &#x3D; &quot;100000000000000000000000000&quot;;
BigInteger bg2 &#x3D; new BigInteger(temp2);
System.out.println(bg1.add(bg2));                &#x2F;&#x2F;加法    object.add(BigInteger b)

System.out.println(bg1.subtract(bg2));           &#x2F;&#x2F;减法   返回为 bg1 - bg2  (this - param)

System.out.println(bg1.multiply(bg2));           &#x2F;&#x2F;乘法  返回 bg1 * bg2

System.out.println(bg1.divide(bg2));             &#x2F;&#x2F;除法  返回bg1 &#x2F; bg2

System.out.println(bg1.mod(bg2));                &#x2F;&#x2F;取模运算 返回的是   bg1%bg2 (this mod param)

System.out.println(bg1.gcd(bg2));                &#x2F;&#x2F;直接封装好了 求解bg1,bg2 的最大公约数

int temp5 &#x3D; 5;
System.out.println(bg2.pow(temp5));              &#x2F;&#x2F;乘方运算  注意这个方法的参数是基本类型int

System.out.println(bg2.compareTo(bg1));          &#x2F;&#x2F; 比较方法 结果为1  bg2大
System.out.println(bg1.compareTo(bg2));          &#x2F;&#x2F; 结果为-1  bg2大
                                                 &#x2F;&#x2F;这个地方注意比较的方法，还有一个方法是equal()
String temp3 &#x3D; &quot;1000&quot;;
String temp4 &#x3D; &quot;001000&quot;;
BigInteger bg3  &#x3D; new BigInteger(temp3);
BigInteger bg4 &#x3D; new BigInteger(temp4);
System.out.println(bg3.compareTo(bg4));          &#x2F;&#x2F;结果为0 表示相等
System.out.println(bg3.equals(bg4));             &#x2F;&#x2F;返回结果为true     这样看是没有区别，但是更推荐比较的时候使用compareTo()方法，
                                                 &#x2F;&#x2F;在BigDecimal更直观，例如0.1 与0.10 ，equal返回false 而compareTo则是正确的结果。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="高精度浮点数">高精度浮点数</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">String temp1 &#x3D; &quot;1.2222222222222222222222222&quot;;
BigDecimal bd1 &#x3D; new BigDecimal(temp1);
String temp2 &#x3D; &quot;2.333333333333333333333333&quot;;
BigDecimal bd2 &#x3D; new BigDecimal(temp2);
System.out.println(bd1.add(bd2)); &#x2F;&#x2F; 加法  输出   3.5555555555555555555555552
System.out.println(bd1.add(bd2).doubleValue());         &#x2F;&#x2F; 输出    3.5555555555555554 这里用了一个方法将结果转化为double类型了

System.out.println(bd2.subtract(bd1)); &#x2F;&#x2F;减法    输出 1.1111111111111111111111108
System.out.println(bd2.subtract(bd1).doubleValue());    &#x2F;&#x2F;输出   1.1111111111111112

System.out.println(bd2.multiply(bd1)); 			&#x2F;&#x2F;乘法 输出    2.8518518518518518518518513925925925925925925925926
System.out.println(bd2.multiply(bd1).doubleValue());    &#x2F;&#x2F;乘法    2.8518518518518516

System.out.println(bd2.divide(bd1, 5, RoundingMode.HALF_UP));             &#x2F;&#x2F;除法应该注意很有可能会有除不尽的情况，这时候会有异常抛出，所以要传入控制参数
System.out.println(bd2.divide(bd1, 5, RoundingMode.HALF_UP).doubleValue());     &#x2F;&#x2F;输出都是  1.90909

System.out.println(bd1.compareTo(bd2));          &#x2F;&#x2F;比较方法
BigDecimal bd3 &#x3D; new BigDecimal(&quot;1.20&quot;);
BigDecimal bd4 &#x3D; new BigDecimal(&quot;1.2&quot;);
System.out.println(bd3.compareTo(bd4));          &#x2F;&#x2F;返回0表示相等
System.out.println(bd3.equals(bd4));             &#x2F;&#x2F;返回的是false  是错误的
                                                 &#x2F;&#x2F;所以比较的时候使用compareTo()方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="素数筛法">素数筛法</h3>
<h4 id="六倍原理">六倍原理</h4>
<p>除了2和3以外，其余素数都与<strong>6的倍数</strong>相邻，满足6x+1和6x-1。也就是说大于3的质数一定和6相邻</p>
<h4 id="埃氏筛法">埃氏筛法</h4>
<p>原理：要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。</p>
<p>模板代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
using namespace std;
bool is_prime[1000];
int main()
&#123;
    int n;
    cin &gt;&gt; n;
    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)
        is_prime[i] &#x3D; true; &#x2F;&#x2F;初始化所有的数为素数
    for (int i &#x3D; 2; i &lt;&#x3D; sqrt(n); i++)
    &#123; &#x2F;&#x2F;从第一个素数2开始筛选
        if (is_prime[i])
        &#123; &#x2F;&#x2F;如果是素数
            for (int j &#x3D; i * i; j &lt;&#x3D; n; j +&#x3D; i)
            &#123; &#x2F;&#x2F;则剔除掉它的倍数
                is_prime[j] &#x3D; false;
            &#125;
        &#125;
    &#125;
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
    &#123;
        if (is_prime[i])
            cout &lt;&lt; i &lt;&lt; endl;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="欧拉筛法（线性筛）">欧拉筛法（线性筛）</h4>
<p>基本思想：埃氏筛法要重复标记很多次相同的数，在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。</p>
<p><strong>模板代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;题目
&#x2F;&#x2F;求小于等于n的素数的个数，并输出每个素数
#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
int main()
&#123;
    int n, cnt &#x3D; 0;
    int prime[100001]; &#x2F;&#x2F;存素数
    bool vis[100001];  &#x2F;&#x2F;保证不做素数的倍数
    cin &gt;&gt; n;
    memset(vis, false, sizeof(vis)); &#x2F;&#x2F;初始化
    memset(prime, 0, sizeof(prime));
    for (int i &#x3D; 2; i &lt;&#x3D; n; i++)
    &#123;
        if (!vis[i])          &#x2F;&#x2F;不是目前找到的素数的倍数
            prime[cnt++] &#x3D; i; &#x2F;&#x2F;找到素数
        for (int j &#x3D; 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;&#x3D; n; j++)
        &#123;
            vis[i * prime[j]] &#x3D; true; &#x2F;&#x2F;找到的素数的倍数不访问
            if (i % prime[j] &#x3D;&#x3D; 0)
                break; &#x2F;&#x2F;关键！！！！
        &#125;
    &#125;
    cout &lt;&lt; cnt &lt;&lt; endl; &#x2F;&#x2F;总数
    for (int i &#x3D; 0; i &lt; cnt; i++)
        cout &lt;&lt; prime[i] &lt;&lt; endl; &#x2F;&#x2F;输出每个素数
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="最长上升子序列-LIS">最长上升子序列-LIS</h3>
<p><strong>定义</strong>：在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。</p>
<h4 id="朴素算法-2">朴素算法</h4>
<p>dp[i] = max(dp[i], dp[j] + 1) (1 &lt;= j &lt; i, a[j] &lt; a[i])</p>
<p>模板代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;

int a[100];
int dp[100];
int main()
&#123;
    int n;
    fill(dp, dp + sizeof(dp), 1);
    cin &gt;&gt; n;
    for (int i &#x3D; 0; i &lt; n; i++)
        cin &gt;&gt; a[i];
    for (int i &#x3D; 0; i &lt; n; i++) 	&#x2F;&#x2F;两个for循环遍历整个数组并求dp
        for (int j &#x3D; 0; j &lt; i; j++)
        &#123;
            if (a[i] &gt; a[j])&#x2F;&#x2F;满足次条件才能形成升序列
                dp[i] &#x3D; max(dp[i], dp[j] + 1);
        &#125;

    for (int i &#x3D; 0; i &lt; n; i++)
        cout &lt;&lt; dp[i] &lt;&lt; &#39; &#39;;

        return 0;
 &#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="二分-贪心优化">二分+贪心优化</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">#include&lt;iostream&gt;  
#include&lt;string.h&gt;  
#include&lt;algorithm&gt;  
  
using namespace std;
const int maxn &#x3D; 1e5 + 10;
int num[maxn];
const int INF &#x3D; 0x3f3f3f3f;
int slow[maxn], d[maxn];

int main()  
&#123;
	fill(slow, slow + maxn, INF);&#x2F;&#x2F;fill函数初始化
	int n;
	cin &gt;&gt; n;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
		cin &gt;&gt; num[i];
	int len &#x3D; -1;
	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
	&#123;
        int j &#x3D; lower_bound(slow + 1, slow + maxn + 1, num[i]) - slow;&#x2F;&#x2F;二分查找
        d[i] &#x3D; j;
		if (len &lt; d[i])
			len &#x3D; d[i];
		slow[j] &#x3D; num[i];
	&#125;

	cout &lt;&lt; len &lt;&lt; endl;&#x2F;&#x2F;输出最长上升子序列的长度
	return 0;  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h3 id="最长公共子序列-LCS">最长公共子序列-LCS</h3>
<p>定义：一个序列S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。</p>
<h4 id="模板代码-3">模板代码</h4>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
#define IOS std::ios::sync_with_stdio(false)
const int N &#x3D; 1010;
int n, m;
char a[N], b[N];
int dp[N][N];
int main()
&#123;
	memset(dp, 0, sizeof(dp));
	cin &gt;&gt; n &gt;&gt; m;
	for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)
		cin &gt;&gt; a[i];&#x2F;&#x2F;A字符串
	for (int j &#x3D; 1; j &lt;&#x3D; m; ++j)
		cin &gt;&gt; b[j];&#x2F;&#x2F;B字符串
	for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)
		for (int j &#x3D; 1; j &lt;&#x3D; m; ++j)
			if (a[i] &#x3D;&#x3D; b[j])
				dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; &#x2F;&#x2F;左上角的值+1
			else
				dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);&#x2F;&#x2F;左边或上边取最大

	cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#x2F;&#x2F;最长公共序列

	&#x2F;&#x2F;以下是输出该序列
	int i &#x3D; n, j &#x3D; m, index &#x3D; 0;
	char lcs[1005];
	while (i !&#x3D; 0 &amp;&amp; j !&#x3D; 0)
	&#123;
		if (dp[i][j] &#x3D;&#x3D; dp[i][j - 1])&#x2F;&#x2F;反向回退
			j--;
		else if (dp[i][j] &#x3D;&#x3D; dp[i - 1][j])
			i--;
		else
		&#123;
			lcs[index++] &#x3D; a[i];
			i--, j--;
		&#125;
	&#125;
	for (int i &#x3D; index - 1; i &gt;&#x3D; 0; --i)&#x2F;&#x2F;最后一步会index会多加一个1所以要在这里减掉
		cout &lt;&lt; lcs[i];
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><strong>LCS表格</strong></p>
<p>推一遍就懂了</p>
<blockquote>
<p>此处图片丢失</p>
</blockquote>
<hr>
<h3 id="背包">背包</h3>
<h4 id="01背包">01背包</h4>
<p><strong>题目</strong></p>
<p>有<strong>N</strong>件物品和一个容量为<strong>V</strong>的背包。第<strong>i</strong>件物品的费用是<strong>w [ i ]</strong> ，价值**是v [ i ] **，求将哪些物品装入背包可使价值总和最大。</p>
<p><strong>状态转移方程</strong></p>
<p><img src="C:%5CUsers%5CHiroshi%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210815212021791.png" srcset="/img/loading.gif" lazyload alt="image-20210815212021791"></p>
<p><strong>核心代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">memset(dp, 0, sizeof(dp));
for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
&#123;
    for (int j &#x3D; 0; j &lt;&#x3D; m; j++)
    &#123;
        if (j &gt;&#x3D; w[i]) &#x2F;&#x2F;如果背包装得下当前的物体
        &#123;
            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
        &#125;
        else &#x2F;&#x2F;如果背包装不下当前物体
        &#123;
            dp[i][j] &#x3D; dp[i - 1][j];
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">例题</a></p>
<h5 id="优化空间复杂度的01背包">优化空间复杂度的01背包</h5>
<p>用<strong>dp[j]<strong>表示当前</strong>总重量为j</strong>的所有方案中的最大价值</p>
<p><strong>核心代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
    for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--)&#x2F;&#x2F;反向线性更新
        dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="完全背包">完全背包</h4>
<p><strong>题目</strong></p>
<p>有<strong>N</strong>种物品和一个容量为<strong>V</strong>的背包，每种物品都有无限件可用。第<strong>i</strong>种物品的费用是<strong>w [ i ]</strong> ，价值是<strong>v [ i ]</strong>。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p>
<p>可以将完全背包简化成01背包。</p>
<p><strong>状态转移方程</strong></p>
<blockquote>
<p>此处图片丢失</p>
</blockquote>
<p><strong>优化后</strong></p>
<blockquote>
<p>此处图片丢失</p>
</blockquote>
<p>还可以根据1背包的优化原则对,完全背包进行优化。</p>
<p><strong>优化代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int N, V;
int v[1010], val[1010];
int dp[1010];
int main()
&#123;
    cin &gt;&gt; N &gt;&gt; V;
    for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
        cin &gt;&gt; v[i] &gt;&gt; val[i];
    for (int i &#x3D; 1; i &lt;&#x3D; N; i++)
        for (int j &#x3D; 0; j &lt;&#x3D; V; j++)
        &#123;
            dp[j] &#x3D; dp[j]; &#x2F;&#x2F;此时右边的dp[j]是上一层i-1的dp[j],然后赋值给了当前i的dp[i]
            if (j &gt;&#x3D; v[i])
            &#123;
                dp[j] &#x3D; max(dp[j], dp[j - v[i]] + val[i]); &#x2F;&#x2F;dp[j-v[i]],已经被算过
            &#125;
        &#125;
    cout &lt;&lt; dp[V] &lt;&lt; endl; &#x2F;&#x2F;输出最大体积,即最优解

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3/">例题1</a></p>
<h4 id="多重背包">多重背包</h4>
<p>多重背包也是 01 背包的一个变式。与 01 背包的区别在于每种物品有<strong>k</strong>个，而非一个。</p>
<p><strong>题目</strong></p>
<p>有<strong>N</strong>种物品和一个容量为<strong>V</strong>的背包。第<strong>i</strong>种物品最多有<strong>p[i]<strong>件可用，每件费用是</strong>w[i]</strong> 价值是<strong>v[i]</strong>。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<p><strong>状态转移方程</strong></p>
<blockquote>
<p>此处图片丢失</p>
</blockquote>
<p>还是可以转化为01背包问题，但是要用到<strong>二进制拆分</strong></p>
<blockquote>
<p>此处图片丢失</p>
</blockquote>
<p><strong>二进制拆分代码</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
&#123;
    int num &#x3D; min(p[i], V &#x2F; w[i]);
    for (int k &#x3D; 1; num &gt; 0; k &lt;&lt;&#x3D; 1)
    &#123;
        if (k &gt; num)
            k &#x3D; num;
        num -&#x3D; k;
        for (int j &#x3D; V; j &gt;&#x3D; w[i] * k; j--)
            dp[j] &#x3D; max(dp[j], dp[j - w[i] * k] + v[i] * k);
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4/">例题</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/5/">例题2</a></p>
<hr>
<h3 id="博弈基础">博弈基础</h3>
<h4 id="巴什博奕">巴什博奕</h4>
<p>规则：有一堆n个石子，两个足够聪明的人玩，每个人可以去1～m个石子，取到最后一个石子为胜。</p>
<p><strong>结论</strong>：当n%(m+1)==0，先手必输，否则先手必胜。</p>
<p>代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int main()
&#123;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    if (n % (m + 1))
        cout &lt;&lt; &quot;先手胜&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;后手胜&quot; &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1846">例题</a></p>
<h4 id="威佐夫博弈">威佐夫博弈</h4>
<p>规则：有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。</p>
<p><strong>结论</strong>：若两堆物品的初始值为（x，y），且x&lt;y，则另z=y-x；<br>
记w=（int）[（（sqrt（5）+1）/2）*z  ]；<br>
若w=x，则先手必败，否则先手必胜。</p>
<p>代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    int n1, n2, temp;
    while (cin &gt;&gt; n1 &gt;&gt; n2)
    &#123;
        if (n1 &gt; n2)
            swap(n1, n2);
        temp &#x3D; floor((n2 - n1) * (1 + sqrt(5.0)) &#x2F; 2.0);
        if (temp &#x3D;&#x3D; n1)
            cout &lt;&lt; &quot;后手必胜&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;先手必胜&quot; &lt;&lt; endl;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="斐波那契博弈">斐波那契博弈</h4>
<p>规则：有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。</p>
<p><strong>结论</strong>：<strong>先手胜当且仅当n不是斐波那契数（n为物品总数）</strong></p>
<p>代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
using namespace std;
const int N &#x3D; 55;
int f[N];
void Init()
&#123;
    f[0] &#x3D; f[1] &#x3D; 1;
    for (int i &#x3D; 2; i &lt; N; i++)
        f[i] &#x3D; f[i - 1] + f[i - 2];
&#125;

int main()

&#123;

    Init();
    int n;
    while (cin &gt;&gt; n)
    &#123;
        if (n &#x3D;&#x3D; 0)
            break;
        bool flag &#x3D; 0;
        for (int i &#x3D; 0; i &lt; N; i++)
        &#123;
            if (f[i] &#x3D;&#x3D; n)
            &#123;
                flag &#x3D; 1;
                break;
            &#125;
        &#125;
        if (flag)
            puts(&quot;Second win&quot;);
        else
            puts(&quot;First win&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2516">例题</a></p>
<h4 id="尼姆博弈">尼姆博弈</h4>
<p>规则：任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。</p>
<p><strong>结论</strong>：把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。</p>
<p>代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    int n, ans, temp;
    while (cin &gt;&gt; n)
    &#123;
        temp &#x3D; 0;
        for (int i &#x3D; 0; i &lt; n; i++)
        &#123;
            cin &gt;&gt; ans;
            temp ^&#x3D; ans;&#x2F;&#x2F;异或
        &#125;
        if (temp &#x3D;&#x3D; 0)
            cout &lt;&lt; &quot;后手必胜&quot; &lt;&lt; endl;

        else
            cout &lt;&lt; &quot;先手必胜&quot; &lt;&lt; endl;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="隔板法">隔板法</h3>
<p>定义：隔板法就是在n个元素间的（n-1）个空中插入k个板，可以把n个元素分成k+1组的方法。</p>
<p>条件：</p>
<ul>
<li>这n个元素必须互不相异</li>
<li>所分成的每一组至少分得1个元素</li>
<li>分成的组别彼此相异</li>
</ul>
<p><strong>普通隔板法</strong><br>
例1. 求方程 x+y+z=10的正整数解的个数。</p>
<p>分析：将10个球排成一排，球与球之间形成9个空隙，将两个隔板插入这些空隙中（每空至多插一块隔板），规定由隔板分成的左、中、右三部分的球数分别为x、y、z之值）。则隔法与解的个数之间建立了一一对立关系，故解的个数为C(n-1,m-1)=C（9，2）=36（个）。</p>
<p>​</p>
<p><strong>添元素隔板法</strong><br>
例2. 求方程 x+y+z=10的非负整数解的个数。</p>
<p>分析：注意到x、y、z可以为零，故例1解法中的限定“每空至多插一块隔板”就不成立了，怎么办呢？只要添加三个球，给x、y、z各添加一个球，这样原问题就转化为求 x+y+z=13的正整数解的个数了，则问题就等价于把13个相同小球放入3个不同箱子，每个箱子至少一个，有几种情况？易得解的个数为C（n+m-1,m-1）=C（12，2）=66（个）。</p>
<p>例3： 把10个相同小球放入3个不同箱子，第一个箱子至少1个，第二个箱子至少3个，第三个箱子可以放空球，有几种情况？<br>
我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8个小球之外的1个小球，则问题转化为 把9个相同小球放3不同箱子，每箱至少1个，几种方法？ C(8,2）=28</p>
<p>例4. 将20个相同的小球放入编号分别为1，2，3，4的四个盒子中，要求每个盒子中的球数不少于它的编号数，求放法总数。（减少球数用隔板法）</p>
<p>分析：先在编号1，2，3，4的四个盒子内分别放0，1，2，3个球，剩下14个球，有1种方法；再把剩下的球分成4组，每组至少1个，由例1知方法有C（13，3）=286（种）。</p>
<p>例5：有一类自然数，从第三个数字开始，每个数字都恰好是它前面两个数字之和，直至不能再写为止，如257，1459等等，这类数共有几个？<br>
因为前2位数字唯一对应了符合要求的一个数，只要求出前2位有几种情况即可，设前两位为ab<br>
显然a+b&lt;=9 ,且a不为0<br>
1 -1- 1 -1 -1 -1 -1 -1 -1      1代表9个1，-代表8个空位<br>
我们要把9个1分成两组，但b可以为0，我们先给b一个1，然后就相当于10个小球放入两个（a，b）不同的箱子，每一个箱子至少放一个，C（9，1），但这是错误的，为什么？因为1不一定要全部放入。其实解决这个问题可以这么想，我们在引进一个盒子c来放ab取完剩下的1，所以报证c中球数大于0，所以要在增加一个球，题目就等价于，11个小球放入两个（a，b）不同的箱子，每一个箱子至少放一个，所以一共有 c（10，2）=45</p>
<p><strong>添板插板法</strong><br>
例5另一种解法：</p>
<p>显然a+b&lt;=9 ,且a不为0<br>
1 -1- 1 -1 -1 -1 -1 -1 -1 - -    1代表9个1，-代表10个空位 （第一个没有因为a不能为0），我们可以在这9个空位中插入2个板，分成3组，第一组取到a个1，第二组取到b个1，但此时第二组始终不能取空，若多添加第10个空时，设取到该板时第二组取空，即b=0，所以一共有 c（10，2）=45</p>
<p>添板插板法就是添元素隔板法的变形。</p>
<p>**选板法 **</p>
<p>例6： 有10粒糖，如果每天至少吃一粒(多不限)，吃完为止，求有多少种不同吃法？<br>
o - o - o - o - o - o - o - o - o – o       o代表10个糖，-代表9块板<br>
10块糖，9个空，插入9块板，每个板都可以选择放或是不放，相邻两个板间的糖一天吃掉<br>
这样一共就是 2^9= 512</p>
<p>**分类插板 **</p>
<p>例7： 小梅有15块糖，如果每天至少吃3块，吃完为止，那么共有多少种不同的吃法？<br>
此问题不能用插板法的原因在于没有规定一定要吃几天，因此我们需要对吃的天数进行分类讨论<br>
最多吃5天，最少吃1天<br>
1： 吃1天或是5天，各一种吃法 一共2种情况<br>
2：吃2天，每天预先吃2块，即问11块糖，每天至少吃1块，吃2天，几种情况？ C（10， 1）=10<br>
3：吃3天，每天预先吃2块，即问9块糖，每天至少1块，吃3天? C（8 ，2）=28<br>
4：吃4天，每天预先吃2块，即问7块糖，每天至少1块，吃4天？c（6 ，3）=20<br>
所以一共是 2+10+28+20=60 种</p>
<p>**逐步插板法 **</p>
<p>例8 ：在一张节目单中原有6个节目，若保持这些节目相对次序不变，再添加3个节目，共有几种情况？<br>
-o - o - o - o - o - o - 三个节目abc<br>
可以用一个节目去插7个空位，再用第二个节目去插8个空位，用最后个节目去插9个空位<br>
所以一共是 c（7, 1）×c(8, 1)×c(9 ,1)=504种</p>
<hr>
<h3 id="快速幂算法">快速幂算法</h3>
<h4 id="快速幂">快速幂</h4>
<p><strong>作用</strong>：解决乘法溢出问题，如2^100 % 10086</p>
<p>要用到模运算规律：(a * b) % p = (a % p * b % p) % p</p>
<p>朴素版</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int ans&#x3D;1;
for (int i&#x3D;1; i&lt;&#x3D;b; ++i)
&#123;
    ans *&#x3D; a % p;
&#125;
return ans % p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>但是朴素版时间复杂度过高为<strong>O(N)</strong></p>
<p>优化版</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int pow(int a, int b, int p)
&#123;
    int ans &#x3D; 1;
    while (b)
    &#123;
        if (b &amp; 1)
            ans &#x3D; ans * a % p; &#x2F;&#x2F;若b&amp;1&#x3D;&#x3D;1，就选择当前的迭代值a和res累乘。
        a &#x3D; a * a;             &#x2F;&#x2F;迭代构造a,a是初始值的2的整数次幂
        b &#x3D; b &gt;&gt; 1;            &#x2F;&#x2F;将b右移一位
    &#125;                          &#x2F;&#x2F;以上计算得到a^b
    return ans % p;            &#x2F;&#x2F;取模
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="龟速乘">龟速乘</h4>
<p><strong>作用</strong>：当(a * b) % p中a和b过大时，快速幂也会超出数据范围，可以使用龟速乘防止爆掉</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">&#x2F;&#x2F;防止在乘法过程中爆ll
ll fast_mult(ll a, ll b)
&#123;
    ll res &#x3D; 0;
    while (b &gt; 0)
    &#123;
        if (b &amp; 1)
        &#123;
            res &#x3D; (res + a) % n;
        &#125;
        b &gt;&gt;&#x3D; 1;
        a &#x3D; (a + a) % n;
    &#125;
    return res % n;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h4 id="矩阵快速幂">矩阵快速幂</h4>
<p><strong>矩阵乘法</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">const int N &#x3D; 100;
int c[N][N];
void multi(int a[][N], int b[][N], int n) &#x2F;&#x2F;n是矩阵大小，n&lt;N
&#123;
    memset(c, 0, sizeof(c));
    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)
            for (int k &#x3D; 1; k &lt;&#x3D; n; k++)
                c[i][j] +&#x3D; a[i][k] * b[k][j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>矩阵快速幂模板</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c+" data-language="c+"><code class="language-c+">#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
int M, n;
struct node &#x2F;&#x2F;定义一个矩阵类型的结构体
&#123;
    int m[100][100];
&#125; ans, res; &#x2F;&#x2F;ans是结果，res是最初的方阵
node mul(node A, node B)
&#123;
    int i, j, k;
    node temp;              &#x2F;&#x2F;定义一个临时矩阵，存放A*B的结果
    for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;先全部定义为0
    &#123;
        for (j &#x3D; 0; j &lt; n; j++)
        &#123;
            temp.m[i][j] &#x3D; 0;
        &#125;
    &#125;
    for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;矩阵相乘的代码
    &#123;
        for (j &#x3D; 0; j &lt; n; j++)
        &#123;
            for (k &#x3D; 0; k &lt; n; k++)
            &#123;
                temp.m[i][j] +&#x3D; A.m[i][k] * B.m[k][j];
            &#125;
        &#125;
    &#125;
    return temp;
&#125;
void fastpow(int M, int n)
&#123;
    int i, j;
    for (i &#x3D; 0; i &lt; n; i++)
    &#123;
        for (j &#x3D; 0; j &lt; n; j++)
        &#123;
            if (i &#x3D;&#x3D; j)
            &#123;
                ans.m[i][j] &#x3D; 1;
            &#125;
            else
                ans.m[i][j] &#x3D; 0;
        &#125;
    &#125; &#x2F;&#x2F;这里是思想的转换，之前我们定义为1去计算，所以我们先初始化ans为
    &#x2F;&#x2F;单位矩阵，我们知道单位矩阵与任何矩阵的乘积为其本身
    while (M) &#x2F;&#x2F;快速幂的步骤
    &#123;
        if (M &amp; 1)
        &#123;
            ans &#x3D; mul(ans, res);
        &#125;
        res &#x3D; mul(res, res);
        M &#x3D; M &gt;&gt; 1;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n; &#x2F;&#x2F;方阵的阶数
    cin &gt;&gt; M; &#x2F;&#x2F;指数
    int i, j;
    for (i &#x3D; 0; i &lt; n; i++)
    &#123;
        for (j &#x3D; 0; j &lt; n; j++)
        &#123;
            cin &gt;&gt; res.m[i][j]; &#x2F;&#x2F;初始化方阵res
        &#125;
    &#125;
    fastpow(M, n);          &#x2F;&#x2F;进行快速幂
    for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;输出
    &#123;
        for (j &#x3D; 0; j &lt; n; j++)
        &#123;
            cout &lt;&lt; ans.m[i][j] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
    &#125;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="数论基础">数论基础</h3>
<h4 id="同余式">同余式</h4>
<p><strong>定义</strong>：同余式是 数论 的基本概念之一，设m是给定的一个正整数，a、b是整数，若满足m| (a-b)，则称a与b对模m 同余 ，记为a≡b (mod m)，或记为a≡b (m)。</p>
<h4 id="逆元">逆元</h4>
<p>每个数a均有唯一的与之对应的乘法逆元x，使得ax≡1(mod n) ， 一个数有逆元的充分必要条件是gcd(a,n)=1，此时逆元唯一存在 。<br>
<strong>逆元的含义</strong>：模n意义下，1个数a如果有逆元x，那么除以a相当于乘以x。</p>
<p><strong>逆元的定义</strong>：定义：正整数 a, n，如果有 ax ≡ 1(mod n)，则称 x 的最小正整数解为 a 模 n的逆元。</p>
<h5 id="扩展欧几里得算法">扩展欧几里得算法</h5>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;

int exgcd(int a, int b, int &amp;x, int &amp;y)
&#123;
    if (b &#x3D;&#x3D; 0)
    &#123;
        x &#x3D; 1, y &#x3D; 0;
        return a;
    &#125;
    int r &#x3D; exgcd(b, a % b, x, y);
    int t &#x3D; x;
    x &#x3D; y;
    y &#x3D; t - a &#x2F; b * y;
    return r;
&#125;
int inv(int n, int m)
&#123;
    int x, y;
    int ans &#x3D; exgcd(n, m, x, y);
    if (ans &#x3D;&#x3D; 1)
        return (x % m + m) % m;
    &#x2F;&#x2F;定义：正整数 a, n，如果有 ax ≡ 1(mod n)，则称 x 的最小整数解为 a 模 n的逆元。
    else
        return -1;
&#125;
int main()
&#123;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    int ans &#x3D; inv(n, m);
    ans &#x3D;&#x3D; -1 ? cout &lt;&lt; &quot;no&quot; &lt;&lt; endl : cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
&#x2F;*
    intput:
    5 7
    22 29
    100 97
    
    output:
    3
    4
    65
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<h5 id="费马小定理">费马小定理</h5>
<p><strong>定义</strong>：若存在整数 a , p 且gcd(a,p)=1,即二者互为质数，则有a^(p-1)≡ 1(mod p)。</p>
<p>费马小定理求逆元</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long long fast_pow(long long a, long long b, long long p)
&#123;
    long long ans &#x3D; 1;
    a %&#x3D; p;
    while (b)
    &#123;
        if (b &amp; 1)
            ans &#x3D; (ans * a) % p;
        a &#x3D; (a * a) % p;
        b &gt;&gt;&#x3D; 1;
    &#125;
    return ans;
&#125;
long long inv(long long x, long long p)
&#123;
    return fast_pow(x, p - 2, p);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="KMP算法">KMP算法</h3>
<ul>
<li>
<p>KMP是一种时间复杂度<strong>O(n+m)<strong>的字符串单模匹配算法，核心是通过预处理模式串的所有前缀串的最长相同前后缀，构造</strong>next数组</strong>，在原串与模式串匹配失败时参考next数组做跳转避免原串指针的回退并减少模式串指针的回退长度</p>
</li>
<li>
<p>next数组是一个大小与模式串长度相同的数组，next[i]为模式串[0,i)子串的最长相同前后缀长度</p>
</li>
</ul>
<p>构造next数组</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;优化过后的next 数组求法
void GetNext(char *p, int next[])
&#123;
    int pLen &#x3D; strlen(p);
    next[0] &#x3D; -1;
    int k &#x3D; -1;
    int j &#x3D; 0;
    while (j &lt; pLen - 1)
    &#123;
        &#x2F;&#x2F;p[k]表示前缀，p[j]表示后缀
        if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k])
        &#123;
            ++j;
            ++k;
            if (p[j] !&#x3D; p[k])
                next[j] &#x3D; k; 
            else
                &#x2F;&#x2F;因为不能出现p[j] &#x3D; p[ next[j ]]，所以当出现时需要继续递归，k &#x3D; next[k] &#x3D; next[next[k]]
                next[j] &#x3D; next[k];
        &#125;
        else
        &#123;
            k &#x3D; next[k];
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p>kmp模板</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int Kmp(char *s, char *p)
&#123;
    int i &#x3D; 0;
    int j &#x3D; 0;
    int sLen &#x3D; strlen(s);
    int pLen &#x3D; strlen(p);
    while (i &lt; sLen &amp;&amp; j &lt; pLen)
    &#123;
        &#x2F;&#x2F;如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++
        if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j])
        &#123;
            i++;
            j++;
        &#125;
        else
        &#123;
            &#x2F;&#x2F;如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j]
            &#x2F;&#x2F;next[j]即为j所对应的next值
            j &#x3D; next[j];
        &#125;
    &#125;
    if (j &#x3D;&#x3D; pLen)
        return i - j;
    else
        return -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=3461">例题1</a></p>
<p>AC代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#define Memset(x, a) memset(x, a, sizeof(x))
using namespace std;
const int N &#x3D; 1e6 + 10;
char w[N], t[N];
int next[N];
int sum;

void getNext(const char P[], int next[])
&#123;
    int m &#x3D; strlen(P);
    int i &#x3D; 0, j;
    j &#x3D; next[0] &#x3D; -1;
    while (i &lt; m)
    &#123;
        while (-1 !&#x3D; j &amp;&amp; P[i] !&#x3D; P[j])
            j &#x3D; next[j];
        next[++i] &#x3D; ++j;
    &#125;
&#125;

void kmp(const char T[], const char P[], int next[])
&#123;
    int n &#x3D; strlen(T), m &#x3D; strlen(P);
    int i, j;
    getNext(P, next);
    i &#x3D; j &#x3D; 0;
    while (i &lt; n)
    &#123;
        while (-1 !&#x3D; j &amp;&amp; T[i] !&#x3D; P[j])
            j &#x3D; next[j];
        i++;
        j++;
        if (j &gt;&#x3D; m)
        &#123;
            sum++;
            j &#x3D; next[j]; &#x2F;&#x2F;这儿修改很重要，不然会超时
        &#125;
    &#125;
&#125;

int main()
&#123;
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--)
    &#123;
        sum &#x3D; 0;
        Memset(next, 0);
        scanf(&quot;%s%s&quot;, w, t);
        kmp(t, w, next);
        printf(&quot;%d\n&quot;, sum);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2752">例题2(next数组的使用)</a></p>
<p>AC代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#define Memset(x, a) memset(x, a, sizeof(x))
using namespace std;
const int N &#x3D; 4e5 + 10;
int next[N], ans[N];
char s[N];

void getNext(const char P[], int next[])
&#123;
    int m &#x3D; strlen(P);
    int i &#x3D; 0, j;
    j &#x3D; next[0] &#x3D; -1;
    while (i &lt; m)
    &#123;
        while (-1 !&#x3D; j &amp;&amp; P[i] !&#x3D; P[j])
            j &#x3D; next[j];
        next[++i] &#x3D; ++j;
    &#125;
&#125;

int main()
&#123;
    while (~scanf(&quot;%s&quot;, s))
    &#123;
        Memset(next, 0);
        getNext(s, next);
        int cnt &#x3D; 0;
        int len &#x3D; strlen(s);
        int j &#x3D; next[len];
        while (j &gt; 0)
        &#123;
            ans[++cnt] &#x3D; j;
            j &#x3D; next[j];
        &#125;
        for (int i &#x3D; cnt; i &gt; 0; i--)
            printf(&quot;%d &quot;, ans[i]);
        printf(&quot;%d\n&quot;, len);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<hr>
<h3 id="manacher算法">manacher算法</h3>
<p>求最长回文子串，一般从字符串的中心开始向两侧遍历，为了防止偶数字串，在每个字符的左右都加上一个特殊字符如#（前提是这个字符在字符串中没有出现）使这两种回文串都变成奇回文串，因为原回文串长度是n,必将插入n+1个分隔符,处理之后的长度为2n+1,无论n的奇偶,2n+1必为奇数,故处理后必是<strong>奇回文串</strong></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define maxn 1000010
#include &lt;bits&#x2F;stdc++.h&gt;

using namespace std;

char str[maxn] &#x3D; &#123;&quot;3212343219&quot;&#125;; &#x2F;&#x2F;原字符串
char tmp[maxn * 2];              &#x2F;&#x2F;转换后的字符串
int Len[maxn * 2];

&#x2F;&#x2F;转换原始串
int init(char *st)
&#123;
    int i, len &#x3D; strlen(st);
    tmp[0] &#x3D; &#39;@&#39;; &#x2F;&#x2F;字符串开头增加一个特殊字符，防止越界
    for (i &#x3D; 1; i &lt;&#x3D; 2 * len; i +&#x3D; 2)
    &#123;
        tmp[i] &#x3D; &#39;#&#39;;
        tmp[i + 1] &#x3D; st[i &#x2F; 2];
    &#125;
    tmp[2 * len + 1] &#x3D; &#39;#&#39;;
    tmp[2 * len + 2] &#x3D; &#39;$&#39;; &#x2F;&#x2F;字符串结尾加一个字符，防止越界
    tmp[2 * len + 3] &#x3D; 0;
    return 2 * len + 1; &#x2F;&#x2F;返回转换字符串的长度
&#125;
&#x2F;&#x2F;Manacher算法计算过程
int manacher(char *st, int len)
&#123;
    int mx &#x3D; 0, ans &#x3D; 0, po &#x3D; 0; &#x2F;&#x2F;mx即为当前计算回文串最右边字符的最大值
    for (int i &#x3D; 1; i &lt;&#x3D; len; i++)
    &#123;
        if (mx &gt; i)
            Len[i] &#x3D; min(mx - i, Len[2 * po - i]); &#x2F;&#x2F;在Len[j]和mx-i中取个小
        else
            Len[i] &#x3D; 1; &#x2F;&#x2F;如果i&gt;&#x3D;mx，要从头开始匹配
        while (st[i - Len[i]] &#x3D;&#x3D; st[i + Len[i]])
            Len[i]++;
        if (Len[i] + i &gt; mx) &#x2F;&#x2F;若新计算的回文串右端点位置大于mx，要更新po和mx的值
        &#123;
            mx &#x3D; Len[i] + i;
            po &#x3D; i;
        &#125;
        ans &#x3D; max(ans, Len[i]);
    &#125;
    return ans - 1; &#x2F;&#x2F;返回Len[i]中的最大值-1即为原串的最长回文子串额长度
&#125;

int main()
&#123;
    int len &#x3D; init(str);
    manacher(tmp, len);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=4513">manacher例题</a></p>
<p>AC代码</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;
#define INF 0x3f3f3f3f
const int MOD&#x3D;10007;
const int N&#x3D;200000+5;
const int dx[]&#x3D; &#123;-1,1,0,0&#125;;
const int dy[]&#x3D; &#123;0,0,-1,1&#125;;
using namespace std;
int str[N];
int newStr[N*2];
int p[N*2];
int n;
int init()&#123;
    newStr[0]&#x3D;-1;
    newStr[1]&#x3D;0;
 
    int j&#x3D;2;
    int len&#x3D;n;
    for (int i&#x3D;0;i&lt;len;i++)&#123;
        newStr[j++]&#x3D;str[i];
        newStr[j++]&#x3D;0;
    &#125;
 
    return j;
&#125;
 
int manacher()&#123;
    int len&#x3D;init();
    int res&#x3D;-1;
 
    int id;
    int mx&#x3D;0;
    for(int i&#x3D;1;i&lt;len;i++)&#123;
        int j&#x3D;2*id-i;
        if(i&lt;mx)
            p[i]&#x3D;min(p[j], mx-i);
        else
            p[i]&#x3D;1;
 
        while(newStr[i-p[i]]&#x3D;&#x3D;newStr[i+p[i]] &amp;&amp;  newStr[i-p[i]]&lt;&#x3D;newStr[i-p[i]+2] )
            p[i]++;
 
        if(mx&lt;i+p[i])&#123;
            id&#x3D;i;
            mx&#x3D;i+p[i];
        &#125;
        res&#x3D;max(res,p[i]-1);
    &#125;
    return res;
&#125;
 
int main()&#123;
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    &#123;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i&#x3D;0;i&lt;n;++i)
            scanf(&quot;%d&quot;,&amp;str[i]);
        printf(&quot;%d\n&quot;,manacher());
    &#125;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>基础算法总结</div>
      <div>https://exusiai.top/article/25cafd126b0c.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>HauKuen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - haukuen">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/article/a1d9e410697e.html" title="如何跨设备同步hexo">
                        <span class="hidden-mobile">如何跨设备同步hexo</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://time-runner-5oruvii0p-haukuen.vercel.app/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<!-- hexo injector body_end start -->
<script type="text/javascript">
(function() {
  var metaElement = document.querySelector('meta[property="article:modified_time"]');
  if (metaElement) {
    var modifiedTime = metaElement.getAttribute('content');
    var articleDate = new Date(modifiedTime);
    var currentDate = new Date();

    var posts = document.getElementsByClassName('post-content');
    if (posts.length === 0) {
      return;
    }

    // 计算时间差，单位为毫秒
    var timeDifference = currentDate - articleDate;

    // 一年的毫秒数
    var oneYearInMilliseconds = 365 * 24 * 60 * 60 * 1000;

    if (timeDifference > oneYearInMilliseconds) {
      var daysSinceUpdate = Math.floor(timeDifference / (24 * 60 * 60 * 1000));
      posts[0].innerHTML = '<div class="note note-warning" style="font-size:0.9rem"><p>' +
        '<div class="h6">文章时效性提示</div><p>这是一篇更新于 ' + daysSinceUpdate + ' 天前的文章，部分信息可能已经有所发展或是发生改变。' +
        '</p></p></div>' + posts[0].innerHTML;
    }
  }
})();
</script>
<!-- hexo injector body_end end --></body>
</html>

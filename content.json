{"meta":{"title":"时砾逐光","subtitle":"愿前路无止境","description":"个人博客","author":"Hiroshi","url":"http://example.com","root":"/"},"pages":[{"title":"Repositories","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"软件设计师学习笔记 一","slug":"软件设计师学习笔记 一","date":"2022-10-18T06:46:29.000Z","updated":"2022-10-19T06:01:25.436Z","comments":true,"path":"2022/10/18/软件设计师学习笔记 一/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E4%B8%80/","excerpt":"","text":"#现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 Flynn分类法 CISC与RISC 流水线（重要） 流程： 取指——分析——执行 流水线周期指所有流程中执行时间最长的一段 流水线吞吐率计算： 流水线的加速比计算： 流水线的效率计算： 计算机层次化存储结构： Catch的基本概念： 除了寄存器外catch是最快的 计算 局部性原理： 主存的分类： 编址 （1）：","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据库笔记","slug":"数据库笔记","date":"2022-10-17T02:45:16.000Z","updated":"2022-10-20T04:15:34.327Z","comments":true,"path":"2022/10/17/数据库笔记/","link":"","permalink":"http://example.com/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"","text":"# 跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名;create database 数据库名 charset=字符集; #设定默认字符集create database 数据库名 default cheoharacter set 字符集; #设定默认字符集 删除数据库 drop database 数据库名; 使用数据库 use 数据库名; 查询当前正在使用的数据库 select database(); 设置数据库字符集 alter database 数据库名 character set 字符集; 2.数据表操作 创建表 create table 表名 (字段名 字段类型 [NOT NULL]); 查询数据库的表格个数 # 第一种写法show tables from 数据库名;# 第二种写法,如果已经选择了使用的数据库则可以直接show tables; 修改表名 rename table 旧表名 to 新表名; 查看表格的详细信息 show create table 表名; 查看字段 desc 表名; 插入数据 # 两种写法into都可以省略insert into 表名 values(数据1, 数据2...) (数据1, 数据2...) # 可同时插入多组数据insert into 表名 (字段1,字段2...) values (数据1, 数据2...) # 这种写法可以跳过部分字段 查询数据 select 字段1,字段2 from 表名 [where...][limit n][offset m]# LIMIT 属性来设定返回的记录数。# OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 更新数据 update 表名 set 字段1 = 值1,字段2 = 值2 [where...] 删除数据 delete from 表名 [where...] 3.筛选条件 去重(distinct) 例：select distinct job from user; # 查询user表中所有不重复的job名经常使用（count(distinct id)）来返回不重复字段的条数 NULL # 可以在语句中加入is null 和is not null来筛选字段数据例：select * from user where job is not null; # 查询user表中所有有工作的人的信息 between select * from user where age between 20 and 30; #包含范围两端 in # in运算符允许确定指定的值是否与列表中的值或子查询中的任何值匹配。 也可以搭配not使用select 字段1,字段2 from 表名 where (expr|column_1) in (值1,值2); as # 设置字段的别名select 字段名 as &quot;别名&quot; from 表名; # 最完整的写法 as和引号都可以省略例如:select 字段名 &quot;别名&quot; from 表名;select 字段名 别名 from 表名; like # 匹配的字符串必须加单引号或双引号# 通配符% 它能代表任何长度的字符串，字符串的长度可以为 0# 通配符_ 它只能代表单个字符，字符串的长度不能为 0例:select * from user where name like &#x27;王%&#x27;; #查询所有以王姓开头的用户# 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字例:select * from user where name like binary &#x27;t%&#x27;;# 这样就不会查询到 T 开头的名字了tips:1. % 通配符可以到匹配任意字符，但是不能匹配 NULL。2. mysql通配符的处理会比其他操作符花费更长的时间,如果其它操作符能达到相同的目的，应该使用其它操作符。3. 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。4. 如果查询内容中包含通配符，可以使用&quot;\\&quot;转义符。 排序**[ASC|DESC]** select 字段名 from 表名 [where...] order by 字段名 [ASC|DESC];# ASC代表升序、DESC代表降序 不跟默认升序# order by 后面可以跟多个条件，例如 order by age, id desc; 分页查询(LIMIT) 格式：limit 偏移量,取出的数据条数 # 偏移量不写默认为0limit 跳过的条数,请求的条数(每一页的条数) # 跳过的条数 = (请求的页数-1) * 请求的条数tips:分页查询一般和排序组合使用 聚合函数 max, min, avg, sum, count 分组查询(GROUP BY) 格式：group by 分组字段名 HAVING # 和where的区别having：后面跟聚合函数，可以单独使用where：后面跟普通字段条件，不能包含聚合函数 4.子查询(嵌套查询) 在SQL语言中，一个 SELECT-FROM-WHERE 语句称为一个查询块。将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。 # 查询工资大于二号部门平均工资的员工信息select * from emp where sal &gt; (select avg(sal) from emp where dept_id = 2);tips:1.子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。 5.关联查询(同时查询多表) 完善中… 1. 等值连接|笛卡尔积# 查询工资高于2000的员工姓名和部门名select emp.name,dept.name from dept, emp where emp.sal &gt; 2000 and emp.dept_id = dept.id;2. 内连接select 字段1,字段2 from 表名1 join 表名2 on 关联关系 [where...]3. 外连接# 外连接有三种：左外连接、右外连接、全外连接，左/右外连接没有本质区别select 字段1,字段2 from 表名1 left/right 表名2 on 关联关系 [where...] 6.奇技淫巧 修改正在使用被外键约束的列 # 原本不允许进行修改，因为这个操作违反了外键约束，破坏了数据库完整性。# 但是万能的mysql提供了一个方法，临时关闭外键约束，当修改完成之后再将外键约束加回来。 SET FOREIGN_KEY_CHECKS = 0;............SET FOREIGN_KEY_CHECKS = 1; SQL语句书写顺序 # 完善中select 字段 from 表名 where 普通字段条件 group by 分组字段 having 聚合函数条件 order by 排序字段名 limit 跳过的条数，请求的条数","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo-GitHub搭建教程","slug":"Hexo-Github搭建教程","date":"2022-10-16T07:56:22.000Z","updated":"2022-10-19T06:18:19.489Z","comments":true,"path":"2022/10/16/Hexo-Github搭建教程/","link":"","permalink":"http://example.com/2022/10/16/Hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"#注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io 2.本地安装Hexo程序 安装Node.js,一路next即可 Node.js：https://nodejs.org/zh-cn 使用指令npm install -g hexo-cli安装 ,mac用户需要在指令前加上sudo,这一步请耐心等待 在本地新建一个用于存放博客文件的文件夹，例如blog文件夹，在此文件夹进入Git Bash 初始化博客文件并安装组件 hexo init # 初始化npm install # 安装组件 完成后便可以在本地进行预览了（输入指令后不要关闭窗口） hexo g # 生成页面 hexo s # 启动预览 在浏览器中输入localhost:4000进行预览，出现Hexo的默认页面则本地博客安装成功！ 如果无法预览则可能是端口被占用，可以找出占用端口的程序并关闭，或者也可以修改Hexo启动的端口,这里改为5000端口 hexo s -p 5000 3.部署 Hexo 到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改_config.yml文件末尾的 Deployment 部分，修改成如下 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 运行hexo d部署网站，成功后便可以在https://用户名.github.io看到自己的博客了 更新中······","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-05-05T13:55:34.000Z","updated":"2022-10-19T06:14:53.168Z","comments":true,"path":"2022/05/05/素数筛/","link":"","permalink":"http://example.com/2022/05/05/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"","text":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足$6n+1$或$6n-1$。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力 模板 bool isprime(int n)&#123; if (n == 1) return false; else if (n == 2 || n == 3) return true; //不满足六倍原理，一定不是素数 else if (n % 6 != 1 &amp;&amp; n % 6 != 5) return false; //只判断6倍的邻数 for (int i = 5; i &lt;= sqrt(n); i += 6) &#123; if (n % i == 0 || n % (i + 2) == 0) return false; &#125; return true;&#125; 埃氏筛法 原理：要得到自然数$n$以内的全部素数，必须把不大于根号$n$的所有素数的倍数剔除，剩下的就是素数。 时间复杂度：$O(nlog(logn))$ 有的写法内层循环不同时间复杂度可能是$O(nlogn)$ 模板 bool is_prime[1000]; //标记是否是素数for (int i = 0; i &lt;= n; i++) is_prime[i] = true; //初始化所有的数为素数 is_prime[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; //从第一个素数2开始筛选 if (is_prime[i]) &#123; //如果是素数 for (int j = i * i; j &lt;= n; j += i) //一个小优化，从i * i开始而不是从 i + i开始 &#123; //则剔除掉它的倍数 is_prime[j] = false; &#125; &#125; &#125; 欧拉筛法（线性筛） 原理：使用埃式筛法时，同一个数字会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多的时间。欧拉筛正是埃式筛的优化。即让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 时间复杂度：$O(n)$ 模板 //求小于等于n的素数的个数，并输出每个素数#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5;int prime[N]; //存素数bool vis[N]; //保证不做素数的倍数int main()&#123; int n, cnt = 0; cin &gt;&gt; n; memset(vis, false, sizeof(vis)); //初始化 memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) //未被标记 prime[cnt++] = i; //则找到素数 for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = true; //标记找到的素数的倍数 if (i % prime[j] == 0) break; //线性的关键！！ &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) cout &lt;&lt; prime[i] &lt;&lt; &quot; &quot;; //输出每个素数 return 0;&#125; 个人学习记录，非教程，所以不太注重以上算法原理的解释","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二分总结","slug":"二分总结","date":"2022-01-07T09:31:37.000Z","updated":"2022-10-19T06:18:25.069Z","comments":true,"path":"2022/01/07/二分总结/","link":"","permalink":"http://example.com/2022/01/07/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } 为什么需要补上一个呢？ 因为整数的除法是向下取整，我们需要在运算时+1时它变成向上取整，否则的话会因为边界问题导致while无限循环。 举个例子，在区间只有两个数的时候，比如，，，这时候如果check成功，那么会执行，然后问题就来了，和本来就都等于3，然后就会无限循环下去，和的值永远不会更新。所以在的更新方式下，我们需要将运算时成为向上取整才不会死循环。 第二种 这种情况代码如下 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; } 为什么在这里不需要补上一个呢？ 因为边界问题不会影响到值的更新，还是用上面那个例子，，，。 此时如果check成功，那么，更新成功。如果check失败，则，同样更新成功。由此可以看出，在的更新方式下，不需要对进行任何操作。 以上是整数二分的两种固定写法。那么什么时候用哪种方法呢，这就要根据具体的题目进行分析了。 例题—— 分巧克力 题目描述 儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 和 。 输入保证每位小朋友至少能获得一块 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 输入输出样例 输入#1 2 10 6 5 5 6 输出#1 2 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl '\\n'using namespace std;int n, k;const int N = 1e5 + 10;int h[N], w[N];bool check(int x){ int cnt = 0; for (int i = 0; i &lt; n; i++) { cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; } return false;}int main(){ IOS; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i] &gt;&gt; w[i]; int l = 0, r = N; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; return 0;} 题目很简单是二分的板子题，主要是说为什么要用第一种求方法呢。 为什么二分里面不能写成 int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; //这样写跑样例答案是3 else r = mid; 推导一遍发现，如果成立后，说明当前的值也是在答案范围中，所以答案只能在之中取。理所当然无法用上面那种写法，如果用上面那种方法，会直接更新成，会越过这个值，所以在一些情况就会出现错误，比如题面的样例就会成为，越过了这个可能的答案值，恰好就是最大的一个答案，导致答案错误。 总结 这次弄明白了二分的写法属实是不易，留文一篇防止日后遗忘 以后写二分的时候记得注意一下区间情况","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}
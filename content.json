{"meta":{"title":"时砾逐光","subtitle":"愿前路无止境","description":"个人博客","author":"Hiroshi","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库笔记","slug":"数据库笔记","date":"2022-10-17T02:45:16.000Z","updated":"2022-10-18T00:43:52.688Z","comments":true,"path":"2022/10/17/数据库笔记/","link":"","permalink":"http://example.com/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"","text":"# 跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名;create database 数据库名 charset=字符集; #设定默认字符集create database 数据库名 default character set 字符集; #设定默认字符集 删除数据库 drop database 数据库名; 使用数据库 use 数据库名; 查询当前正在使用的数据库 select database(); 设置数据库字符集 2.数据表操作 创建表 create table 表名 (字段名 字段类型 [NOT NULL]); 查询数据库的表格个数 # 第一种写法show tables from 数据库名;# 第二种写法,如果已经选择了使用的数据库则可以直接show tables; 修改表名 rename table 旧表名 to 新表名; 查看表格的详细信息 show create table 表名; 查看字段 desc 表名; 插入数据 # 两种写法into都可以省略insert into 表名 values(数据1, 数据2...) (数据1, 数据2...) # 可同时插入多组数据insert into 表名 (字段1,字段2...) values (数据1, 数据2...) # 这种写法可以跳过部分字段 查询 select 字段1,字段2 from 表名 [where...][limit n][offset m]","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo-GitHub搭建教程","slug":"Hexo-Github搭建教程","date":"2022-10-16T07:56:22.000Z","updated":"2022-10-17T00:07:24.053Z","comments":true,"path":"2022/10/16/Hexo-Github搭建教程/","link":"","permalink":"http://example.com/2022/10/16/Hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"#注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io 2.本地安装Hexo程序 安装Node.js,一路next即可 Node.js：https://nodejs.org/zh-cn 使用指令npm install -g hexo-cli安装 ,mac用户需要在指令前加上sudo,这一步请耐心等待 在本地新建一个用于存放博客文件的文件夹，例如blog文件夹，在此文件夹进入Git Bash 初始化博客文件并安装组件 hexo init # 初始化npm install # 安装组件 完成后便可以在本地进行预览了（输入指令后不要关闭窗口） hexo g # 生成页面 hexo s # 启动预览 在浏览器中输入localhost:4000进行预览，出现Hexo的默认页面则本地博客安装成功！ 如果无法预览则可能是端口被占用，可以找出占用端口的程序并关闭，或者也可以修改Hexo启动的端口,这里改为5000端口 hexo s -p 5000 3.部署 Hexo 到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改_config.yml文件末尾的 Deployment 部分，修改成如下 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 运行hexo d部署网站，成功后便可以在https://用户名.github.io看到自己的博客了 更新中······","categories":[],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"二分总结","slug":"二分总结","date":"2022-01-07T09:31:37.000Z","updated":"2022-10-17T15:25:29.267Z","comments":true,"path":"2022/01/07/二分总结/","link":"","permalink":"http://example.com/2022/01/07/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"序 以前学习二分的时候一直没有搞清楚什么时候$mid = (left + right) / 2$，什么时候$mid = (left + right + 1) / 2$，更新的时候是$right = mid + 1$还是$right = mid - 1$，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 $mid=(right+left+1)/2$ 这种情况代码如下 while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; 为什么$mid$需要补上一个$1$呢？ 因为整数的除法是向下取整，我们需要在运算时+1时它变成向上取整，否则的话会因为边界问题导致while无限循环。 举个例子，在区间只有两个数的时候，比如$l=3，r=4，mid=(3+4)/2=3$，这时候如果check成功，那么会执行$l=mid$，然后问题就来了，$l$和$mid$本来就都等于3，然后就会无限循环下去，$l$和$mid$的值永远不会更新。所以在$l=mid,r=mid-1$的更新方式下，我们需要将运算时$mid+1$成为向上取整才不会死循环。 第二种 $mid=(right+left)/2$ 这种情况代码如下 while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; &#125; 为什么$mid$在这里不需要补上一个$1$呢？ 因为边界问题不会影响到值的更新，还是用上面那个例子，$l=3，r=4，mid=(3+4)/2=3$。 此时如果check成功，那么$l=mid+1=4$，更新成功。如果check失败，则$r= mid=3$，同样更新成功。由此可以看出，在$l=mid+1,r=mid$的更新方式下，不需要对$mid$进行任何操作。 以上是整数二分的两种固定写法。那么什么时候用哪种方法呢，这就要根据具体的题目进行分析了。 例题—— 分巧克力 题目描述 儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 $H_i$ 和 $W_i$。 输入保证每位小朋友至少能获得一块 $1×1$ 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 输入输出样例 输入#1 2 10 6 5 5 6 输出#1 2 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int n, k;const int N = 1e5 + 10;int h[N], w[N];bool check(int x)&#123; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; &#125; return false;&#125;int main()&#123; IOS; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i] &gt;&gt; w[i]; int l = 0, r = N; while (l &lt; r) &#123; int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; return 0;&#125; 题目很简单是二分的板子题，主要是说为什么要用第一种求$mid$方法呢。 为什么二分里面不能写成 int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; //这样写跑样例答案是3 else r = mid; 推导一遍发现，如果$check$成立后，说明当前的$mid$值也是在答案范围中，所以答案只能在$[mid, r]$之中取。理所当然无法用上面那种写法，如果用上面那种方法，$l$会直接更新成$mid+1$，会越过$mid$这个值，所以在一些情况就会出现错误，比如题面的样例$l$就会成为$2+1=3$，越过了$2$这个可能的答案值，恰好$2$就是最大的一个答案，导致答案错误。 总结 这次弄明白了二分的写法属实是不易，留文一篇防止日后遗忘 以后写二分的时候记得注意一下区间情况","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}
{"meta":{"title":"时砾逐光","subtitle":"愿前路无止境","description":"个人博客","author":"HauKuen","url":"https://exusiai.top","root":"/"},"pages":[{"title":"分类","date":"2022-11-20T08:53:47.544Z","updated":"2022-11-20T08:53:47.544Z","comments":false,"path":"categories/index.html","permalink":"https://exusiai.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-11-20T08:55:23.712Z","updated":"2022-11-20T08:55:23.712Z","comments":false,"path":"about/index.html","permalink":"https://exusiai.top/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"repository/index.html","permalink":"https://exusiai.top/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-11-22T14:31:23.189Z","updated":"2023-11-22T14:31:23.189Z","comments":false,"path":"tags/index.html","permalink":"https://exusiai.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基础算法总结","slug":"基础算法总结","date":"2024-03-13T07:07:29.000Z","updated":"2024-03-13T07:16:03.078Z","comments":true,"path":"article/25cafd126b0c.html","permalink":"https://exusiai.top/article/25cafd126b0c.html","excerpt":"三年前暑假学习算法的总结笔记，先全部放上来，之后根据自己现在的理解再慢慢修改。 并查集 基础模板 查找","text":"三年前暑假学习算法的总结笔记，先全部放上来，之后根据自己现在的理解再慢慢修改。 并查集 基础模板 查找 int find(int x) &#123; while(pre[x] !&#x3D; x) x &#x3D; pre[x]; return x; &#125; 合并 void join(int x,int y) &#123; int fx&#x3D;find(x), fy&#x3D;find(y); if(fx !&#x3D; fy) pre[fx]&#x3D;fy; &#125; 优化模板 路径压缩之优化函数 int find(int x) &#123; if (pre[x] &#x3D;&#x3D; x) return x; return pre[x] &#x3D; find(pre[x]); &#x2F;&#x2F;此代码相当于先找到根结点rootx，然后pre[x]&#x3D;rootx &#125; 小缺陷：只有当查找了某个节点的根节点后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效。 路径压缩之加权标记法 主要思想：加权标记法的核心在于对rank数组的逻辑控制，其主要的情况有： 1、如果rank[x] &lt; rank[y]，则令pre[x] = y； 2、如果rank[x] == rank[y]，则可任意指定上级； 3、如果rank[x] &gt; rank[y]，则令pre[y] = x； void join(int x, int y) &#123; x &#x3D; find(x); y &#x3D; find(y); if (x &#x3D;&#x3D; y) &#x2F;&#x2F;如果 x和 y的根节点一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑 return; if (rank[x] &gt; rank[y]) pre[y] &#x3D; x; else &#123; if (rank[x] &#x3D;&#x3D; rank[y]) rank[y]++; &#x2F;&#x2F;&#x2F;&#x2F;如果 x的高度和 y的高度相同，则令 y的高度加1 (这里是随便选的x或者y增加) &#125; &#125; 以上两种方法不能同时使用 带权并查集 路径压缩 原理：先记录下原本父节点的编号，因为在路径压缩后父节点就变为根节点了，再将当前节点的权值加上原本父节点的权值，此时父节点的权值已经是父节点到根节点的权值了，因此加上这个权值就会得到当前节点到根节点的权值。 int find(int x) &#123; if (x !&#x3D; parent[x]) &#123; int t &#x3D; parent[x]; parent[x] &#x3D; find(parent[x]); value[x] +&#x3D; value[t]; &#125; return parent[x]; &#125; 带权合并 现在是已知x所在的并查集根节点为px，y所在的并查集根节点为py，如果有了x、y之间的关系，要将px并到py上，如果不考虑权值直接修改parent就行了，但是现在是带权并查集，必须得求出px与py这条边的权值是多少，很显然x到py两条路径的权值之和应该相同。 int px &#x3D; find(x); int py &#x3D; find(y); if (px !&#x3D; py) &#123; parent[px] &#x3D; py; value[px] &#x3D; -value[x] + value[y] + s; &#125; 二分函数 头文件&lt;algorithm&gt; 1.binary_search(arrfirst,arrlast,value) arrlast为数组末地址后一个位置，相当于左闭右开，value为具体值. 功能：函数返回值为真或假. 2.lower_bound(arrfirst , arrlast, value) (仍为左闭右开区间) 功能：返回指向大于或等于value的第一个元素的指针。如果所有元素都小于value，则返回arrlast. 重载：lower_bound(arrfist , arrlast, value, greater()) 功能：返回小于或等于value的元素地址. 3.upper_bound(arrfirst , arrlast, value) 功能：在左闭右开区间进行二分查找，返回指向大于value的第一个元素的指针。如果所有元素都小于value，则返回arrlast. 重载：upper_bound(arrfist , arrlast, value, greater()) 功能：返回小于value的元素地址. 4.equal_range(arrfirst,arrlast,value) 功能：返回一个迭代器(i,j),其中i是在不破坏次序的前提下，value可插入的第一个位置，j则是在不破坏次序的前提下，value可插入的最后一个位置.因此，[i,j)内的每个元素都等同于value，而且[i,j)是[arrfirst,arrlast)之中符合此一性质的最大子区间. 以上函数在对容器使用时会返回迭代器，无需减去初始地址. 5.includes(beg,end,searchBeg,searchEnd) 功能：返回一个bool变量，两种形式都用来判断有序序列[beg,end)是否包含另一个有序序列[searchBeg,searchEnd)的全部元素.即判断子集. 折半枚举 最小化最大值 while (l &lt; r) &#123; int mid &#x3D; (l + r + 1) &gt;&gt; 1; if (check()) l &#x3D; mid; else r &#x3D; mid - 1; &#125; 最大化最小值 while (l &lt; r) &#123; int mid &#x3D; (l + r) &gt;&gt; 1; if (check()) r &#x3D; mid; else l &#x3D; mid + 1; &#125; 二分进阶 二分深入剖析 哈夫曼树 ​ 给定n个权值，作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为哈夫曼树。 ​ 哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 ​ WPL:树的带权路径长度所有叶子结点的带权路径长度之和，即为树的带权路径长度，记为WPL。 构造哈夫曼树 给定n个权值，作为n个叶子结点，构造哈夫曼树。设n个权值分别为w1、w2、······wn，哈夫曼树的构造方式如下： （1）将n个结点加入小根堆。 （2）从小根堆中取出权值最小的两个结点合并为一棵树，树的根结点的权值即为两个子结点的权值之和。 （3）将(2)中合成的根结点加入小根堆，保持堆仍为小根堆。 （4）重复(2) (3)步骤，直到小根堆中只剩一个结点，即完成一棵哈夫曼树。 设六个结点的权值分别是{6，3，8，2，10，4}，构造哈夫曼树 WPL的三种求法 1.所有叶子结点的带权路径长度之和 WPL=24+34+43+62+82+210=80 2.除根结点外的所有结点的权值之和 WPL=2+3+4+5+6+8+9+10+14+19=80 3.除叶子结点的所有结点的权值之和 WPL=33+19+14+9+5=80 哈夫曼树的特性 1.哈夫曼树并不唯一（即左右子树可以交换），但带权路径长度是相同的。 2.权值越大的结点越靠近根结点。 3.哈夫曼树中只有叶子结点（度为0）和度为2的结点，没有度为1的结点。 4.一棵有n个叶子结点的哈夫曼树共有2n-1个结点。 BFS用队列实现的思路： ​ 每遇到一个元素，就把这个元素的所有邻接元素放入队列，当队列不为空的时候，不断从队首拿出元素进行操作，直到队列为空。 ​ PS:一般情况下，用递归实现BFS比较为难，所以常用队列实现。 基本模型 &#x2F;* * @param Vs 起点 * @param Vd 终点 *&#x2F; bool BFS(Node&amp; Vs, Node&amp; Vd)&#123; queue&lt;Node&gt; Q; Node Vn, Vw; int i; &#x2F;&#x2F;初始状态将起点放进队列Q Q.push(Vs); hash(Vw) &#x3D; true;&#x2F;&#x2F;设置节点已经访问过了！ while (!Q.empty())&#123;&#x2F;&#x2F;队列不为空，继续搜索！ &#x2F;&#x2F;取出队列的头Vn Vn &#x3D; Q.front(); &#x2F;&#x2F;从队列中移除 Q.pop(); while(Vw &#x3D; Vn通过某规则能够到达的节点)&#123; if (Vw &#x3D;&#x3D; Vd)&#123;&#x2F;&#x2F;找到终点了！ &#x2F;&#x2F;把路径记录 return true;&#x2F;&#x2F;返回 &#125; if (isValid(Vw) &amp;&amp; !visit[Vw])&#123; &#x2F;&#x2F;Vw是一个合法的节点并且为白色节点 Q.push(Vw);&#x2F;&#x2F;加入队列Q hash(Vw) &#x3D; true;&#x2F;&#x2F;设置节点颜色 &#125; &#125; &#125; return false; &#125; BFS基础题-连通块问题(也可以用dfs解决) AC代码 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;cstdio&gt; char a[102][102]; int row, col; int dir[8][2] &#x3D; &#123;&#123;1, 0&#125;, &#123;1, 1&#125;, &#123;1, -1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;-1, -1&#125;&#125;; using namespace std; void dfs(int i, int j) &#123; a[i][j]&#x3D;&#39;*&#39;; for (int k &#x3D; 0; k &lt; 8; k++) &#123; int x &#x3D; i + dir[k][0]; int y &#x3D; j + dir[k][1]; if (x &gt;&#x3D; 1 &amp;&amp; x &lt;&#x3D; row &amp;&amp; y &gt;&#x3D; 1 &amp;&amp; y &lt;&#x3D; col &amp;&amp; a[x][y] &#x3D;&#x3D; &#39;@&#39;) dfs(x, y); &#125; return; &#125; int main() &#123; while ((cin &gt;&gt; row &gt;&gt; col) &amp;&amp; (row !&#x3D; 0 || col !&#x3D; 0)) &#123; int c &#x3D; 0; getchar(); for (int i &#x3D; 1; i &lt;&#x3D; row; i++) for (int j &#x3D; 1; j &lt;&#x3D; col; j++) cin &gt;&gt; a[i][j]; for (int i &#x3D; 1; i &lt;&#x3D; row; i++) for (int j &#x3D; 1; j &lt;&#x3D; col; j++) if (a[i][j] &#x3D;&#x3D; &#39;@&#39;) &#123; dfs(i, j); c++; &#125; cout &lt;&lt; c &lt;&lt; endl; &#125; return 0; &#125; 八皇后问题 三维BFS Dungeon Master AC代码 #include &lt;queue&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int inf &#x3D; 0x3f3f3f3f; int l, r, c, ans; int sx, sy, sz; char mp[35][35][35]; int vis[35][35][35]; struct node &#123; int x, y, z, step; &#125;nw, nxt; int dx[6] &#x3D; &#123;1, -1, 0, 0, 0, 0&#125;, dy[6] &#x3D; &#123;0, 0, 1, -1, 0, 0&#125;, dz[6] &#x3D; &#123;0, 0, 0, 0, 1, -1&#125;; void bfs(int z, int x, int y) &#123; vis[z][x][y] &#x3D; 1; nw.z &#x3D; z, nw.x &#x3D; x, nw.y &#x3D; y, nw.step &#x3D; 0; queue&lt;node&gt; q; q.push(nw); while(!q.empty()) &#123; nw &#x3D; q.front(), q.pop(); if(mp[nw.z][nw.x][nw.y] &#x3D;&#x3D; &#39;E&#39;) &#123; ans &#x3D; nw.step; return; &#125; for(int i &#x3D; 0; i &lt; 6; i++) &#123; nxt.z &#x3D; nw.z + dz[i]; nxt.x &#x3D; nw.x + dx[i]; nxt.y &#x3D; nw.y + dy[i]; if(nxt.z &gt;&#x3D; 0 &amp;&amp; nxt.z &lt; l &amp;&amp; nxt.x &gt;&#x3D; 0 &amp;&amp; nxt.x &lt; r &amp;&amp; nxt.y &gt;&#x3D;0 &amp;&amp; nxt.y &lt; c &amp;&amp; vis[nxt.z][nxt.x][nxt.y] &#x3D;&#x3D; 0 &amp;&amp; mp[nxt.z][nxt.x][nxt.y] !&#x3D; &#39;#&#39;) &#123; &#x2F;&#x2F;到其它层时相对位置不能为&#39;#&#39; nxt.step &#x3D; nw.step + 1; vis[nxt.z][nxt.x][nxt.y] &#x3D; 1; q.push(nxt); &#125; &#125; &#125; &#125; int main() &#123; while(~scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c) &amp;&amp; (l + r + c)) &#123; for(int i &#x3D; 0; i &lt; l; i++) &#123; for(int j &#x3D; 0; j &lt; r; j++) &#123; scanf(&quot;%s&quot;, mp[i][j]); &#x2F;&#x2F;三维存图第一维是层数！！！ for(int k &#x3D; 0; k &lt; c; k++) &#123; &#x2F;&#x2F;第二维是行数，第三维是列数 if(mp[i][j][k] &#x3D;&#x3D; &#39;S&#39;) &#123; sx &#x3D; j, sy &#x3D; k, sz &#x3D;i; &#125; &#125; &#125; &#125; memset(vis, 0, sizeof(vis)); ans &#x3D; inf; bfs(sz, sx, sy); if(ans &gt;&#x3D; inf) &#123; printf(&quot;Trapped!\\n&quot;); &#125; else &#123; printf(&quot;Escaped in %d minute(s).\\n&quot;, ans); &#125; &#125; return 0; &#125; DFS ​ DFS也可用栈实现(比较小众) ​ 思路：每遇到一个元素，就把这个元素所有的邻接元素入栈，当栈不为空时，不断的从栈顶拿出元素进行操作，直到栈为空。 ​ 优点:DFS能够做到使用一个状态变量去搜索所有的状态空间，这对空间的消耗来说，是非常节约空间的（通常使用递归实现）。主要应用于回溯的搜索问题中，比如迷宫问题，岛屿问题。 基本模型 int check(参数) &#123; if(满足条件) return 1; return 0; &#125; void dfs(int step) &#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（回溯的时候要用到） &#125; &#125; 模板例题 P1605-迷宫 链接 进阶 DFS算法+剪枝+优化总结 图论基础 图的基本概念 1.若一个图的边数接近完全图，则称这样的图为稠密图。 2.若一个图的边数远小于完全图，则称这样的图为稀疏图。 顶点的度 在无向图中，是指依附于该点的边数，在有向图中还分入度和出度。 图的存储方式 邻接矩阵——适合稠密图 邻接表——适合稀疏图 链式前向星(静态邻接表) 通常情况下，邻接表是O(n+e)的复杂程度（n表示节点数，e表示边长），邻接矩阵则是O(n^2)的复杂程度。 邻接矩阵 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn&#x3D;105; int G[maxn][maxn]&#x3D;&#123;0&#125;; &#x2F;&#x2F;定义邻接矩阵 int x,y; &#x2F;&#x2F;输入两条边 int n,m; &#x2F;&#x2F;供输入n对边 ,m个顶点 (x,y &lt;&#x3D; m) int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; cin &gt;&gt; x &gt;&gt; y; G[x][y] &#x3D; 1; G[y][x] &#x3D; 1; &#x2F;&#x2F;有向图去掉就可 &#125; for (int i &#x3D; 0; i &lt; m; i++) &#x2F;&#x2F;输出邻接矩阵 &#123; for (int j &#x3D; 0; j &lt; m; j++) &#123; cout &lt;&lt; G[i][j] &lt;&lt; &#39; &#39;; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; 邻接表(vector) #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int MAXN &#x3D; 1e3 + 5; const int INF &#x3D; 0x3f3f3f3f; &#x2F;&#x2F; 仅存储 vector&lt;int&gt; edge[MAXN]; int main() &#123; int n, m, u, v; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); &#x2F;&#x2F; n个点，m条边 while (m--) &#123; scanf(&quot;%d%d&quot;, &amp;u, &amp;v); &#x2F;&#x2F; 无向图 edge[u].push_back(v); edge[v].push_back(u); &#x2F;&#x2F; 有向图 &#x2F;&#x2F; edge[u].push_back(v); &#125; return 0; &#125; 拓扑排序 概念：拓扑排序要解决的问题是给一个图的所有节点排序。 Kahn 算法 算法的核心思想是维持一个入度为 0 的顶点的集合。 从图中取出入度为0的顶点放入集合，并在图中删除与该顶点相关的所有边，如此往复，最后检查图中是否存在任何边，若存在，那么这个图一定有环路，否则返回集合中的顶点，返回的顺序就是拓扑排序的顺序。 对其排序的结果就是：2 -&gt; 8 -&gt; 0 -&gt; 3 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 6 -&gt; 9 -&gt; 4 -&gt; 11 -&gt; 10 -&gt; 12 代码实现 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; bool TopSort(vector&lt;vector&lt;int&gt;&gt; &amp;G, int n, vector&lt;int&gt; &amp;inDegree) &#123; int num &#x3D; 0; &#x2F;&#x2F;记录加入拓扑排序的顶点数 queue&lt;int&gt; q; for (int i &#x3D; 0; i &lt; n; i++) if (inDegree[i] &#x3D;&#x3D; 0) q.push(i); &#x2F;&#x2F;将所有入度为0的顶点入队 while (!q.empty()) &#123; int u &#x3D; q.front(); &#x2F;&#x2F;取队首顶点u cout &lt;&lt; u &lt;&lt; &quot; &quot;; q.pop(); for (int i &#x3D; 0; i &lt; G[u].size(); i++) &#123; int v &#x3D; G[u][i]; &#x2F;&#x2F;u的后继节点 inDegree[v]--; &#x2F;&#x2F;v的入度减1 if (inDegree[v] &#x3D;&#x3D; 0) &#x2F;&#x2F;顶点v的入度减为0则入队 q.push(v); &#125; G[u].clear(); &#x2F;&#x2F;清空顶点u的所有出边 num++; &#125; if (num &#x3D;&#x3D; n) &#x2F;&#x2F;加入拓扑序列的顶点数为n，说明拓扑排序成功，否则，失败 return true; else return false; &#125; int main() &#123; int n, m; cout &lt;&lt; &quot;请输入顶点数和边数:&quot;; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; G(n); for (int i &#x3D; 0; i &lt; m; i++) &#123; int x, y; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i+1 &lt;&lt; &quot;条边的顶点:&quot;; cin &gt;&gt; x &gt;&gt; y; G[x].push_back(y); &#125; cout &lt;&lt; &quot;拓扑排序为:&quot;; vector&lt;int&gt; inDegree(n); for (auto x : G) &#123; for (auto y : x) inDegree[y]++; &#125; bool res &#x3D; TopSort(G, n, inDegree); return 0; &#125; DFS算法 vector&lt;int&gt; G[MAXN]; &#x2F;&#x2F; vector 实现的邻接表 int c[MAXN]; &#x2F;&#x2F; 标志数组 vector&lt;int&gt; topo; &#x2F;&#x2F; 拓扑排序后的节点 bool dfs(int u) &#123; c[u] &#x3D; -1; for (int v : G[u]) &#123; if (c[v] &lt; 0) return false; else if (!c[v]) if (!dfs(v)) return false; &#125; c[u] &#x3D; 1; topo.push_back(u); return true; &#125; bool toposort() &#123; topo.clear(); memset(c, 0, sizeof(c)); for (int u &#x3D; 0; u &lt; n; u++) if (!c[u]) if (!dfs(u)) return false; reverse(topo.begin(), topo.end()); return true; &#125; 前缀和&amp;差分 前缀和 即为数列的前n项和。 C++ 标准库中实现了前缀和函数 std::partial_sum，定义于头文件 &lt;numeric&gt; 中。 注意：一般写前缀和遍历的时候令i=1，因为递推公式是B[i]=A[i]+B[i-1],要保证第一位存在所以不能让i=0。 求前缀和区间值:sum[l,r]=B[r]-B[l-1] 二维前缀和 假定一个矩阵 1 2 4 3 5 1 2 4 6 3 5 9 它的二维前缀和矩阵为 1 3 7 10 6 9 15 22 12 18 29 45 公式：sum[i] [j]=sum[i] [j-1]+sum[i-1] [j]-sum[i-1] [j-1]+a[i] [j] 子矩阵之和 求(x1,y1)到(x2,y2)的子矩阵之和 **sum[x2] [y2] – sum[x2] [y1-1] – sum[x1-1] [y2] + sum[x1-1] [y1-1] ** 差分 差分是一种和前缀和相对的策略，可以当做是求和的逆运算。 b[i]=a[i]-a[i-1] 单调栈&amp;单调队列 概念：单调栈和单调队列都是满足单调性的数据结构。两者不同之处在于单调队列只能在一端进出，而单调队列是一端入一端出。 单调栈 插入 将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。 使用样例：栈中自顶向下的元素为 1,3,5,20,30,插入元素10时为了保证单调性需要依次弹出元素1,3,5，最后操作后栈中元素为10,20,30。 单调队列 概念：从队列头部到队列的尾部严格保持递增(或递减)，与普通队列不同的是，单调队列要求可以在队尾进行操作，&lt;queue&gt;无法做到，可以手动模拟或者使用stl的双端队列&lt;deque&gt; 。 例题Sliding Window 分析 要求的是每连续的 个数中的最大（最小）值，很明显，当一个数进入所要 “寻找” 最大值的范围中时，若这个数比其前面（先进队）的数要大，显然，前面的数会比这个数先出队且不再可能是最大值。也就是说——当满足以上条件时，可将前面的数 “弹出”，再将该数真正 push 尾。 这就相当于维护了一个递减的队列，符合单调队列的定义，减少了重复的比较次数，不仅如此，由于维护出的队伍是查询范围内的且是递减的，队头必定是该查询区域内的最大值，因此输出时只需输出队头即可。 题解 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #define maxn 1000100 using namespace std; int q[maxn], a[maxn]; int n, k; void getmin() &#123; int head &#x3D; 0, tail &#x3D; 0; for (int i &#x3D; 1; i &lt; k; i++) &#123; while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &gt;&#x3D; a[i]) tail--; q[++tail] &#x3D; i; &#125; for (int i &#x3D; k; i &lt;&#x3D; n; i++) &#123; while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &gt;&#x3D; a[i]) tail--; q[++tail] &#x3D; i; while (q[head] &lt;&#x3D; i - k) head++; printf(&quot;%d &quot;, a[q[head]]); &#125; &#125; void getmax() &#123; int head &#x3D; 0, tail &#x3D; 0; for (int i &#x3D; 1; i &lt; k; i++) &#123; while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &lt;&#x3D; a[i]) tail--; q[++tail] &#x3D; i; &#125; for (int i &#x3D; k; i &lt;&#x3D; n; i++) &#123; while (head &lt;&#x3D; tail &amp;&amp; a[q[tail]] &lt;&#x3D; a[i]) tail--; q[++tail] &#x3D; i; while (q[head] &lt;&#x3D; i - k) head++; printf(&quot;%d &quot;, a[q[head]]); &#125; &#125; int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); getmin(); printf(&quot;\\n&quot;); getmax(); printf(&quot;\\n&quot;); return 0; &#125; 线段树 概念：线段树是算法竞赛中常用的用来维护 区间信息 的数据结构。 线段树可以在***O(logN)***的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。 模板代码 建树 void build(int *a, int q, int l, int r) &#123; if (l &#x3D;&#x3D; r) &#123; st[q] &#x3D; a[l]; return; &#125; int mid &#x3D; (l + r) &#x2F; 2; build(a, q * 2 + 1, l, mid); build(a, q * 2 + 2, mid + 1, r); st[q] &#x3D; st[q * 2 + 1] + st[q * 2 + 2]; &#125; &#x2F;&#x2F;build(a, 1, 1, n); 单点更新 void update_single(int q, int l, int r, int x, int num) &#123; &#x2F;&#x2F;q为初始节点(一般默认为1)，l，r为线段树范围，x为具体节点，num为更新值 if (l &#x3D;&#x3D; x &amp;&amp; r &#x3D;&#x3D; x) &#123; st[q] +&#x3D; num; return; &#125; int mid &#x3D; (l + r) &#x2F; 2; if (mid &gt;&#x3D; x) update(q * 2 + 1, l, mid, x, num); else update(q * 2 + 2, mid + 1, r, x, num); st[q] &#x3D; st[q * 2 + 1] + st[q * 2 + 2]; &#125; 只单点更新的区间求和 int query(int q, int l, int r, int tl, int tr) &#123; &#x2F;&#x2F;tl,tr为求和区间 if (tl &lt;&#x3D; l &amp;&amp; r &lt;&#x3D; tr) return st[q]; int mid &#x3D; (l + r) &#x2F; 2, sum &#x3D; 0; if (tl &lt;&#x3D; mid) sum +&#x3D; query(q * 2 + 1, l, mid, tl, tr); if (tr &gt; mid) sum +&#x3D; query(q * 2 + 2, mid + 1, r, tl, tr); return sum; &#125; 区间更新 &#x2F;&#x2F;区间[tl,tr]的值全部加num void update_region(int q, int l, int r, int tl, int tr, int num) &#123; if (l &gt;&#x3D; tl &amp;&amp; r &lt;&#x3D; tr) &#123; st[q] +&#x3D; num * (r - l + 1); lazy[q] +&#x3D; num; return; &#125; if (lazy[q]) pushdown(q, l, r); int mid &#x3D; (l + r) &#x2F; 2; if (tl &lt;&#x3D; mid) update_region(q * 2, l, mid, tl, tr, num); if (tr &gt; mid) update_region(q * 2 + 1, mid + 1, r, tl, tr, num); st[q] &#x3D; st[q * 2] + st[q * 2 + 1]; &#125; 延迟标记 &#x2F;&#x2F;将下标k的节点lazy向下传递 void pushdown(int k, int l, int r) &#123; int mid &#x3D; (l + r) &#x2F; 2; lazy[2 * k] +&#x3D; lazy[k]; st[2 * k] +&#x3D; ((mid - l) + 1) * lazy[k]; lazy[2 * k + 1] +&#x3D; lazy[k]; st[2 * k + 1] +&#x3D; (r - mid) * lazy[k]; lazy[k] &#x3D; 0; &#125; 区间更新的区间求和 int query(int q, int l, int r, int tl, int tr) &#123; if(l&gt;&#x3D;tl&amp;&amp;r&lt;&#x3D;tr) return st[q]; if(lazy[q]) pushdown(q, l, r);&#x2F;&#x2F;下放标记 int sum &#x3D; 0; int mid &#x3D; (l + r) &#x2F; 2; if (tl &lt;&#x3D; mid) sum +&#x3D; query(q * 2, l, mid, tl, tr); if (tr &gt; mid) sum +&#x3D; query(q * 2 + 1, mid + 1, r, tl, tr); return sum; &#125; 经典例题敌兵布阵+思路+题解 字典树 概念：字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。 模板代码 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn&#x3D;1e7; int trie[maxn][26]; string s; int ind&#x3D;1; int flag[maxn]; void insert(string s)&#x2F;&#x2F;插入操作 &#123; int t &#x3D; 0; for (int i &#x3D; 0; s[i]; i++) &#123; int x &#x3D; s[i] - &#39;a&#39;; &#x2F;&#x2F;x是t节点的第x个孩子 if (trie[t][x] &#x3D;&#x3D; 0) &#x2F;&#x2F;如果没有就添加节点 trie[t][x] &#x3D; ind++; &#x2F;&#x2F;ind为节点编号 t &#x3D; trie[t][x]; ans[t]++; &#125; &#x2F;&#x2F; flag[t]&#x3D;1; &#x2F;&#x2F;用flag标记字符串的最后一个节点位置，查询的时候可以防止出错，如树中有cart，不添加标记如果查询car就会出现错误 &#125; bool query(string s) &#x2F;&#x2F;查询是否存在目标字符串 &#123; int t &#x3D; 0; for (int i &#x3D; 0; s[i]; i++) &#123; int x &#x3D; s[i] - &#39;a&#39;; if (trie[t][x] &#x3D;&#x3D; 0) &#x2F;&#x2F;中途没有查询到就返回false return 0; t &#x3D; trie[t][x]; &#x2F;&#x2F;前往下一个节点 &#125; return flag[t]; &#x2F;&#x2F;插入时的标记在此发挥作用 &#125; 最短路问题 四种算法 Floyd算法 Dijkstra算法 Bellman-Ford算法 SPFA算法 Floyd算法 用来求任意两个节点之间的最短路 缺点：复杂度较高为O(n^3)，一般只适合三位数的数据大小。 优点：适用于任何图，代码简单，边权可以为负，但是不能有负环(必须存在最短路)。 核心代码 for (k &#x3D; 1; k &lt;&#x3D; n; k++) &#123; for (x &#x3D; 1; x &lt;&#x3D; n; x++) &#123; for (y &#x3D; 1; y &lt;&#x3D; n; y++) &#123; f[x][y] &#x3D; min(f[x][y], f[x][k] + f[k][y]); &#125; &#125; &#125; 原本f数组是有三维的，但是第一维可以省略不会产生影响，这里不进行深究。 Dijkstra算法 用来求单源最短路的算法，图的边权不能为负，时间复杂度为O(N^2)，堆优化为O(mlogn)。 模板代码 #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;set&gt; #include &lt;string.h&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;stdio.h&gt; #include&lt;algorithm&gt; #include&lt;math.h&gt; using namespace std; const int inf&#x3D;0x3f3f3f3f; const int maxn &#x3D; 1e3 + 10; int n,m;&#x2F;&#x2F;n个顶点，m条边。 bool visited[maxn];&#x2F;&#x2F;判断是否确定到源点的最终最短距离。 int graph[maxn][maxn]; int dis[maxn];&#x2F;&#x2F;顶点到源点的最短距离。 int start,goal; void init() &#123; memset(visited, false, sizeof(visited)); for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; dis[i] &#x3D; graph[start][i]; &#x2F;&#x2F;从start点到i点的距离 &#125; &#125; void dijkstra() &#123; int minn;&#x2F;&#x2F;记录每趟最短路径中最小的路径值。 int pos &#x3D; 0; &#x2F;&#x2F;记录得到的minn所对应的下标。 init(); visited[start] &#x3D; true; &#x2F;&#x2F;因为pos为0，所以这里标不标记都一样 for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; &#x2F;&#x2F;将n个顶点依次加入判断。 minn &#x3D; inf; for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if (!visited[j] &amp;&amp; dis[j] &lt; minn) &#123; minn &#x3D; dis[j]; pos &#x3D; j; &#125; &#125; &#x2F;&#x2F;经过这趟for循环后找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。 visited[pos] &#x3D; true; &#x2F;&#x2F;将此点并入已知集合。 &#x2F;&#x2F;接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。 for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123; if (!visited[j] &amp;&amp; dis[j] &gt; dis[pos] + graph[pos][j]) dis[j] &#x3D; dis[pos] + graph[pos][j]; &#125; &#125; &#x2F;&#x2F;退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。 if (dis[goal] &#x3D;&#x3D; inf) cout &lt;&lt; -1 &lt;&lt; endl; else cout &lt;&lt; dis[goal] &lt;&lt; endl; &#x2F;&#x2F;输出目标点到源点的最短路径长度。 &#125; int main() &#123; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123; memset(graph, inf, sizeof(graph)); int u, v, w; for (int i &#x3D; 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (w &lt; graph[u][v])&#x2F;&#x2F; 判断重边，取最小值 graph[u][v] &#x3D; w; if (w &lt; graph[v][u]) graph[v][u] &#x3D; w; &#125; start &#x3D; 1, goal &#x3D; n; dijkstra(); &#125; return 0; &#125; Bellman-Ford算法 能找到某个结点出发到所有结点的最短路，或者报告某些最短路不存在 可以在负权图中使用，可以用来寻找是否有负环 核心代码 for(int k &#x3D; 1 ; k &lt;&#x3D; n - 1 ; k ++) &#x2F;&#x2F;n为点 &#123; for(int i &#x3D; 1 ; i &lt; m ; i ++) &#x2F;&#x2F;m为边，枚举每一条边 &#123; if(dis[v[i]] &gt; dis[u[i]] + w[i])&#x2F;&#x2F;尝试对每一条边进行松弛 dis[v[i]] &#x3D; dis[u[i]] + w[i] ;&#x2F;&#x2F;dis数组记录源点到其余各个顶点的最短路径 &#125; &#125; 模板例题+代码 题目 第1行输入n,m，其中n为顶点，m为边的关系 第2-m+1行给出两个点和之间的距离 求1号点到每个点的最短路 题解 #include&lt;bits&#x2F;stdc++.h&gt; const int INF &#x3D; 0x3f3f3f; using namespace std; int main() &#123; int u[100] , v[100] , w[100] , dis[100] , n , m ; cin &gt;&gt; n &gt;&gt; m; for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++) &#123; cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i]; &#125; for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++) dis[i] &#x3D; INF; dis[1] &#x3D; 0; for(int k &#x3D; 1 ; k &lt;&#x3D; n - 1 ; k ++) for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++) if(dis[v[i]] &gt; dis[u[i]] + w[i]) dis[v[i]] &#x3D; dis[u[i]] + w[i]; for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++) cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;; return 0 ; &#125; SPFA算法 是Bellman-Ford的队列优化 优化原理：Bellman-Ford算法会进行很多次无用的松弛操作，但是易知，只有上次被松弛过得节点所连接的边才会引起下一次的松弛，所以用队列维护可能引起松弛操作的节点就可以省略操作不必要的边。 思想：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。 模板代码 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn &#x3D; 200010; struct edge &#123; int to, next, w; &#125; e[maxn]; int n, m, cnt, p[maxn], Dis[maxn]; int In[maxn]; bool visited[maxn]; void add(const int x, const int y, const int z) &#123; e[++cnt].to &#x3D; y; e[cnt].next &#x3D; p[x]; e[cnt].w &#x3D; z; p[x] &#x3D; cnt; return; &#125; bool Spfa(const int S) &#123; int i, t, temp; queue&lt;int&gt; Q; memset(visited, 0, sizeof(visited)); memset(Dis, 0x3f, sizeof(Dis)); memset(In, 0, sizeof(In)); Q.push(S); visited[S] &#x3D; true; Dis[S] &#x3D; 0; while (!Q.empty()) &#123; t &#x3D; Q.front(); Q.pop(); visited[t] &#x3D; false; for (i &#x3D; p[t]; i; i &#x3D; e[i].next) &#123; temp &#x3D; e[i].to; if (Dis[temp] &gt; Dis[t] + e[i].w) &#123; Dis[temp] &#x3D; Dis[t] + e[i].w; if (!visited[temp]) &#123; Q.push(temp); visited[temp] &#x3D; true; if (++In[temp] &gt; n) return false; &#125; &#125; &#125; &#125; return true; &#125; int main ( ) &#123; int s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; add(a, b, c); &#125; if (!Spfa(s)) cout &lt;&lt; &quot;fail&lt;&lt;endl&quot;; else cout &lt;&lt; Dis[t] &lt;&lt; endl; return 0; &#125; 最小生成树 Kruskal算法 知识点：对边贪心，并查集 思想：从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了n-1条边，即形成了一棵树。 模板代码 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int N &#x3D; 5010; struct node &#123; int u, v, w; &#125; edge[N]; int n, m, num, ans; int pre[N]; bool cmp(node a, node b)&#x2F;&#x2F;按照边的距离排序 &#123; return a.w &lt; b.w; &#125; void init() &#123; num &#x3D; 0, ans &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) pre[i] &#x3D; i;&#x2F;&#x2F;初始化，父节点为自己 &#125; int find(int x) &#123; if (x !&#x3D; pre[x]) &#x2F;&#x2F;路径压缩 return pre[x] &#x3D; find(pre[x]); return x; &#125; void merge(int x,int y)&#x2F;&#x2F;合并函数 &#123; int a &#x3D; find(x); int b &#x3D; find(y); if (a !&#x3D; b) pre[a] &#x3D; b; &#125; void krusal() &#123; sort(edge, edge + m, cmp);&#x2F;&#x2F;排序 for (int i &#x3D; 0; i &lt; m; i++) &#123; int x &#x3D; edge[i].u; int y &#x3D; edge[i].v; if (find(x) !&#x3D; find(y)) &#x2F;&#x2F;两个点的父节点不是同一个就直接合并，如果是同一个的话就直接丢弃这个边，继续下一个边 &#123; merge(x, y); num++; ans +&#x3D; edge[i].w; if (num &#x3D;&#x3D; n - 1)&#x2F;&#x2F;根据性质，最小生成树的边是结点数-1,，如果边数够了就表明满足条件 &#123; cout &lt;&lt; ans &lt;&lt; endl; return; &#125; &#125; &#125;&#x2F;&#x2F;循环结束边数都不够说明无法构成最小生成树 cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl; return; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; init(); for (int i &#x3D; 0; i &lt; m; i++) &#123; cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].w; &#125; krusal(); return 0; &#125; Prim算法 知识点：对点贪心 思想：每次选择距离当前节点最近的一个节点，并用这条边更新其它节点的距离。 模板代码 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int inf&#x3D;0x3f3f3f; const int maxx&#x3D;500+10; int e[maxx][maxx], dis[maxx]; bool book[maxx]; int n,m; void init()&#x2F;&#x2F;初始化，自己到自己初始化为0，到其他点为inf &#123; for (int i &#x3D; 0; i &lt; m; i++) for (int j &#x3D; 0; j &lt; m; j++) if (i &#x3D;&#x3D; j) e[i][j] &#x3D; 0; else e[i][j] &#x3D; inf; &#125; int prim(int e[][maxx], int n) &#123; int ans &#x3D; 0; memset(book, false, sizeof(book)); for (int i &#x3D; 0; i &lt; n; i++) dis[i] &#x3D; e[0][i]; for (int i &#x3D; 0; i &lt; n; i++) &#123; int minn &#x3D; inf, u &#x3D; -1; for (int j &#x3D; 0; j &lt; n; j++) &#123; if (!book[j] &amp;&amp; dis[j] &lt; minn) &#x2F;&#x2F;未被标记且距离更小 &#123; minn &#x3D; dis[j]; u &#x3D; j; &#125; &#125; if (u &#x3D;&#x3D; -1) return 0; ans +&#x3D; minn; book[u] &#x3D; true;&#x2F;&#x2F;访问后进行标记 for (int v &#x3D; 0; v &lt; n; v++) if (!book[v] &amp;&amp; e[u][v] !&#x3D; inf) dis[v] &#x3D; min(dis[v], e[u][v]); &#125; return ans; &#125; int main() &#123; cin &gt;&gt; m &gt;&gt; n; init(); for (int i &#x3D; 0; i &lt; n; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (e[a][b] &gt; c) e[a][b] &#x3D; e[b][a] &#x3D; c;&#x2F;&#x2F;无向图 &#125; int cnt &#x3D; prim(e, m); if (cnt) cout &lt;&lt; cnt &lt;&lt; endl; else cout &lt;&lt; &quot;orz&quot; &lt;&lt; endl;&#x2F;&#x2F;没有最小生成树 return 0; &#125; Prim参考代码 &#x2F;*prim算法求最小生成树 邻接矩阵法构造图 算法思想：首先从顶点0出发，然后找到下一个距离顶点0最近的顶点i，也进入集合U 此算法是从进入了集合U的顶点中找到个各顶点与其他未进入集合U的顶点之间的一条最短的边去连接的 *&#x2F; # include&lt;stdio.h&gt; #include&lt;iostream&gt; using namespace std; int inf&#x3D;0x3f3f3f3f; int s[100][100];&#x2F;&#x2F;存储图 bool selected[100];&#x2F;&#x2F;判断顶点是否被选中 int minCost[100];&#x2F;&#x2F;保存已选顶点中到该顶点的最小的路径 int parent[100];&#x2F;&#x2F;保存父节点 void prim(int n,int k)&#123; &#x2F;&#x2F;第一步，第K个顶点被选中 selected[k]&#x3D;true; minCost[k]&#x3D;-1; &#x2F;&#x2F;开始更新minCost数组和parent数组 for(int i&#x3D;0;i&lt;n;i++)&#123; if(s[k][i]!&#x3D;inf&amp;&amp;s[k][i]&lt;minCost[i]) &#123; minCost[i]&#x3D;s[k][i]; parent[i]&#x3D;k; &#125; &#125; &#x2F;&#x2F;在minCost数组中找到最小的那个值，然后选择对应的点 int min&#x3D;inf;int f&#x3D;-1; for(int j&#x3D;0;j&lt;n;j++) &#123; if(minCost[j]!&#x3D;-1&amp;&amp;minCost[j]&lt;min)&#123; min&#x3D;minCost[j]; f&#x3D;j; &#125; &#125; if(f&#x3D;&#x3D;-1) return;&#x2F;&#x2F;全部都已经被选了 prim(n,f); &#125; int main(void)&#123; &#x2F;&#x2F;输入图的顶点个数 int n; cin&gt;&gt;n; for(int i&#x3D;0;i&lt;n;i++)&#123; for(int j&#x3D;0;j&lt;n;j++)&#123; cin&gt;&gt;s[i][j]; if(s[i][j]&#x3D;&#x3D;0) s[i][j]&#x3D;inf; &#125; selected[i]&#x3D;false; minCost[i]&#x3D;inf; parent[i]&#x3D;-1; &#125; &#x2F;&#x2F; cout&lt;&lt;&quot;图输入完成！&quot;; prim(n,0); int sum&#x3D;0; for(int i&#x3D;1;i&lt;n;i++) &#123; sum&#x3D;sum+s[i][parent[i]]; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#x2F;*6 0 6 1 5 0 0 6 0 5 0 3 0 1 5 0 5 6 4 5 0 5 0 0 2 0 3 6 0 0 6 0 0 4 2 6 0*&#x2F; 倍增求LCA 朴素算法 让节点一层一层在树上跳，预处理时需要dfs整棵树，时间复杂度为O(n)，单次查询O(logN),如果是单次查询的话可以考虑朴素算法，应该比倍增快。 BFS求节点深度 #include &lt;bits&#x2F;stdc++.h&gt; #define MXN 50007 using namespace std; vector&lt;int&gt; v[MXN]; vector&lt;int&gt; w[MXN]; int fa[MXN][31], cost[MXN][31], dep[MXN]; int n, m; int a, b, c; &#x2F;&#x2F; 接受两个参数：dfs 起始节点和它的父亲节点。 void dfs(int root, int fno) &#123; &#x2F;&#x2F; 初始化：第 2^0 &#x3D; 1 个祖先就是它的父亲节点，dep 也比父亲节点多 1。 fa[root][0] &#x3D; fno; dep[root] &#x3D; dep[fa[root][0]] + 1; &#x2F;&#x2F; 初始化：其他的祖先节点：第 2^i 的祖先节点是第 2^(i-1) 的祖先节点的第 &#x2F;&#x2F; 2^(i-1) 的祖先节点。 for (int i &#x3D; 1; i &lt; 31; ++i) &#123; fa[root][i] &#x3D; fa[fa[root][i - 1]][i - 1]; cost[root][i] &#x3D; cost[fa[root][i - 1]][i - 1] + cost[root][i - 1]; &#125; &#x2F;&#x2F; 遍历子节点来进行 dfs。 int sz &#x3D; v[root].size(); for (int i &#x3D; 0; i &lt; sz; ++i) &#123; if (v[root][i] &#x3D;&#x3D; fno) continue; cost[v[root][i]][0] &#x3D; w[root][i]; dfs(v[root][i], root); &#125; &#125; 倍增算法 时间复杂度为O(nlogn) 基础模板代码 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn &#x3D; 5e5 + 5; int n, m, s; int lg[maxn]; int dep[maxn]; int fa[maxn][25]; vector&lt;int&gt; G[maxn]; void getdep(int u) &#123; &#x2F;&#x2F;求祖先数组 for (int i &#x3D; 1; i &lt;&#x3D; lg[dep[u]]; i++) fa[u][i] &#x3D; fa[fa[u][i - 1]][i - 1]; for (int i &#x3D; 0; i &lt; G[u].size(); i++) &#123; &#x2F;&#x2F;遍历u所有边 int e &#x3D; G[u][i]; if (e !&#x3D; fa[u][0]) &#123; fa[e][0] &#x3D; u; dep[e] &#x3D; dep[u] + 1; getdep(e); &#125; &#125; &#125; int lca(int u,int v) &#123; if (dep[u] &lt; dep[v]) swap(u, v); while (dep[u] !&#x3D; dep[v]) u &#x3D; fa[u][lg[dep[u] - dep[v]]]; if (u &#x3D;&#x3D; v) return u; for (int j &#x3D; lg[dep[u]]; j &gt;&#x3D; 0; j--) &#123; if (fa[u][j] !&#x3D; fa[v][j]) &#123; u &#x3D; fa[u][j]; v &#x3D; fa[v][j]; &#125; &#125; return fa[u][0]; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; lg[i] &#x3D; lg[i - 1]; if (i &#x3D;&#x3D; (1 &lt;&lt; lg[i - 1])) lg[i]++; &#125; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) lg[i]--; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v);&#x2F;&#x2F;无向图 G[v].push_back(u); &#125; &#x2F;&#x2F;无向图可以用任意一个节点当做根节点 &#x2F;&#x2F;选择初始化1的深度为1，以1为根节点建树 dep[1] &#x3D; 1; getdep(1); for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; endl; &#125; return 0; &#125; 例题HDU 2586 How far away? 思路:只需要在LCA中执行上跳的操作时，加上对应的长度，就可以求得需要距离。 题解 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn&#x3D;4e4+5; int n,m; int lg[maxn]; int dep[maxn]; &#x2F;&#x2F;深度 int f[maxn][25]; int value[maxn][25]; vector&lt;int&gt; a[maxn],w[maxn]; void init() &#123; memset(dep, 0, sizeof dep); memset(f, 0, sizeof f); memset(value, 0, sizeof value); for (int i &#x3D; 0; i &lt; maxn; i++) &#123; a[i].clear(); w[i].clear(); &#125; &#125; void getdep(int u) &#123; &#x2F;&#x2F;完善祖先数组和到这个祖先长度的数组 for (int i &#x3D; 1; i &lt;&#x3D; lg[dep[u]]; i++) &#123; f[u][i] &#x3D; f[f[u][i - 1]][i - 1]; value[u][i] &#x3D; value[u][i - 1] + value[f[u][i - 1]][i - 1]; &#125; &#x2F;&#x2F;遍历所有u的边 for (int i &#x3D; 0; i &lt; a[u].size(); i++) &#123; int e &#x3D; a[u][i]; &#x2F;&#x2F;不遍历父亲的边 if (e !&#x3D; f[u][0]) &#123; &#x2F;&#x2F;无向图不能在录入边时记录父亲，所以在这记录 f[e][0] &#x3D; u; &#x2F;&#x2F;记录的点是到父亲的长度 value[e][0] &#x3D; w[u][i]; dep[e] &#x3D; dep[u] + 1; getdep(e); &#125; &#125; &#125; int lca(int u, int v) &#123; int sum &#x3D; 0; if (dep[u] &lt; dep[v]) &#123; swap(u, v); &#125; while (dep[u] !&#x3D; dep[v]) &#123; &#x2F;&#x2F;u节点上跳的同时，更新总长度 sum +&#x3D; value[u][lg[dep[u] - dep[v]]]; u &#x3D; f[u][lg[dep[u] - dep[v]]]; &#125; &#x2F;&#x2F;如果v是u祖先；直接返回现在的总长度； if (u &#x3D;&#x3D; v) return sum; for (int j &#x3D; lg[dep[u]]; j &gt;&#x3D; 0; j--) &#123; if (f[u][j] !&#x3D; f[v][j]) &#123; &#x2F;&#x2F;节点上跳的同时，更新总长度 sum +&#x3D; value[u][j]; sum +&#x3D; value[v][j]; u &#x3D; f[u][j]; v &#x3D; f[v][j]; &#125; &#125; &#x2F;&#x2F;u和v离LCA还差一步，加上这两个距离。 sum +&#x3D; value[u][0]; sum +&#x3D; value[v][0]; return sum; &#125; int main() &#123; &#x2F;&#x2F;lg[i]中是i内最大的2的幂次数，如lg【5】中值为2，代表2^2是5内最大2的幂次数。 for (int i &#x3D; 1; i &lt; maxn; i++) &#123; lg[i] &#x3D; lg[i - 1]; if (i &#x3D;&#x3D; (1 &lt;&lt; lg[i - 1])) lg[i]++; &#125; for (int i &#x3D; 1; i &lt; maxn; i++) &#123; lg[i]--; &#125; &#x2F;&#x2F;t组样例 int t; cin &gt;&gt; t; while (t--) &#123; &#x2F;&#x2F;初始化 init(); &#x2F;&#x2F;n个节点，m次询问 cin &gt;&gt; n &gt;&gt; m; for (int i &#x3D; 1; i &lt; n; i++) &#123; int u, v, k; cin &gt;&gt; u &gt;&gt; v &gt;&gt; k; &#x2F;&#x2F;无向图建边两次 &#x2F;&#x2F;都加上边权 a[u].push_back(v); w[u].push_back(k); a[v].push_back(u); w[v].push_back(k); &#125; &#x2F;&#x2F;无向图任意节点都可以为根节点，这里选了1做根节点 dep[1] &#x3D; 1; getdep(1); for (int i &#x3D; 0; i &lt; m; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; lca(x, y) &lt;&lt; endl; &#125; &#125; &#125; LCA还可以用tarjan算法求,这里不拓展总结。 Tarjan算法 Tarjan求强连通分量 在 Tarjan 算法中为每个结点u维护了以下几个变量： dfn[u]:深度优先搜索遍历时结点u被搜索的次序 low[u]:u在图中可以到达最小的dfn 性质: 每个结点的dfn都是不一样的 每次在dfn中找到新结点时，该结点的dfn和low赋相同值 一个结点的子树内结点的 dfn 都大于该结点的 dfn从根开始的一条路径上的dfn 严格递增，low 严格非降。 伪代码 tarjan(u)&#123; DFN[u]&#x3D;Low[u]&#x3D;++Index &#x2F;&#x2F;为节点u设定次序编号和Low初值 Stack.push(u) &#x2F;&#x2F;将节点u压入栈中 foreach(u,v) in E &#x2F;&#x2F;枚举每一条边 if(v is not visted) &#x2F;&#x2F;如果节点v未被访问过 tarjan(v) &#x2F;&#x2F;继续向下找 Low[u]&#x3D;min(Low[u],Low[v]) else if(v in S) &#x2F;&#x2F;如果节点v还在栈内 Low[u]&#x3D;min(Low[u],DFN[v]) if(DFN[u]&#x3D;&#x3D;Low[u]) &#x2F;&#x2F;如果节点u是强连通分量的根 repeat v&#x3D;S.pop&#x2F;&#x2F;将v退栈，为该强连通分量中一个顶点 print v until(u&#x3D;&#x3D;v) &#125; 可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。N为点数，M为边数。 模板代码（手动模拟栈） #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; const int MAX &#x3D; 10005; #define ll long long vector&lt;ll&gt; g[MAX]; ll color[MAX], vis[MAX], stack[MAX], dfn[MAX], low[MAX], cnt[MAX]; &#x2F;&#x2F;deep:节点编号 top：栈顶 sum：强连通分量数目 ll deep, top, sum, res &#x3D; 0; void tanjan(ll v) &#123; dfn[v] &#x3D; ++deep; low[v] &#x3D; deep; &#x2F;&#x2F;(1)初始化dfn数组，同时将low设置为相同值 vis[v] &#x3D; 1; stack[++top] &#x3D; v;&#x2F;&#x2F;(2)入栈，作为栈顶元素，同时更新vis数组 for (unsigned i &#x3D; 0; i &lt; g[v].size(); i++) &#123; &#x2F;&#x2F;(3)遍历所有可能到达的点 ll id &#x3D; g[v][i]; if (!dfn[id]) &#123;&#x2F;&#x2F;如果这个点从没访问过，则先访问它更新low[v]的值 tanjan(id); low[v] &#x3D; min(low[v], low[id]); &#x2F;&#x2F;他的儿子如果能连到更小的祖先节点，显然他也可以 &#125; else &#123; if (vis[id]) &#123; &#x2F;&#x2F;不在栈中的点，要么没有访问，要么不能到达id，所以只需要判断栈中的 low[v] &#x3D; min(low[v], low[id]); &#125; &#125; &#125; if (low[v] &#x3D;&#x3D; dfn[v]) &#123; &#x2F;&#x2F;(4)自己和子节点形成了强连通分量，或者只有自己孤身一人 color[v] &#x3D; ++sum; vis[v] &#x3D; 0; while (stack[top] !&#x3D; v) &#123; &#x2F;&#x2F;将从v开始所有的点取出 color[stack[top]] &#x3D; sum;&#x2F;&#x2F;给予同一颜色 vis[stack[top--]] &#x3D; 0;&#x2F;&#x2F;出栈要顺便修改vis &#125; top--; &#125; &#125; Tarjan缩点 仍使用了求强连通分量的方法，适用于具有传递性的题面，如路径权值之类。 原理：一个强连通分量中的每两个点都是强连通的，可以将一个强连通分量缩小成一个点，点权如何计算根据题意而定。 部分代码 vector&lt;int&gt; g[MAX]; int color[MAX], vis[MAX], stack[MAX], dfn[MAX], low[MAX], cnt[MAX], num[MAX]; int ind[MAX], outd[MAX];&#x2F;&#x2F;每个点的出度入度 &#x2F;&#x2F;deep:节点编号 top：栈顶 sum：强连通分量数目 int deep, top, sum, res &#x3D; 0; void tanjan(int v) &#123; dfn[v] &#x3D; ++deep; low[v] &#x3D; deep; &#x2F;&#x2F;(1)初始化dfn数组，同时将low设置为相同值 vis[v] &#x3D; 1; stack[++top] &#x3D; v;&#x2F;&#x2F;(2)入栈，作为栈顶元素，同时更新vis数组 for (unsigned i &#x3D; 0; i &lt; g[v].size(); i++) &#123;&#x2F;&#x2F;(3)遍历所有可能到达的点 int id &#x3D; g[v][i]; if (!dfn[id]) &#123;&#x2F;&#x2F;如果这个点从没访问过，则先放问它，再用它更新low[v]的值 tanjan(id); low[v] &#x3D; min(low[v], low[id]); &#x2F;&#x2F;他的儿子如果能连到更小的祖先节点，显然他也可以 &#125; else &#123; if (vis[id]) &#123;&#x2F;&#x2F;不在栈中的点，要么没有访问，要么不能到达id，所以只需要判断栈中的 low[v] &#x3D; min(low[v], low[id]); &#125; &#125; &#125; if (low[v] &#x3D;&#x3D; dfn[v]) &#123;&#x2F;&#x2F;(4)自己和子节点形成了强连通分量，或者只有自己孤身一人 color[v] &#x3D; ++sum; num[sum]++; &#x2F;&#x2F;num统计该颜色有多少点 vis[v] &#x3D; 0; while (stack[top] !&#x3D; v) &#123;&#x2F;&#x2F;将从v开始所有的点取出 color[stack[top]] &#x3D; sum;&#x2F;&#x2F;给予同一颜色 vis[stack[top--]] &#x3D; 0;&#x2F;&#x2F;出栈要顺便修改vis num[sum]++; &#125; top--; &#125; &#125; int main()&#123; for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123; for (unsigned k &#x3D; 0; k &lt; g[i].size(); k++) &#123; int v &#x3D; g[i][k]; if (color[v] !&#x3D; color[i]) &#123;&#x2F;&#x2F;二者分属于不同的联通集 outd[color[i]] +&#x3D; 1; &#x2F;&#x2F;以颜色作为点，更新相应点的出度 &#125; &#125; &#125; &#125; Tarjan割点、割桥 能力不足，日后再补 欧拉图 定义 在图上用一种走法，能够经过所有的边一次，且每条边只经过一次的路径，即为欧拉路径 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路 通过图中所有边恰好一次且行遍所有顶点的回路(回到起点)称为欧拉回路(所有点的入度等于出度) 具有欧拉回路的无向图或有向图称为欧拉图 具有欧拉通路但不具有欧拉回路的无向图或有向图称为半欧拉图 性质 欧拉图中所有顶点的度数都是偶数 Hierholzer 算法 思想： 判断奇点数，为0则随意指定起点，若为2则其一为起点 从一个起点出发，进行DFS，每次从一个顶点到另一个顶点时，都要删除两顶点之间的边，如果没有可移动的边，则将该顶点加入栈中 输出栈中顶点，该顺序即是从起点出发的欧拉路径 例题 骑马修栅栏 题解 #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; struct edge &#123; int to; bool exists; int revref; bool operator&lt;(const edge &amp;b) const &#123; return to &lt; b.to; &#125; &#125;; vector&lt;edge&gt; beg[505]; int cnt[505]; const int dn &#x3D; 500; stack&lt;int&gt; ans; void Hierholzer(int x) &#123; for (int &amp;i &#x3D; cnt[x]; i &lt; (int)beg[x].size();) &#123; if (beg[x][i].exists) &#123; edge e &#x3D; beg[x][i]; beg[x][i].exists &#x3D; 0; beg[e.to][e.revref].exists &#x3D; 0; ++i; Hierholzer(e.to); &#125; else &#123; ++i; &#125; &#125; ans.push(x); &#125; int deg[505]; int reftop[505]; int main() &#123; for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i) &#123; beg[i].reserve(1050); &#125; int m; scanf(&quot;%d&quot;, &amp;m); for (int i &#x3D; 1; i &lt;&#x3D; m; ++i) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); beg[a].push_back((edge)&#123;b, 1, 0&#125;); beg[b].push_back((edge)&#123;a, 1, 0&#125;); ++deg[a]; ++deg[b]; &#125; for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i) &#123; if (!beg[i].empty()) &#123; sort(beg[i].begin(), beg[i].end()); &#x2F;&#x2F; 为了要按字典序贪心，必须排序 &#125; &#125; for (int i &#x3D; 1; i &lt;&#x3D; dn; ++i) &#123; for (int j &#x3D; 0; j &lt; (int)beg[i].size(); ++j) &#123; beg[i][j].revref &#x3D; reftop[beg[i][j].to]++; &#125; &#125; int bv &#x3D; 0; for (int i &#x3D; 1; i &lt;&#x3D; dn; ++;i) &#123; if (!deg[bv] &amp;&amp; deg[i]) &#123; bv &#x3D; i; &#125; else if (!(deg[bv] &amp; 1) &amp;&amp; (deg[i] &amp; 1)) &#123; bv &#x3D; i; &#125; &#125; Hierholzer(bv); while (!ans.empty()) &#123; printf(&quot;%d\\n&quot;, ans.top()); ans.pop(); &#125; return 0; &#125; 题解2 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; int map[10001][10001];&#x2F;&#x2F;记录两个点之间的路径个数 int du[10001];&#x2F;&#x2F;辅助记录奇点 int lu[10001];&#x2F;&#x2F;记录路径 int n,x,y,js&#x3D;0; int maxn&#x3D;0; void find(int i)&#x2F;&#x2F; &#123; int j; for(j&#x3D;1;j&lt;&#x3D;maxn;++j)&#x2F;&#x2F;而且这里不是n而是maxn因为n不是点的个数而是下面有多少行 &#123; if(map[i][j]&gt;&#x3D;1) &#123; map[i][j]--;&#x2F;&#x2F;删去边一次吗避免重复 map[j][i]--;&#x2F;&#x2F;z这里和一笔画不一样这里是累减而一笔画直接变成0 find(j); &#125; &#125; lu[++js]&#x3D;i; &#125; int main() &#123; scanf(&quot;%d&quot;,&amp;n); for(int i&#x3D;1;i&lt;&#x3D;n;++i) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); map[x][y]++; map[y][x]++; du[x]++; du[y]++;&#x2F;&#x2F;记录出现的次数 maxn&#x3D;max(maxn,max(x,y)); &#125; int start&#x3D;1;&#x2F;&#x2F;默认奇点是1 for(int i&#x3D;1;i&lt;&#x3D;maxn;++i) &#123; if(du[i]%2)&#x2F;&#x2F;找到奇点 &#123; start&#x3D;i;&#x2F;&#x2F;记录奇点 break;&#x2F;&#x2F;然后结束循环 &#125; &#125; find(start);&#x2F;&#x2F;从奇点开始找 for(int i&#x3D;js;i&gt;&#x3D;1;i--) &#123; printf(&quot;%d\\n&quot;,lu[i]);&#x2F;&#x2F;挨个输出路径并且换行 &#125; return 0; &#125; 注意，不能在递归的同时进行输出，输出的路径是错误的 void dfs(int x)&#x2F;&#x2F;错误输出 &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(a[i][x]) &#123; printf(&quot;%d\\n&quot;,x); a[i][x]--;a[x][i]--; dfs(i); &#125; &#125; int main() &#123; &#x2F;&#x2F;…… printf(&quot;%d&quot;,&amp;s);&#x2F;&#x2F;s是起点 dfs(s); &#125; void dfs(int x)&#x2F;&#x2F;正确输出 &#123; for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(a[i][x]) &#123; a[i][x]--;a[x][i]--; dfs(i); &#125; p[size++]&#x3D;x; &#125; int main() &#123; &#x2F;&#x2F;…… dfs(s); for(int i&#x3D;size-1;i&gt;&#x3D;0;i--)printf(&quot;%d\\n&quot;,p[i]); return 0; &#125; 二分图 定义：节点由两个集合组成，且两个集合内部没有边的图。 性质 如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。 二分图不存在长度为奇数的环 二分图判定 AcWing-860染色法判定二分图 &#x2F;&#x2F;dfs染色法 #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int N &#x3D; 1e5 + 10, M &#x3D; 2e5 + 10; int n, m; int h[N], e[M], ne[M], idx; &#x2F;&#x2F;邻接表的存储 int color[N]; void add(int a, int b) &#123; e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++; &#125; bool dfs(int u, int c) &#123; color[u] &#x3D; c; &#x2F;&#x2F;当前这个点u的颜色是 c for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i]) &#123; int j &#x3D; e[i]; if (!color[j]) &#x2F;&#x2F;u 的邻接点 j 未被染色 &#123; dfs(j, 3 - c); &#x2F;&#x2F; u的颜色如果是1，j就是3-1&#x3D;2；u的颜色如果是2，j就是3-2&#x3D;1 &#125; else if (color[j] &#x3D;&#x3D; c) return false; &#x2F;&#x2F;两邻接点染相同颜色 &#125; return true; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof(h)); while (m--) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); &#x2F;&#x2F; 无向图建两条相反方向的边 &#125; bool flag &#x3D; true; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;遍历图的所有点 if (!color[i]) &#123; if (!dfs(i, 1)) &#123; flag &#x3D; false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot;; else cout &lt;&lt; &quot;No&quot;; &#125; &#x2F;&#x2F;bfs染色法 &#x2F;&#x2F;不建议使用 &#x2F;&#x2F;太玄幻了根本看不懂还是把代码粘贴进来吧 #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; typedef pair&lt;int, int&gt; PII; &#x2F;&#x2F;first存点编号，second存颜色 const int N &#x3D; 1e5 + 10, M &#x3D; 2e5 + 10; int n, m; int h[N], e[M], ne[M], idx; &#x2F;&#x2F;邻接表的存储 int color[N]; void add(int a, int b) &#123; e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++; &#125; bool bfs(int u) &#123; queue&lt;PII&gt; q; q.push(&#123;u, 1&#125;); color[u] &#x3D; 1; &#x2F;&#x2F;当前这个点u的颜色是 c while (q.size()) &#x2F;&#x2F;队列不空 &#123; PII t &#x3D; q.front(); q.pop(); int ver &#x3D; t.first, c &#x3D; t.second; for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i]) &#123; int j &#x3D; e[i]; if (!color[j]) &#x2F;&#x2F;未被染色 &#123; color[j] &#x3D; 3 - c; q.push(&#123;j, 3 - c&#125;); &#125; else if (color[j] &#x3D;&#x3D; c) return false; &#x2F;&#x2F;两邻接点染相同颜色 &#125; &#125; return true; &#125; int main() &#123; cin &gt;&gt; n &gt;&gt; m; memset(h, -1, sizeof(h)); while (m--) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); add(a, b), add(b, a); &#x2F;&#x2F; 无向图建两条相反方向的边 &#125; bool flag &#x3D; true; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;遍历图的所有点 if (!color[i]) &#123; if (!bfs(i)) &#123; flag &#x3D; false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;Yes&quot;; else cout &lt;&lt; &quot;No&quot;; &#125; 增广路算法 匹配：一个边集中的任意两条边都不依附于同一个顶点，则称这个边集是一个匹配。 最大匹配：在匹配的基础上让边最大。 通俗理解可以看成左边一个集合是所有男孩，右边一个集合是所有女孩，我们需要求最多可以凑成几对情侣。 增广路：增广路径是指，由一个未匹配的顶点开始，经过若干个匹配顶点，最后到达对面集合的一个未匹配顶点的路径，即这条路径将两个不同集合的两个未匹配顶点通过一系列匹配顶点相连。 增广路算法例题 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; const int maxn &#x3D; 600 + 5; bool line[maxn][maxn]; &#x2F;&#x2F;line[x][y]&#x3D;true表示x号女生喜欢y男生(边） int boy[maxn]; &#x2F;&#x2F;存储y号男生匹配边另一端的匹配点女生，如果是未覆盖点则为0 bool falg[maxn]; &#x2F;&#x2F;存储y号男生是否在这条交替路上被使用过,男生是否被别人喜欢 int k, n, m; bool dfs(int x) &#123; for (int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123; if (line[x][j] &amp;&amp; !falg[j]) &#123; falg[j] &#x3D; true; if (!boy[j] || dfs(boy[j])) &#123; &#x2F;&#x2F;满足上面的判断语句说明找到了增广路 &#x2F;&#x2F;即终点是未覆盖点的交替路 boy[j] &#x3D; x; return true; &#125; &#125; &#x2F;&#x2F;该条路不是增广路 &#125; return false; &#125; int main() &#123; while (cin &gt;&gt; k) &#123; if (!k) break; cin &gt;&gt; n &gt;&gt; m; int x, y; int ans &#x3D; 0; memset(line, false, sizeof(line));&#x2F;&#x2F;初始化 memset(boy, 0, sizeof(boy)); while (k--) &#123; cin &gt;&gt; x &gt;&gt; y; line[x][y] &#x3D; true; &#125; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; memset(falg, false, sizeof(falg));&#x2F;&#x2F;每次循环都要初始化flag if (dfs(i)) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0; &#125; C++高精度 高精度四则运算 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; struct bign &#x2F;&#x2F;大整数数组 &#123; int len; &#x2F;&#x2F;位数 int num[1000]; &#125;; &#x2F;&#x2F;大整数转换 bign change(char a[]) &#123; bign c; c.len &#x3D; strlen(a); for (int i &#x3D; 0; i &lt; c.len; i++) &#123; c.num[i] &#x3D; a[c.len - i - 1] - &#39;0&#39;; &#125; return c; &#125; &#x2F;&#x2F;大整数比较 int compare(bign a, bign b) &#123; &#x2F;&#x2F;大于返回1，小于返回-1，相等返回0 if (a.len &gt; b.len) &#x2F;&#x2F;位数多的数比位数少的数大 return 1; if (a.len &lt; b.len) return -1; for (int i &#x3D; a.len - 1; i &gt;&#x3D; 0; i--) &#123; &#x2F;&#x2F;位数相同，高位到低位逐位比较 if (a.num[i] &gt; b.num[i]) return 1; else if (a.num[i] &lt; b.num[i]) return -1; &#125; return 0; &#x2F;&#x2F;执行到最后肯定相等 &#125; bign add_bign(bign a, bign b) &#123; bign c; for (int i &#x3D; 0; i &lt; a.len || i &lt; b.len; i++) &#123; &#x2F;&#x2F;以位数长的结束条件 c.num[c.len] +&#x3D; a.num[i] + b.num[i]; &#x2F;&#x2F;对应位置相加再加上进位 if (c.num[c.len] &gt;&#x3D; 10) &#123; &#x2F;&#x2F;大于等于10需要进位 c.num[c.len + 1]++; &#x2F;&#x2F;进位加到前一位上 c.num[c.len] -&#x3D; 10; &#x2F;&#x2F;更新原位置的值 &#125; c.len++; &#125; if (c.num[c.len]) &#x2F;&#x2F;最高位不为零长度加一 c.len++; return c; &#125; bign sub_bign(bign a, bign b) &#123; bign c; for (int i &#x3D; 0; i &lt; a.len || i &lt; b.len; i++) &#123; &#x2F;&#x2F;以位数长的结束条件 if (a.num[i] &lt; b.num[i]) &#123; &#x2F;&#x2F;如果同位的被减数比减数小需要借位 a.num[i] +&#x3D; 10; a.num[i + 1]--; &#125; c.num[c.len++] &#x3D; a.num[i] - b.num[i]; &#125; while (c.len &gt; 1 &amp;&amp; !c.num[c.len - 1]) &#x2F;&#x2F;消除前缀零 c.len--; return c; &#125; bign mutli_bign(bign a, bign b) &#123; bign c; for (int i &#x3D; 0; i &lt; a.len; i++) &#x2F;&#x2F;大数a逐位乘大数b for (int j &#x3D; 0; j &lt; b.len; j++) &#123; c.num[i + j] +&#x3D; a.num[i] * b.num[j]; &#x2F;&#x2F;a的第i位乘b的第j位加上进位 if (c.num[i + j] &gt;&#x3D; 10) &#123; &#x2F;&#x2F;大于等于十进位 c.num[i + j + 1] +&#x3D; c.num[i + j] &#x2F; 10; c.num[i + j] %&#x3D; 10; &#125; &#125; c.len &#x3D; a.len + b.len; &#x2F;&#x2F;两个数乘积的位数不超过两个数位数之和 while (c.len &gt; 1 &amp;&amp; c.num[c.len - 1] &#x3D;&#x3D; 0) &#x2F;&#x2F;取出前导零 c.len--; return c; &#125; bign div_bign(bign a, bign b) &#123; bign c; c.len &#x3D; a.len - b.len + 1; &#x2F;&#x2F;求商的位置 for (int i &#x3D; c.len - 1; i &gt;&#x3D; 0; i--) &#123; bign temp; for (int j &#x3D; 0; j &lt; b.len; j++) &#x2F;&#x2F;b补零存在临时数组 temp.num[j + i] &#x3D; b.num[j]; temp.len &#x3D; b.len + i; while (compare(a, temp) &gt;&#x3D; 0) &#123; &#x2F;&#x2F;a的高b.len位比temp小重新补零 c.num[i]++; &#x2F;&#x2F;累计减的次数 sub_bign(a, temp); &#x2F;&#x2F;大整数减法 &#125; &#125; while (c.len &gt; 1 &amp;&amp; !c.num[c.len - 1]) &#x2F;&#x2F;消去前导零 c.len--; return c; &#125; char a[1000], b[1000]; int main() &#123; &#x2F;*cin &gt;&gt; a &gt;&gt; b; bign a1 &#x3D; change(a); bign b1 &#x3D; change(b); bign c &#x3D; add_bign(a1, b1); for (int i &#x3D; c.len - 1; i &gt;&#x3D; 0; --i) cout &lt;&lt; c.num[i];*&#x2F; return 0; &#125; JAVA高精度 高精度加法 &#x2F;&#x2F;package com.company;交题的时候不需要这一行 import java.math.BigInteger; import java.util.Scanner; public class Main&#123; public static void main(String[] args)&#123; Scanner in&#x3D;new Scanner(System.in); BigInteger a&#x3D;in.nextBigInteger(); BigInteger b&#x3D;in.nextBigInteger(); System.out.println(a.add(b)); &#125;&#x2F;&#x2F;减法换成subtract，乘法换成multiply，除法换成divide &#125; 求大整数的阶乘 &#x2F;&#x2F;package com.company; import java.math.BigInteger; import java.util.Scanner; public class Mai n&#123; public static void main(String[] args)&#123; &#x2F;&#x2F; write your code here Scanner in&#x3D;new Scanner(System.in); BigInteger ans&#x3D;BigInteger.ONE; int n&#x3D;in.nextInt(); for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; ans&#x3D;ans.multiply(BigInteger.valueOf(i)); &#125; System.out.println(ans); &#125; &#125; 高精度整数BigInteger String temp1 &#x3D; &quot;-1000000000000000000000000000000000000&quot;; BigInteger bg1 &#x3D; new BigInteger(temp1); &#x2F;&#x2F;注意初始化的方式,使用字符串来初始化 System.out.println(bg1.abs()); &#x2F;&#x2F;绝对值方法 object.abs() String temp2 &#x3D; &quot;100000000000000000000000000&quot;; BigInteger bg2 &#x3D; new BigInteger(temp2); System.out.println(bg1.add(bg2)); &#x2F;&#x2F;加法 object.add(BigInteger b) System.out.println(bg1.subtract(bg2)); &#x2F;&#x2F;减法 返回为 bg1 - bg2 (this - param) System.out.println(bg1.multiply(bg2)); &#x2F;&#x2F;乘法 返回 bg1 * bg2 System.out.println(bg1.divide(bg2)); &#x2F;&#x2F;除法 返回bg1 &#x2F; bg2 System.out.println(bg1.mod(bg2)); &#x2F;&#x2F;取模运算 返回的是 bg1%bg2 (this mod param) System.out.println(bg1.gcd(bg2)); &#x2F;&#x2F;直接封装好了 求解bg1,bg2 的最大公约数 int temp5 &#x3D; 5; System.out.println(bg2.pow(temp5)); &#x2F;&#x2F;乘方运算 注意这个方法的参数是基本类型int System.out.println(bg2.compareTo(bg1)); &#x2F;&#x2F; 比较方法 结果为1 bg2大 System.out.println(bg1.compareTo(bg2)); &#x2F;&#x2F; 结果为-1 bg2大 &#x2F;&#x2F;这个地方注意比较的方法，还有一个方法是equal() String temp3 &#x3D; &quot;1000&quot;; String temp4 &#x3D; &quot;001000&quot;; BigInteger bg3 &#x3D; new BigInteger(temp3); BigInteger bg4 &#x3D; new BigInteger(temp4); System.out.println(bg3.compareTo(bg4)); &#x2F;&#x2F;结果为0 表示相等 System.out.println(bg3.equals(bg4)); &#x2F;&#x2F;返回结果为true 这样看是没有区别，但是更推荐比较的时候使用compareTo()方法， &#x2F;&#x2F;在BigDecimal更直观，例如0.1 与0.10 ，equal返回false 而compareTo则是正确的结果。 高精度浮点数 String temp1 &#x3D; &quot;1.2222222222222222222222222&quot;; BigDecimal bd1 &#x3D; new BigDecimal(temp1); String temp2 &#x3D; &quot;2.333333333333333333333333&quot;; BigDecimal bd2 &#x3D; new BigDecimal(temp2); System.out.println(bd1.add(bd2)); &#x2F;&#x2F; 加法 输出 3.5555555555555555555555552 System.out.println(bd1.add(bd2).doubleValue()); &#x2F;&#x2F; 输出 3.5555555555555554 这里用了一个方法将结果转化为double类型了 System.out.println(bd2.subtract(bd1)); &#x2F;&#x2F;减法 输出 1.1111111111111111111111108 System.out.println(bd2.subtract(bd1).doubleValue()); &#x2F;&#x2F;输出 1.1111111111111112 System.out.println(bd2.multiply(bd1)); &#x2F;&#x2F;乘法 输出 2.8518518518518518518518513925925925925925925925926 System.out.println(bd2.multiply(bd1).doubleValue()); &#x2F;&#x2F;乘法 2.8518518518518516 System.out.println(bd2.divide(bd1, 5, RoundingMode.HALF_UP)); &#x2F;&#x2F;除法应该注意很有可能会有除不尽的情况，这时候会有异常抛出，所以要传入控制参数 System.out.println(bd2.divide(bd1, 5, RoundingMode.HALF_UP).doubleValue()); &#x2F;&#x2F;输出都是 1.90909 System.out.println(bd1.compareTo(bd2)); &#x2F;&#x2F;比较方法 BigDecimal bd3 &#x3D; new BigDecimal(&quot;1.20&quot;); BigDecimal bd4 &#x3D; new BigDecimal(&quot;1.2&quot;); System.out.println(bd3.compareTo(bd4)); &#x2F;&#x2F;返回0表示相等 System.out.println(bd3.equals(bd4)); &#x2F;&#x2F;返回的是false 是错误的 &#x2F;&#x2F;所以比较的时候使用compareTo()方法 素数筛法 六倍原理 除了2和3以外，其余素数都与6的倍数相邻，满足6x+1和6x-1。也就是说大于3的质数一定和6相邻 埃氏筛法 原理：要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。 模板代码 #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;stdio.h&gt; using namespace std; bool is_prime[1000]; int main() &#123; int n; cin &gt;&gt; n; for (int i &#x3D; 0; i &lt;&#x3D; n; i++) is_prime[i] &#x3D; true; &#x2F;&#x2F;初始化所有的数为素数 for (int i &#x3D; 2; i &lt;&#x3D; sqrt(n); i++) &#123; &#x2F;&#x2F;从第一个素数2开始筛选 if (is_prime[i]) &#123; &#x2F;&#x2F;如果是素数 for (int j &#x3D; i * i; j &lt;&#x3D; n; j +&#x3D; i) &#123; &#x2F;&#x2F;则剔除掉它的倍数 is_prime[j] &#x3D; false; &#125; &#125; &#125; for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; if (is_prime[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return 0; &#125; 欧拉筛法（线性筛） 基本思想：埃氏筛法要重复标记很多次相同的数，在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 模板代码 &#x2F;&#x2F;题目 &#x2F;&#x2F;求小于等于n的素数的个数，并输出每个素数 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; int main() &#123; int n, cnt &#x3D; 0; int prime[100001]; &#x2F;&#x2F;存素数 bool vis[100001]; &#x2F;&#x2F;保证不做素数的倍数 cin &gt;&gt; n; memset(vis, false, sizeof(vis)); &#x2F;&#x2F;初始化 memset(prime, 0, sizeof(prime)); for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123; if (!vis[i]) &#x2F;&#x2F;不是目前找到的素数的倍数 prime[cnt++] &#x3D; i; &#x2F;&#x2F;找到素数 for (int j &#x3D; 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;&#x3D; n; j++) &#123; vis[i * prime[j]] &#x3D; true; &#x2F;&#x2F;找到的素数的倍数不访问 if (i % prime[j] &#x3D;&#x3D; 0) break; &#x2F;&#x2F;关键！！！！ &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#x2F;&#x2F;总数 for (int i &#x3D; 0; i &lt; cnt; i++) cout &lt;&lt; prime[i] &lt;&lt; endl; &#x2F;&#x2F;输出每个素数 return 0; &#125; 最长上升子序列-LIS 定义：在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。 朴素算法 dp[i] = max(dp[i], dp[j] + 1) (1 &lt;= j &lt; i, a[j] &lt; a[i]) 模板代码 #include&lt;bits&#x2F;stdc++.h&gt; using namespace std; int a[100]; int dp[100]; int main() &#123; int n; fill(dp, dp + sizeof(dp), 1); cin &gt;&gt; n; for (int i &#x3D; 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;两个for循环遍历整个数组并求dp for (int j &#x3D; 0; j &lt; i; j++) &#123; if (a[i] &gt; a[j])&#x2F;&#x2F;满足次条件才能形成升序列 dp[i] &#x3D; max(dp[i], dp[j] + 1); &#125; for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; dp[i] &lt;&lt; &#39; &#39;; return 0; &#125; 二分+贪心优化 #include&lt;iostream&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int maxn &#x3D; 1e5 + 10; int num[maxn]; const int INF &#x3D; 0x3f3f3f3f; int slow[maxn], d[maxn]; int main() &#123; fill(slow, slow + maxn, INF);&#x2F;&#x2F;fill函数初始化 int n; cin &gt;&gt; n; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; num[i]; int len &#x3D; -1; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int j &#x3D; lower_bound(slow + 1, slow + maxn + 1, num[i]) - slow;&#x2F;&#x2F;二分查找 d[i] &#x3D; j; if (len &lt; d[i]) len &#x3D; d[i]; slow[j] &#x3D; num[i]; &#125; cout &lt;&lt; len &lt;&lt; endl;&#x2F;&#x2F;输出最长上升子序列的长度 return 0; &#125; 最长公共子序列-LCS 定义：一个序列S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。 模板代码 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; #define IOS std::ios::sync_with_stdio(false) const int N &#x3D; 1010; int n, m; char a[N], b[N]; int dp[N][N]; int main() &#123; memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m; for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) cin &gt;&gt; a[i];&#x2F;&#x2F;A字符串 for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) cin &gt;&gt; b[j];&#x2F;&#x2F;B字符串 for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) for (int j &#x3D; 1; j &lt;&#x3D; m; ++j) if (a[i] &#x3D;&#x3D; b[j]) dp[i][j] &#x3D; dp[i - 1][j - 1] + 1; &#x2F;&#x2F;左上角的值+1 else dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);&#x2F;&#x2F;左边或上边取最大 cout &lt;&lt; dp[n][m] &lt;&lt; endl;&#x2F;&#x2F;最长公共序列 &#x2F;&#x2F;以下是输出该序列 int i &#x3D; n, j &#x3D; m, index &#x3D; 0; char lcs[1005]; while (i !&#x3D; 0 &amp;&amp; j !&#x3D; 0) &#123; if (dp[i][j] &#x3D;&#x3D; dp[i][j - 1])&#x2F;&#x2F;反向回退 j--; else if (dp[i][j] &#x3D;&#x3D; dp[i - 1][j]) i--; else &#123; lcs[index++] &#x3D; a[i]; i--, j--; &#125; &#125; for (int i &#x3D; index - 1; i &gt;&#x3D; 0; --i)&#x2F;&#x2F;最后一步会index会多加一个1所以要在这里减掉 cout &lt;&lt; lcs[i]; return 0; &#125; LCS表格 推一遍就懂了 此处图片丢失 背包 01背包 题目 有N件物品和一个容量为V的背包。第i件物品的费用是w [ i ] ，价值**是v [ i ] **，求将哪些物品装入背包可使价值总和最大。 状态转移方程 核心代码 memset(dp, 0, sizeof(dp)); for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; for (int j &#x3D; 0; j &lt;&#x3D; m; j++) &#123; if (j &gt;&#x3D; w[i]) &#x2F;&#x2F;如果背包装得下当前的物体 &#123; dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#125; else &#x2F;&#x2F;如果背包装不下当前物体 &#123; dp[i][j] &#x3D; dp[i - 1][j]; &#125; &#125; &#125; 例题 优化空间复杂度的01背包 用dp[j]表示当前总重量为j的所有方案中的最大价值 核心代码 for (int i &#x3D; 1; i &lt;&#x3D; n; i++) for (int j &#x3D; m; j &gt;&#x3D; w[i]; j--)&#x2F;&#x2F;反向线性更新 dp[j] &#x3D; max(dp[j], dp[j - w[i]] + v[i]); 完全背包 题目 有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w [ i ] ，价值是v [ i ]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大 可以将完全背包简化成01背包。 状态转移方程 此处图片丢失 优化后 此处图片丢失 还可以根据1背包的优化原则对,完全背包进行优化。 优化代码 #include &lt;iostream&gt; using namespace std; int N, V; int v[1010], val[1010]; int dp[1010]; int main() &#123; cin &gt;&gt; N &gt;&gt; V; for (int i &#x3D; 1; i &lt;&#x3D; N; i++) cin &gt;&gt; v[i] &gt;&gt; val[i]; for (int i &#x3D; 1; i &lt;&#x3D; N; i++) for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123; dp[j] &#x3D; dp[j]; &#x2F;&#x2F;此时右边的dp[j]是上一层i-1的dp[j],然后赋值给了当前i的dp[i] if (j &gt;&#x3D; v[i]) &#123; dp[j] &#x3D; max(dp[j], dp[j - v[i]] + val[i]); &#x2F;&#x2F;dp[j-v[i]],已经被算过 &#125; &#125; cout &lt;&lt; dp[V] &lt;&lt; endl; &#x2F;&#x2F;输出最大体积,即最优解 return 0; &#125; 例题1 多重背包 多重背包也是 01 背包的一个变式。与 01 背包的区别在于每种物品有k个，而非一个。 题目 有N种物品和一个容量为V的背包。第i种物品最多有p[i]件可用，每件费用是w[i] 价值是v[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 状态转移方程 此处图片丢失 还是可以转化为01背包问题，但是要用到二进制拆分 此处图片丢失 二进制拆分代码 for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123; int num &#x3D; min(p[i], V &#x2F; w[i]); for (int k &#x3D; 1; num &gt; 0; k &lt;&lt;&#x3D; 1) &#123; if (k &gt; num) k &#x3D; num; num -&#x3D; k; for (int j &#x3D; V; j &gt;&#x3D; w[i] * k; j--) dp[j] &#x3D; max(dp[j], dp[j - w[i] * k] + v[i] * k); &#125; &#125; 例题 例题2 博弈基础 巴什博奕 规则：有一堆n个石子，两个足够聪明的人玩，每个人可以去1～m个石子，取到最后一个石子为胜。 结论：当n%(m+1)==0，先手必输，否则先手必胜。 代码 #include &lt;iostream&gt; using namespace std; int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; if (n % (m + 1)) cout &lt;&lt; &quot;先手胜&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;后手胜&quot; &lt;&lt; endl; return 0; &#125; 例题 威佐夫博弈 规则：有两堆各若干的物品，两人轮流从其中一堆取至少一件物品，至多不限，或从两堆中同时取相同件物品，规定最后取完者胜利。 结论：若两堆物品的初始值为（x，y），且x&lt;y，则另z=y-x； 记w=（int）[（（sqrt（5）+1）/2）*z ]； 若w=x，则先手必败，否则先手必胜。 代码 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; int n1, n2, temp; while (cin &gt;&gt; n1 &gt;&gt; n2) &#123; if (n1 &gt; n2) swap(n1, n2); temp &#x3D; floor((n2 - n1) * (1 + sqrt(5.0)) &#x2F; 2.0); if (temp &#x3D;&#x3D; n1) cout &lt;&lt; &quot;后手必胜&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;先手必胜&quot; &lt;&lt; endl; &#125; return 0; &#125; 斐波那契博弈 规则：有一堆物品，两人轮流取物品，先手最少取一个，至多无上限，但不能把物品取完，之后每次取的物品数不能超过上一次取的物品数的二倍且至少为一件，取走最后一件物品的人获胜。 结论：先手胜当且仅当n不是斐波那契数（n为物品总数） 代码 #include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; using namespace std; const int N &#x3D; 55; int f[N]; void Init() &#123; f[0] &#x3D; f[1] &#x3D; 1; for (int i &#x3D; 2; i &lt; N; i++) f[i] &#x3D; f[i - 1] + f[i - 2]; &#125; int main() &#123; Init(); int n; while (cin &gt;&gt; n) &#123; if (n &#x3D;&#x3D; 0) break; bool flag &#x3D; 0; for (int i &#x3D; 0; i &lt; N; i++) &#123; if (f[i] &#x3D;&#x3D; n) &#123; flag &#x3D; 1; break; &#125; &#125; if (flag) puts(&quot;Second win&quot;); else puts(&quot;First win&quot;); &#125; return 0; &#125; 例题 尼姆博弈 规则：任意堆物品，每堆物品的个数是任意的，双方轮流从中取物品，每一次只能从一堆物品中取部分或全部物品，最少取一件，取到最后一件物品的人获胜。 结论：把每堆物品数全部异或起来，如果得到的值为0，那么先手必败，否则先手必胜。 代码 #include &lt;cmath&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int main() &#123; int n, ans, temp; while (cin &gt;&gt; n) &#123; temp &#x3D; 0; for (int i &#x3D; 0; i &lt; n; i++) &#123; cin &gt;&gt; ans; temp ^&#x3D; ans;&#x2F;&#x2F;异或 &#125; if (temp &#x3D;&#x3D; 0) cout &lt;&lt; &quot;后手必胜&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;先手必胜&quot; &lt;&lt; endl; &#125; return 0; &#125; 隔板法 定义：隔板法就是在n个元素间的（n-1）个空中插入k个板，可以把n个元素分成k+1组的方法。 条件： 这n个元素必须互不相异 所分成的每一组至少分得1个元素 分成的组别彼此相异 普通隔板法 例1. 求方程 x+y+z=10的正整数解的个数。 分析：将10个球排成一排，球与球之间形成9个空隙，将两个隔板插入这些空隙中（每空至多插一块隔板），规定由隔板分成的左、中、右三部分的球数分别为x、y、z之值）。则隔法与解的个数之间建立了一一对立关系，故解的个数为C(n-1,m-1)=C（9，2）=36（个）。 ​ 添元素隔板法 例2. 求方程 x+y+z=10的非负整数解的个数。 分析：注意到x、y、z可以为零，故例1解法中的限定“每空至多插一块隔板”就不成立了，怎么办呢？只要添加三个球，给x、y、z各添加一个球，这样原问题就转化为求 x+y+z=13的正整数解的个数了，则问题就等价于把13个相同小球放入3个不同箱子，每个箱子至少一个，有几种情况？易得解的个数为C（n+m-1,m-1）=C（12，2）=66（个）。 例3： 把10个相同小球放入3个不同箱子，第一个箱子至少1个，第二个箱子至少3个，第三个箱子可以放空球，有几种情况？ 我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8个小球之外的1个小球，则问题转化为 把9个相同小球放3不同箱子，每箱至少1个，几种方法？ C(8,2）=28 例4. 将20个相同的小球放入编号分别为1，2，3，4的四个盒子中，要求每个盒子中的球数不少于它的编号数，求放法总数。（减少球数用隔板法） 分析：先在编号1，2，3，4的四个盒子内分别放0，1，2，3个球，剩下14个球，有1种方法；再把剩下的球分成4组，每组至少1个，由例1知方法有C（13，3）=286（种）。 例5：有一类自然数，从第三个数字开始，每个数字都恰好是它前面两个数字之和，直至不能再写为止，如257，1459等等，这类数共有几个？ 因为前2位数字唯一对应了符合要求的一个数，只要求出前2位有几种情况即可，设前两位为ab 显然a+b&lt;=9 ,且a不为0 1 -1- 1 -1 -1 -1 -1 -1 -1 1代表9个1，-代表8个空位 我们要把9个1分成两组，但b可以为0，我们先给b一个1，然后就相当于10个小球放入两个（a，b）不同的箱子，每一个箱子至少放一个，C（9，1），但这是错误的，为什么？因为1不一定要全部放入。其实解决这个问题可以这么想，我们在引进一个盒子c来放ab取完剩下的1，所以报证c中球数大于0，所以要在增加一个球，题目就等价于，11个小球放入两个（a，b）不同的箱子，每一个箱子至少放一个，所以一共有 c（10，2）=45 添板插板法 例5另一种解法： 显然a+b&lt;=9 ,且a不为0 1 -1- 1 -1 -1 -1 -1 -1 -1 - - 1代表9个1，-代表10个空位 （第一个没有因为a不能为0），我们可以在这9个空位中插入2个板，分成3组，第一组取到a个1，第二组取到b个1，但此时第二组始终不能取空，若多添加第10个空时，设取到该板时第二组取空，即b=0，所以一共有 c（10，2）=45 添板插板法就是添元素隔板法的变形。 **选板法 ** 例6： 有10粒糖，如果每天至少吃一粒(多不限)，吃完为止，求有多少种不同吃法？ o - o - o - o - o - o - o - o - o – o o代表10个糖，-代表9块板 10块糖，9个空，插入9块板，每个板都可以选择放或是不放，相邻两个板间的糖一天吃掉 这样一共就是 2^9= 512 **分类插板 ** 例7： 小梅有15块糖，如果每天至少吃3块，吃完为止，那么共有多少种不同的吃法？ 此问题不能用插板法的原因在于没有规定一定要吃几天，因此我们需要对吃的天数进行分类讨论 最多吃5天，最少吃1天 1： 吃1天或是5天，各一种吃法 一共2种情况 2：吃2天，每天预先吃2块，即问11块糖，每天至少吃1块，吃2天，几种情况？ C（10， 1）=10 3：吃3天，每天预先吃2块，即问9块糖，每天至少1块，吃3天? C（8 ，2）=28 4：吃4天，每天预先吃2块，即问7块糖，每天至少1块，吃4天？c（6 ，3）=20 所以一共是 2+10+28+20=60 种 **逐步插板法 ** 例8 ：在一张节目单中原有6个节目，若保持这些节目相对次序不变，再添加3个节目，共有几种情况？ -o - o - o - o - o - o - 三个节目abc 可以用一个节目去插7个空位，再用第二个节目去插8个空位，用最后个节目去插9个空位 所以一共是 c（7, 1）×c(8, 1)×c(9 ,1)=504种 快速幂算法 快速幂 作用：解决乘法溢出问题，如2^100 % 10086 要用到模运算规律：(a * b) % p = (a % p * b % p) % p 朴素版 int ans&#x3D;1; for (int i&#x3D;1; i&lt;&#x3D;b; ++i) &#123; ans *&#x3D; a % p; &#125; return ans % p; 但是朴素版时间复杂度过高为O(N) 优化版 int pow(int a, int b, int p) &#123; int ans &#x3D; 1; while (b) &#123; if (b &amp; 1) ans &#x3D; ans * a % p; &#x2F;&#x2F;若b&amp;1&#x3D;&#x3D;1，就选择当前的迭代值a和res累乘。 a &#x3D; a * a; &#x2F;&#x2F;迭代构造a,a是初始值的2的整数次幂 b &#x3D; b &gt;&gt; 1; &#x2F;&#x2F;将b右移一位 &#125; &#x2F;&#x2F;以上计算得到a^b return ans % p; &#x2F;&#x2F;取模 &#125; 龟速乘 作用：当(a * b) % p中a和b过大时，快速幂也会超出数据范围，可以使用龟速乘防止爆掉 &#x2F;&#x2F;防止在乘法过程中爆ll ll fast_mult(ll a, ll b) &#123; ll res &#x3D; 0; while (b &gt; 0) &#123; if (b &amp; 1) &#123; res &#x3D; (res + a) % n; &#125; b &gt;&gt;&#x3D; 1; a &#x3D; (a + a) % n; &#125; return res % n; &#125; 矩阵快速幂 矩阵乘法 const int N &#x3D; 100; int c[N][N]; void multi(int a[][N], int b[][N], int n) &#x2F;&#x2F;n是矩阵大小，n&lt;N &#123; memset(c, 0, sizeof(c)); for (int i &#x3D; 1; i &lt;&#x3D; n; i++) for (int j &#x3D; 1; j &lt;&#x3D; n; j++) for (int k &#x3D; 1; k &lt;&#x3D; n; k++) c[i][j] +&#x3D; a[i][k] * b[k][j]; &#125; 矩阵快速幂模板 #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int M, n; struct node &#x2F;&#x2F;定义一个矩阵类型的结构体 &#123; int m[100][100]; &#125; ans, res; &#x2F;&#x2F;ans是结果，res是最初的方阵 node mul(node A, node B) &#123; int i, j, k; node temp; &#x2F;&#x2F;定义一个临时矩阵，存放A*B的结果 for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;先全部定义为0 &#123; for (j &#x3D; 0; j &lt; n; j++) &#123; temp.m[i][j] &#x3D; 0; &#125; &#125; for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;矩阵相乘的代码 &#123; for (j &#x3D; 0; j &lt; n; j++) &#123; for (k &#x3D; 0; k &lt; n; k++) &#123; temp.m[i][j] +&#x3D; A.m[i][k] * B.m[k][j]; &#125; &#125; &#125; return temp; &#125; void fastpow(int M, int n) &#123; int i, j; for (i &#x3D; 0; i &lt; n; i++) &#123; for (j &#x3D; 0; j &lt; n; j++) &#123; if (i &#x3D;&#x3D; j) &#123; ans.m[i][j] &#x3D; 1; &#125; else ans.m[i][j] &#x3D; 0; &#125; &#125; &#x2F;&#x2F;这里是思想的转换，之前我们定义为1去计算，所以我们先初始化ans为 &#x2F;&#x2F;单位矩阵，我们知道单位矩阵与任何矩阵的乘积为其本身 while (M) &#x2F;&#x2F;快速幂的步骤 &#123; if (M &amp; 1) &#123; ans &#x3D; mul(ans, res); &#125; res &#x3D; mul(res, res); M &#x3D; M &gt;&gt; 1; &#125; &#125; int main() &#123; cin &gt;&gt; n; &#x2F;&#x2F;方阵的阶数 cin &gt;&gt; M; &#x2F;&#x2F;指数 int i, j; for (i &#x3D; 0; i &lt; n; i++) &#123; for (j &#x3D; 0; j &lt; n; j++) &#123; cin &gt;&gt; res.m[i][j]; &#x2F;&#x2F;初始化方阵res &#125; &#125; fastpow(M, n); &#x2F;&#x2F;进行快速幂 for (i &#x3D; 0; i &lt; n; i++) &#x2F;&#x2F;输出 &#123; for (j &#x3D; 0; j &lt; n; j++) &#123; cout &lt;&lt; ans.m[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; 数论基础 同余式 定义：同余式是 数论 的基本概念之一，设m是给定的一个正整数，a、b是整数，若满足m| (a-b)，则称a与b对模m 同余 ，记为a≡b (mod m)，或记为a≡b (m)。 逆元 每个数a均有唯一的与之对应的乘法逆元x，使得ax≡1(mod n) ， 一个数有逆元的充分必要条件是gcd(a,n)=1，此时逆元唯一存在 。 逆元的含义：模n意义下，1个数a如果有逆元x，那么除以a相当于乘以x。 逆元的定义：定义：正整数 a, n，如果有 ax ≡ 1(mod n)，则称 x 的最小正整数解为 a 模 n的逆元。 扩展欧几里得算法 #include &lt;cstdio&gt; #include &lt;iostream&gt; using namespace std; int exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b &#x3D;&#x3D; 0) &#123; x &#x3D; 1, y &#x3D; 0; return a; &#125; int r &#x3D; exgcd(b, a % b, x, y); int t &#x3D; x; x &#x3D; y; y &#x3D; t - a &#x2F; b * y; return r; &#125; int inv(int n, int m) &#123; int x, y; int ans &#x3D; exgcd(n, m, x, y); if (ans &#x3D;&#x3D; 1) return (x % m + m) % m; &#x2F;&#x2F;定义：正整数 a, n，如果有 ax ≡ 1(mod n)，则称 x 的最小整数解为 a 模 n的逆元。 else return -1; &#125; int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int ans &#x3D; inv(n, m); ans &#x3D;&#x3D; -1 ? cout &lt;&lt; &quot;no&quot; &lt;&lt; endl : cout &lt;&lt; ans &lt;&lt; endl; return 0; &#125; &#x2F;* intput: 5 7 22 29 100 97 output: 3 4 65 *&#x2F; 费马小定理 定义：若存在整数 a , p 且gcd(a,p)=1,即二者互为质数，则有a^(p-1)≡ 1(mod p)。 费马小定理求逆元 long long fast_pow(long long a, long long b, long long p) &#123; long long ans &#x3D; 1; a %&#x3D; p; while (b) &#123; if (b &amp; 1) ans &#x3D; (ans * a) % p; a &#x3D; (a * a) % p; b &gt;&gt;&#x3D; 1; &#125; return ans; &#125; long long inv(long long x, long long p) &#123; return fast_pow(x, p - 2, p); &#125; KMP算法 KMP是一种时间复杂度O(n+m)的字符串单模匹配算法，核心是通过预处理模式串的所有前缀串的最长相同前后缀，构造next数组，在原串与模式串匹配失败时参考next数组做跳转避免原串指针的回退并减少模式串指针的回退长度 next数组是一个大小与模式串长度相同的数组，next[i]为模式串[0,i)子串的最长相同前后缀长度 构造next数组 &#x2F;&#x2F;优化过后的next 数组求法 void GetNext(char *p, int next[]) &#123; int pLen &#x3D; strlen(p); next[0] &#x3D; -1; int k &#x3D; -1; int j &#x3D; 0; while (j &lt; pLen - 1) &#123; &#x2F;&#x2F;p[k]表示前缀，p[j]表示后缀 if (k &#x3D;&#x3D; -1 || p[j] &#x3D;&#x3D; p[k]) &#123; ++j; ++k; if (p[j] !&#x3D; p[k]) next[j] &#x3D; k; else &#x2F;&#x2F;因为不能出现p[j] &#x3D; p[ next[j ]]，所以当出现时需要继续递归，k &#x3D; next[k] &#x3D; next[next[k]] next[j] &#x3D; next[k]; &#125; else &#123; k &#x3D; next[k]; &#125; &#125; &#125; kmp模板 int Kmp(char *s, char *p) &#123; int i &#x3D; 0; int j &#x3D; 0; int sLen &#x3D; strlen(s); int pLen &#x3D; strlen(p); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; &#x2F;&#x2F;如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++ if (j &#x3D;&#x3D; -1 || s[i] &#x3D;&#x3D; p[j]) &#123; i++; j++; &#125; else &#123; &#x2F;&#x2F;如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j] &#x2F;&#x2F;next[j]即为j所对应的next值 j &#x3D; next[j]; &#125; &#125; if (j &#x3D;&#x3D; pLen) return i - j; else return -1; &#125; 例题1 AC代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #define Memset(x, a) memset(x, a, sizeof(x)) using namespace std; const int N &#x3D; 1e6 + 10; char w[N], t[N]; int next[N]; int sum; void getNext(const char P[], int next[]) &#123; int m &#x3D; strlen(P); int i &#x3D; 0, j; j &#x3D; next[0] &#x3D; -1; while (i &lt; m) &#123; while (-1 !&#x3D; j &amp;&amp; P[i] !&#x3D; P[j]) j &#x3D; next[j]; next[++i] &#x3D; ++j; &#125; &#125; void kmp(const char T[], const char P[], int next[]) &#123; int n &#x3D; strlen(T), m &#x3D; strlen(P); int i, j; getNext(P, next); i &#x3D; j &#x3D; 0; while (i &lt; n) &#123; while (-1 !&#x3D; j &amp;&amp; T[i] !&#x3D; P[j]) j &#x3D; next[j]; i++; j++; if (j &gt;&#x3D; m) &#123; sum++; j &#x3D; next[j]; &#x2F;&#x2F;这儿修改很重要，不然会超时 &#125; &#125; &#125; int main() &#123; int T; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; sum &#x3D; 0; Memset(next, 0); scanf(&quot;%s%s&quot;, w, t); kmp(t, w, next); printf(&quot;%d\\n&quot;, sum); &#125; return 0; &#125; 例题2(next数组的使用) AC代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #define Memset(x, a) memset(x, a, sizeof(x)) using namespace std; const int N &#x3D; 4e5 + 10; int next[N], ans[N]; char s[N]; void getNext(const char P[], int next[]) &#123; int m &#x3D; strlen(P); int i &#x3D; 0, j; j &#x3D; next[0] &#x3D; -1; while (i &lt; m) &#123; while (-1 !&#x3D; j &amp;&amp; P[i] !&#x3D; P[j]) j &#x3D; next[j]; next[++i] &#x3D; ++j; &#125; &#125; int main() &#123; while (~scanf(&quot;%s&quot;, s)) &#123; Memset(next, 0); getNext(s, next); int cnt &#x3D; 0; int len &#x3D; strlen(s); int j &#x3D; next[len]; while (j &gt; 0) &#123; ans[++cnt] &#x3D; j; j &#x3D; next[j]; &#125; for (int i &#x3D; cnt; i &gt; 0; i--) printf(&quot;%d &quot;, ans[i]); printf(&quot;%d\\n&quot;, len); &#125; return 0; &#125; manacher算法 求最长回文子串，一般从字符串的中心开始向两侧遍历，为了防止偶数字串，在每个字符的左右都加上一个特殊字符如#（前提是这个字符在字符串中没有出现）使这两种回文串都变成奇回文串，因为原回文串长度是n,必将插入n+1个分隔符,处理之后的长度为2n+1,无论n的奇偶,2n+1必为奇数,故处理后必是奇回文串 #define maxn 1000010 #include &lt;bits&#x2F;stdc++.h&gt; using namespace std; char str[maxn] &#x3D; &#123;&quot;3212343219&quot;&#125;; &#x2F;&#x2F;原字符串 char tmp[maxn * 2]; &#x2F;&#x2F;转换后的字符串 int Len[maxn * 2]; &#x2F;&#x2F;转换原始串 int init(char *st) &#123; int i, len &#x3D; strlen(st); tmp[0] &#x3D; &#39;@&#39;; &#x2F;&#x2F;字符串开头增加一个特殊字符，防止越界 for (i &#x3D; 1; i &lt;&#x3D; 2 * len; i +&#x3D; 2) &#123; tmp[i] &#x3D; &#39;#&#39;; tmp[i + 1] &#x3D; st[i &#x2F; 2]; &#125; tmp[2 * len + 1] &#x3D; &#39;#&#39;; tmp[2 * len + 2] &#x3D; &#39;$&#39;; &#x2F;&#x2F;字符串结尾加一个字符，防止越界 tmp[2 * len + 3] &#x3D; 0; return 2 * len + 1; &#x2F;&#x2F;返回转换字符串的长度 &#125; &#x2F;&#x2F;Manacher算法计算过程 int manacher(char *st, int len) &#123; int mx &#x3D; 0, ans &#x3D; 0, po &#x3D; 0; &#x2F;&#x2F;mx即为当前计算回文串最右边字符的最大值 for (int i &#x3D; 1; i &lt;&#x3D; len; i++) &#123; if (mx &gt; i) Len[i] &#x3D; min(mx - i, Len[2 * po - i]); &#x2F;&#x2F;在Len[j]和mx-i中取个小 else Len[i] &#x3D; 1; &#x2F;&#x2F;如果i&gt;&#x3D;mx，要从头开始匹配 while (st[i - Len[i]] &#x3D;&#x3D; st[i + Len[i]]) Len[i]++; if (Len[i] + i &gt; mx) &#x2F;&#x2F;若新计算的回文串右端点位置大于mx，要更新po和mx的值 &#123; mx &#x3D; Len[i] + i; po &#x3D; i; &#125; ans &#x3D; max(ans, Len[i]); &#125; return ans - 1; &#x2F;&#x2F;返回Len[i]中的最大值-1即为原串的最长回文子串额长度 &#125; int main() &#123; int len &#x3D; init(str); manacher(tmp, len); &#125; manacher例题 AC代码 #include&lt;bits&#x2F;stdc++.h&gt; #define INF 0x3f3f3f3f const int MOD&#x3D;10007; const int N&#x3D;200000+5; const int dx[]&#x3D; &#123;-1,1,0,0&#125;; const int dy[]&#x3D; &#123;0,0,-1,1&#125;; using namespace std; int str[N]; int newStr[N*2]; int p[N*2]; int n; int init()&#123; newStr[0]&#x3D;-1; newStr[1]&#x3D;0; int j&#x3D;2; int len&#x3D;n; for (int i&#x3D;0;i&lt;len;i++)&#123; newStr[j++]&#x3D;str[i]; newStr[j++]&#x3D;0; &#125; return j; &#125; int manacher()&#123; int len&#x3D;init(); int res&#x3D;-1; int id; int mx&#x3D;0; for(int i&#x3D;1;i&lt;len;i++)&#123; int j&#x3D;2*id-i; if(i&lt;mx) p[i]&#x3D;min(p[j], mx-i); else p[i]&#x3D;1; while(newStr[i-p[i]]&#x3D;&#x3D;newStr[i+p[i]] &amp;&amp; newStr[i-p[i]]&lt;&#x3D;newStr[i-p[i]+2] ) p[i]++; if(mx&lt;i+p[i])&#123; id&#x3D;i; mx&#x3D;i+p[i]; &#125; res&#x3D;max(res,p[i]-1); &#125; return res; &#125; int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); for(int i&#x3D;0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;str[i]); printf(&quot;%d\\n&quot;,manacher()); &#125; return 0; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"如何跨设备同步hexo","slug":"如何跨设备同步hexo","date":"2024-01-22T09:15:18.000Z","updated":"2024-01-25T15:46:32.427Z","comments":true,"path":"article/a1d9e410697e.html","permalink":"https://exusiai.top/article/a1d9e410697e.html","excerpt":"前言 hexo-deployer-git 插件虽然能把静态资源托管在github，但是插件只能备份生成出来的网站文件，不能备份本地的源码文件，因此我选择手动将源码文件同步到github以此来跨设备使用。","text":"前言 hexo-deployer-git 插件虽然能把静态资源托管在github，但是插件只能备份生成出来的网站文件，不能备份本地的源码文件，因此我选择手动将源码文件同步到github以此来跨设备使用。 虽然已经有人为此写了一款插件 hexo-git-backup 但是经过我的实测这个插件对主题的备份有bug，翻看 issue 发现这个问题2016年就提出来了，维护者已经放弃了维护，而且根据项目介绍使用此插件会删除主题文件夹的 .git 文件夹，后续无法更新主题，权衡之下还是选择手动同步，日后有空或许会自己开发一个备份插件。 备份 注意：因为懒得新开个仓库所以我就直接在io仓库开了个分支进行备份，如果配置文件涉及到隐私请自行新建 private 仓库 把博客根目录初始化成 git 仓库，切分支就直接略过，然后配好 ignore 文件,我的配置如下 .DS_Store Thumbs.db db.json *.log node_modules&#x2F; public&#x2F; .deploy*&#x2F; 只要别上传 node_modules 和 .deploy_git 这俩文件夹就行。 重点是 themes 文件夹的处理，因为主题是从别人的仓库拉取的，所以不能直接上传到我们的仓库，这里要把主题配置成子模块。 git submodule add 子项目url 子项目在本地的路径 用 git submodule 查看是否正确 $ git submodule 85add1e141d3bb6663a0bc296a6c9646xxxxxxxx themes&#x2F;hexo-theme-fluid 拉取 虽然拉取可以用 git clone &lt;URL&gt; --recursive 一次性递归克隆整个项目，但是以前经常遇见克隆一些大型项目子模块失败，后面就慢慢养成分步克隆的习惯了。 拉取主项目 初始化子模块 git submodule init 更新子模块 git submodule update 这样所有文件就拉取下来了可以直接用 npm 安装依赖。","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://exusiai.top/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"https://exusiai.top/tags/hexo/"}]},{"title":"吐槽一次配node犯的抽象错误","slug":"吐槽一次配node犯的抽象错误","date":"2024-01-21T17:29:45.000Z","updated":"2024-01-21T18:06:20.901Z","comments":true,"path":"article/db90c03f85c2.html","permalink":"https://exusiai.top/article/db90c03f85c2.html","excerpt":"今晚翻了一下 hexo 的依赖发现已经有几个出了新版本，那自然是顺手 npm update 敲下去运行，结果报错满屏乱飞，翻到最上面发现报错是 npm ERR! code ERR_INVALID_URL npm ERR! Invalid URL 看到 Invalid URL 我第一反应就是配的淘宝源又出问题了，因为22年淘宝就切过一次域名了，但是访问了一下域名是没有变的，这下就开始了坐牢之旅。 首先是根据 npm 的提示去查看 log，打开文件一看 120 行整，自然是想也不想的丢给了 GPT，GPT 回复说 log 报错的只有一行 108 verbose stack TypeError [ERR_INVALID_URL]: Invalid URL","text":"今晚翻了一下 hexo 的依赖发现已经有几个出了新版本，那自然是顺手 npm update 敲下去运行，结果报错满屏乱飞，翻到最上面发现报错是 npm ERR! code ERR_INVALID_URL npm ERR! Invalid URL 看到 Invalid URL 我第一反应就是配的淘宝源又出问题了，因为22年淘宝就切过一次域名了，但是访问了一下域名是没有变的，这下就开始了坐牢之旅。 首先是根据 npm 的提示去查看 log，打开文件一看 120 行整，自然是想也不想的丢给了 GPT，GPT 回复说 log 报错的只有一行 108 verbose stack TypeError [ERR_INVALID_URL]: Invalid URL 我寻思着这个 log 和 terminal 讲的不是在脱裤子放屁，于是就直接去 Google 了，搜出来的方法有清除缓存、升级降级npm等等。我挨个尝试但报错都是这个样子一点不变，最后甚至连 nvm 都重装了一遍还是这样，经过多番尝试时间都过去快一小时了。最后我突然灵机一动觉得GPT不会在骗我吧，毕竟前几天才看了个AI在真消息里掺部分假来制作假新闻的视频。 遂立马打开 log 文件逐行阅读，果然发现 GPT 给的有问题，有问题的报错其实是 108 verbose stack TypeError [ERR_INVALID_URL]: Invalid URL 108 verbose stack at new NodeError (node:internal&#x2F;errors:387:5) 108 verbose stack at URL.onParseError (node:internal&#x2F;url:565:9) 108 verbose stack at new URL (node:internal&#x2F;url:641:5) 108 verbose stack at getProxyUri 这下很明显就能看出是因为 proxy 配置问题导致 parser 解析失败，然而 GPT 只给我展示了第一行没有多大价值的 log。 使用npm config ls -l来列出 npm 的所有配置在最后几行发现代理配置 proxy &#x3D; &quot;127.0.0.1:7890&quot; 剩下自然不必多说，问题就出在没有写协议类型。 看一眼时间已是凌晨两点，就是这么个很蠢的问题折腾了我一个小时，着实令人哭笑不得（orz。 事后反思一下犯这次错误主要有两个方面： 太过于依赖 GPT，对于这种行数不算多的 log 还是犯了懒没去看导致浪费了更多的时间，这点必须谨记于心。 上次在本地配置和使用 npm 已经过去挺长的一段时间，确实对此事一点印象都没有，看到 Invalid URL 后一点往代理上靠的想法都没有，熬夜写篇文当做小小的惩罚。","categories":[{"name":"碎碎念","slug":"碎碎念","permalink":"https://exusiai.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}],"tags":[{"name":"node","slug":"node","permalink":"https://exusiai.top/tags/node/"}]},{"title":"在Linux中理解用户管理并实现有效的访问控制","slug":"在Linux中理解用户管理-实现有效的访问控制","date":"2023-12-07T15:17:30.000Z","updated":"2023-12-15T05:50:19.373Z","comments":true,"path":"article/1098f68dd938.html","permalink":"https://exusiai.top/article/1098f68dd938.html","excerpt":"前言 Linux提供了强大而灵活的权限管理机制，为用户和管理员提供了极大的控制能力。无论是在个人计算机、服务器还是嵌入式设备中，Linux的权限控制系统都是确保数据安全和系统稳定性的重要组成部分。 在Linux中，每个文件和目录都有一组权限，这些权限定义了对它们的访问和操作权限。这种基于权限的访问控制是Linux安全模型的核心，它确保只有经过授权的用户可以访问敏感数据或执行关键操作。同时，Linux提供了多层次的权限控制，使管理员可以对不同用户和用户组进行细粒度的权限分配，从而实现了安全的多用户环境。 文件权限 权限类型解析","text":"前言 Linux提供了强大而灵活的权限管理机制，为用户和管理员提供了极大的控制能力。无论是在个人计算机、服务器还是嵌入式设备中，Linux的权限控制系统都是确保数据安全和系统稳定性的重要组成部分。 在Linux中，每个文件和目录都有一组权限，这些权限定义了对它们的访问和操作权限。这种基于权限的访问控制是Linux安全模型的核心，它确保只有经过授权的用户可以访问敏感数据或执行关键操作。同时，Linux提供了多层次的权限控制，使管理员可以对不同用户和用户组进行细粒度的权限分配，从而实现了安全的多用户环境。 文件权限 权限类型解析 在Linux中，每个文件和目录都有三组权限：所有者（Owner）、所属组（Group）和其他用户（Others），每组权限包括读取（Read）、写入（Write）和执行（Execute）权限 读取权限（r）允许查看文件的内容和属性 写入权限（w）允许修改文件的内容和属性 执行权限（x）允许以可执行文件或目录的形式运行文件或访问目录 除了用 r w x 这三个字母表示外，权限也可以用数字表示：r=4，w=2，x=1。将三个权限相加可以得到一个三位数的数字表示权限组的值，例如rwx（读、写、执行）为7，rw-（读、写）为6，r–（只读）为4。每个权限位有两种可能的状态，有3个权限位，所以总共有 $2^3 = 8$ 种不同的权限搭配。这些不同的权限搭配提供了灵活的权限控制选项，使管理员可以根据需要精确地控制每个文件和目录的访问和操作权限。 使用ls -l命令可以查看文件的权限。例如： drwx-w-r-x 16 hk hk 4096 Dec 8 22:56 hk 第一个字符 “d” 表示这是一个目录。如果是一个普通文件，该位置将显示 “-”。后续的九个字符 “rwx-w-r-x” 表示文件的权限。由左到右，前三个字符 “rwx” 表示所有者（hk）的权限，中间三个字符 “w-” 表示所属组（hk）的权限，最后三个字符 “r-x” 表示其他用户的权限。 设置文件权限 在Linux中，可以使用命令 chmod 来设置文件或目录的权限。chmod 命令可以通过两种方式来设置权限：符号模式（Symbolic Mode）和数字模式（Numeric Mode），通常情况下，只有文件的所有者或超级用户才有权限更改文件的权限。 符号模式 使用符号模式可以直观地指定权限的增加或取消。下面是符号模式中使用的符号及其含义： +：添加权限 -：取消权限 =：设置权限为指定值 结合这些符号，可以使用如下格式设置权限： chmod [who] [symbol] [permissions] file 其中： - [who] 表示要设置权限的对象，可以是以下之一： - u：所有者（user）。 - g：所属组（group）。 - o：其他用户（others）。 - a：所有用户（all），等同于 ugo。 - [permissions] 表示要设置的权限，可以是以下之一： - r：读权限。 - w：写权限。 - x：执行权限。 - s：设置用户或组的权限为 SUID 或 SGID（特殊权限）。 - t：设置目录的粘滞位（Sticky Bit）权限。 - file 表示要设置权限的文件或目录。 例如，要将文件 example.txt 的所有者权限设置为可读、可写，可以使用以下命令： chmod u+rw example.txt 数字模式 使用数字模式可以直接使用数字来表示权限。每个权限对应一个数字值，通过将这些数字相加来表示多个权限的组合。结合这些数字，可以使用如下格式设置权限： chmod [permissions] file 例如，要将文件 example.txt 的权限设置为所有者可读、可写，所属组可读，其他用户可执行，可以使用以下命令： chmod 764 example.txt 在数字模式下，可以使用特殊的权限位来设置一些特殊权限。这些特殊权限位称为粘滞位（数字1）、SUID（数字4） 位和 SGID（数字2） 位。 SUID（Set User ID）权限： 当 SUID 权限应用于可执行文件时，它指定该文件在执行时将使用文件所有者的权限而不是执行者自身的权限。这意味着，当普通用户执行具有 SUID 权限的可执行文件时，该文件将以文件所有者的权限运行。 SUID 权限的示例用法是 /bin/passwd 可执行文件，该文件允许普通用户更改自己的密码，但是只有管理员才能更改其他用户的密码。这是通过将 /bin/passwd 设置为具有 SUID 权限来实现的，这样普通用户在执行该文件时将以管理员的权限执行。 SGID（Set Group ID）权限： 当 SGID 权限应用于可执行文件或目录时，它指定该文件或目录在执行时将使用文件所属组的权限而不是执行者自身的权限。这意味着，当普通用户执行具有 SGID 权限的可执行文件或访问具有 SGID 权限的目录时，将以文件所属组的权限运行。 SGID 权限的示例用法是 /usr/bin/newgrp 可执行文件，该文件允许用户切换到其他组。当用户执行 /usr/bin/newgrp 时，它将以该组的权限运行。 粘滞位（Sticky Bit）: 当目录设置了粘滞位后，只有目录的所有者、文件的所有者或超级用户才能删除或重命名该目录中的文件。其他用户无法删除或重命名不属于自己的文件，即使对于该目录具有写权限也不行。 粘滞位的主要用途是在多个用户共享同一个目录时，确保用户只能删除或修改自己创建的文件，而无法删除或修改其他用户创建的文件。 用户和用户组 在Linux系统中，用户可以划分为不同的组，这样可以更好地管理用户的访问权限和资源，每个用户可以属于一个或多个用户组。通过正确设置文件权限和用户组，可以实现对文件和目录的细粒度访问控制，确保系统的安全性和可管理性。 常见用户组 root（超级用户组）： GID: 0 说明：root是系统中最高权限的用户组，拥有对系统的完全控制权限。root用户可以访问系统上的所有文件，进行系统配置和管理任务。通常情况下，只有root用户才能修改一些关键系统文件和目录。 adm（系统日志组）： GID: 4 说明：adm组拥有对系统日志文件的访问权限。系统日志记录在/var/log目录中，该组允许一些系统工具和日志管理程序访问日志文件。","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://exusiai.top/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"通过 Hexo 5 注入器为页面添加新功能","slug":"通过-Hexo-5-注入器为页面添加新功能","date":"2023-11-27T07:14:29.000Z","updated":"2023-12-27T15:01:37.030Z","comments":true,"path":"article/1901ac8c10de.html","permalink":"https://exusiai.top/article/1901ac8c10de.html","excerpt":"Hexo 注入器 注入器被用于将静态代码片段注入生成的 HTML 的 &lt;head&gt; 和 &lt;body&gt; 中。Hexo 将在 after_render:html 过滤器 之前 完成注入。 编写注入代码，需要在博客的根目录下创建 scripts 文件夹，然后在里面任意命名创建一个 js 文件即可。","text":"Hexo 注入器 注入器被用于将静态代码片段注入生成的 HTML 的 &lt;head&gt; 和 &lt;body&gt; 中。Hexo 将在 after_render:html 过滤器 之前 完成注入。 编写注入代码，需要在博客的根目录下创建 scripts 文件夹，然后在里面任意命名创建一个 js 文件即可。 概要 hexo.extend.injector.register(entry, value, to) entry &lt;string&gt; 代码片段注入的位置，接受以下值： head_begin: 注入在 &lt;head&gt; 之后（默认） head_end: 注入在 &lt;/head&gt; 之前 body_begin: 注入在 &lt;body&gt; 之后 body_end: 注入在 &lt;/body&gt; 之前 value &lt;string&gt; | &lt;Function&gt; 除了字符串，也支持返回值为字符串的函数 需要注入的代码片段。 to &lt;string&gt; 需要注入代码片段的页面类型，接受以下值： default: 注入到每个页面（默认值） home: 只注入到主页（is_home() 为 true 的页面） post: 只注入到文章页面（is_post() 为 true 的页面） page: 只注入到独立页面（is_page() 为 true 的页面） archive: 只注入到归档页面（is_archive() 为 true 的页面） category: 只注入到分类页面（is_category() 为 true 的页面） tag: 只注入到标签页面（is_tag() 为 true 的页面） 或是其他自定义 layout 名称，例如在 Fluid 主题中 about 对应关于页、links 对应友联页，自定义 layout 参见 写作 - 布局（Layout） 示例 文章时效性提示 Fluid 社区提供了根据文章发布时间来为文章开头插入一条提示的注入代码，这条代码全主题通用。 hexo.extend.injector.register('body_end', ` &lt;script type=\"text/javascript\"> (function() &#123; var times = document.getElementsByTagName('time'); if (times.length === 0) &#123; return; &#125; var posts = document.getElementsByClassName('post-content'); if (posts.length === 0) &#123; return; &#125; var pubTime = new Date(times[0].dateTime); /* 文章发布时间戳 */ var now = Date.now() /* 当前时间戳 */ var interval = parseInt(now - pubTime) /* 发布时间超过指定时间（毫秒） */ if (interval > 3600*24*30*1000)&#123; var days = parseInt(interval / 86400000) posts[0].innerHTML = '&lt;div class=\"note note-warning\" style=\"font-size:0.9rem\">&lt;p>' + '&lt;div class=\"h6\">文章时效性提示&lt;/div>&lt;p>这是一篇发布于 ' + days + ' 天前的文章，部分信息可能已发生改变，请注意甄别。' + '&lt;/p>&lt;/p>&lt;/div>' + posts[0].innerHTML; &#125; &#125;)(); &lt;/script> `); 但是某些技术性文章作者或许会持续更新，这种情况下判断更新时间就会更好，所以我编写了根据文章更新时间判断时效性的代码。 注意：更新时间的获取代码或许仅支持 Fluid 主题。 hexo.extend.injector.register('body_end', ` &lt;script type=\"text/javascript\"> (function() &#123; var metaElement = document.querySelector('meta[property=\"article:modified_time\"]'); if (metaElement) &#123; var modifiedTime = metaElement.getAttribute('content'); var articleDate = new Date(modifiedTime); var currentDate = new Date(); var posts = document.getElementsByClassName('post-content'); if (posts.length === 0) &#123; return; &#125; // 计算时间差，单位为毫秒 var timeDifference = currentDate - articleDate; // 一年的毫秒数 var oneYearInMilliseconds = 365 * 24 * 60 * 60 * 1000; if (timeDifference > oneYearInMilliseconds) &#123; var daysSinceUpdate = Math.floor(timeDifference / (24 * 60 * 60 * 1000)); posts[0].innerHTML = '&lt;div class=\"note note-warning\" style=\"font-size:0.9rem\">&lt;p>' + '&lt;div class=\"h6\">文章时效性提示&lt;/div>&lt;p>这是一篇更新于 ' + daysSinceUpdate + ' 天前的文章，部分信息可能已经有所发展或是发生改变。' + '&lt;/p>&lt;/p>&lt;/div>' + posts[0].innerHTML; &#125; &#125; &#125;)(); &lt;/script> `); 致谢 感谢 Hexo 细致的 文档教程 感谢 Fluid 社区的示例代码和文章教程，这给了我很大的启发。","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://exusiai.top/tags/Hexo/"}]},{"title":"BT番剧媒体库搭建","slug":"BT番剧媒体库搭建","date":"2023-11-25T09:19:09.000Z","updated":"2023-11-29T14:30:31.557Z","comments":true,"path":"article/7639876b5368.html","permalink":"https://exusiai.top/article/7639876b5368.html","excerpt":"","text":"暂时撤回文章","categories":[],"tags":[]},{"title":"猴子打字-AC自动机","slug":"猴子打字-AC自动机","date":"2023-11-22T14:32:42.000Z","updated":"2023-11-25T07:16:36.336Z","comments":true,"path":"article/8467d4716bb5.html","permalink":"https://exusiai.top/article/8467d4716bb5.html","excerpt":"有一个有趣的定理：无限猴子定理（infinite monkey theorem），它的表述如下：让一只猴子在打字机上随机按键，当按键次数达到无穷时，几乎必然能够打出任何给定的文字。 给出一篇猴子打出的“文章”，并给定一个由若干个词组成的词典，问猴子一共打出了多少个在词典中出现的词。","text":"有一个有趣的定理：无限猴子定理（infinite monkey theorem），它的表述如下：让一只猴子在打字机上随机按键，当按键次数达到无穷时，几乎必然能够打出任何给定的文字。 给出一篇猴子打出的“文章”，并给定一个由若干个词组成的词典，问猴子一共打出了多少个在词典中出现的词。 输入格式: 第一行一个整数 $(1≤n≤10000)$，表示词典中单词的个数。 接下来$n$行，每行一个仅由小写字母组成的单词，长度不超过 $50$。 最后一行是一篇仅由小写字母组成的文章，长度不超过 $1000000$。 输出格式: 一行一个整数，表示答案。 输入样例： 5 jsk jisuan suantou love program jisuantouisprogramming 输出样例： 3 这道题是 AC 自动机的模板题，直接套用模板就好了。 AC 自动机算法主要依靠构造一个有限状态机（类似于在一个 Trie 树中添加失配指针）来实现。 这些额外的失配指针允许在查找字符串失败时进行回退（例如设 Trie 树的单词 cat 匹配失败，但是在 Trie 树中存在另一个单词 cart，失配指针就会指向前缀 ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。 如果对 KMP 算法了解的话，应该知道 KMP 算法中的 next 函数的用途。KMP 中我们用 next 函数记录了失配后应该调整到的位置，AC 自动机的失败 Fail 指针具有同样的功能，也就是说当我们的模式串在 Trie 上进行匹配时，如果与当前节点的关键字不能继续匹配，就应该去当前节点的失败指针所指向的节点继续进行匹配。 #include &lt;bits&#x2F;stdc++.h&gt; const int MAXC &#x3D; 26; const int MAXN &#x3D; 1000007; const int MAX_WORD_LEN &#x3D; 57; using namespace std; &#x2F;&#x2F; 数据量比较大，可能需要开成全局的，或者动态的，直接放在结构体中，也许会超内存 int child[MAXN][MAXC], fail[MAXN], sta[MAXN], Q[MAXN]; int tot; &#x2F;** * AC 自动机 *&#x2F; struct AC_Automaton &#123; &#x2F;&#x2F; int child[MAXN][MAXC], fail[MAXN], sta[MAXN], Q[MAXN]; &#x2F;&#x2F; int tot; &#x2F;** * 清空 *&#x2F; void clear() &#123; memset(child, 255, sizeof(child)); memset(fail, 0, sizeof(fail)); tot &#x3D; 0; memset(sta, 0, sizeof(sta)); &#125; &#x2F;** * 插入单词 * @param ch 单词，该单词下标从 1 开始 *&#x2F; void insert(char* ch) &#123; int p &#x3D; 0, l &#x3D; strlen(ch + 1); for (int i &#x3D; 1; i &lt;&#x3D; l; i++) &#123; if (child[p][ch[i] - &#39;a&#39;] &#x3D;&#x3D; -1) child[p][ch[i] - &#39;a&#39;]&#x3D; ++tot; p &#x3D; child[p][ch[i] - &#39;a&#39;]; &#125; sta[p]++; &#125; &#x2F;** * 对插入了单词的前缀树构造失败指针 *&#x2F; void build() &#123; int l &#x3D; 0, r &#x3D; 0; for (int i &#x3D; 0; i &lt; MAXC; i++) if (child[0][i] &#x3D;&#x3D; -1) child[0][i] &#x3D; 0; else Q[++ r] &#x3D; child[0][i]; while (l &lt; r) &#123; int p &#x3D; Q[++l]; for (int i &#x3D; 0; i &lt; MAXC; i++) if (child[p][i] &#x3D;&#x3D; -1) child[p][i] &#x3D; child[fail[p]][i]; else &#123; fail[child[p][i]] &#x3D; child[fail[p]][i]; Q[++ r] &#x3D; child[p][i]; &#125; &#125; &#125; &#x2F;** * 查询给定的字符串中，一共有多少个单词是出现在词典中的 * @param ch 给定的字符串，该字符串下标从 1 开始 * @return 该字符串中有多少单词是出现在词典中的 *&#x2F; int solve(char* ch) &#123; int ret &#x3D; 0, p &#x3D; 0, l &#x3D; strlen(ch + 1); for (int i &#x3D; 1; i &lt;&#x3D; l; i++) &#123; p &#x3D; child[p][ch[i] - &#39;a&#39;]; int tmp &#x3D; p; while (tmp) &#123; ret +&#x3D; sta[tmp]; sta[tmp] &#x3D; 0; tmp &#x3D; fail[tmp]; &#125; &#125; return ret; &#125; &#125;T; int main() &#123; &#x2F;&#x2F; 构造 AC 自动机 auto ac &#x3D; new AC_Automaton(); ac-&gt;clear(); int n; scanf(&quot;%d&quot;, &amp;n); &#x2F;&#x2F; 读入单词，加入前缀树 char* s &#x3D; (char*)malloc(sizeof(char) * MAX_WORD_LEN); for (int i &#x3D; 0; i &lt; n; i++) &#123; &#x2F;&#x2F; 字符串下标从 1 开始 scanf(&quot;%s&quot;, s + 1); ac-&gt;insert(s); &#125; &#x2F;&#x2F; 根据前缀树中的单词构造失败指针，即构造字典 ac-&gt;build(); &#x2F;&#x2F; 给定的文章，下标从 1 开始 char* t &#x3D; (char*)malloc(sizeof(char) * MAXN); scanf(&quot;%s&quot;, t + 1); printf(&quot;%d\\n&quot;, ac-&gt;solve(t)); return 0; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://exusiai.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://exusiai.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"oh-my-zsh自用配置记录","slug":"oh-my-zsh自用配置记录","date":"2023-11-21T14:06:56.000Z","updated":"2023-12-12T08:44:29.648Z","comments":true,"path":"article/183d71ab42a6.html","permalink":"https://exusiai.top/article/183d71ab42a6.html","excerpt":"Zsh（Z Shell）是一个在Unix/Linux操作系统中的命令行解释器，相比于Bash（Bourne Again Shell），Zsh具有更强大的自动补全、丰富的插件和主题生态系统、高级历史记录、更多的参数替换选项、灵活的数组处理和强大的调试功能。","text":"Zsh（Z Shell）是一个在Unix/Linux操作系统中的命令行解释器，相比于Bash（Bourne Again Shell），Zsh具有更强大的自动补全、丰富的插件和主题生态系统、高级历史记录、更多的参数替换选项、灵活的数组处理和强大的调试功能。 安装zsh 以我用过的OS举例 Ubuntu: sudo apt-get install zsh Arch Linux: sudo pacman -S zsh 安装好后运行chsh -s /bin/zsh设置zsh为默认shell，如果遇到极为特殊的情况zsh不在此路径下（真的有吗？ 2023.12.12记，还真给我遇见了，今天配一个新arch机器的时候不知道为什么第一个命令不生效），可以使用which zsh来确定zsh的路径，然后在命令中进行替换，或者直接使用chsh -s $(which zsh)命令进行设置。 下载oh-my-zsh 1、使用curl安装 sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 2、使用wget安装 sh -c \"$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" 如果是国内机有墙的话可以使用使用Static CDN提供的反代服务。将 raw.githubusercontent.com 换成raw.staticdn.net即可加速（截止2023.11.22仍可加速） 插件推荐 oh-my-zsh同样有很多自带插件在~/.oh-my-zsh/plugins里，默认只启用了git，这里推荐部分我比较喜欢用的插件，非自带插件会指明下载地址，未说明则均为自带插件无需下载。 1、Z Z 插件是一个用于快速跳转到最常用目录的插件。它通过记忆和分析用户在命令行中的行为来确定用户最常访问的目录，并允许用户使用简短的别名快速切换到这些目录。Z 插件会记住用户经常访问的目录，并根据用户的行为进行排序。这样，当用户想要切换到某个目录时，只需键入与该目录相关的部分名称，Z 插件就会智能地补全并跳转到匹配的目录。 用法：z 目录名称 同时如果文件目录前缀没有重复的话，可以使用正则表达式匹配或者直接简写，上图示例则可以写为 z the 也能跳转到themes文件夹下。如果是第一次跳转对结果不明确，也可以在命令输入完成后按下tab键，此时会z插件会自动显示完整路径以便确认。 启用方式： 在 .zshrc 文件里找到plugins=(xxxx)数组 ,在括号里面加上插件名即可。例如：plugins=(git z 插件A 插件B xxxx) ，添加后记得执行 source ~/.zshrc。 2、extract extract 插件定义了一个名为 extract 的函数，用于解压缩你传递给它的文件，并支持多种存储文件类型。 用法：extract 文件名称 这样一来，你就不需要知道具体的解压缩命令，只需执行 extract &lt;filename&gt; 就可以解压大部分常见文件，支持文件扩展名点这里查看 PS: 直接输入x 文件名也能解压，不需要输入完整函数名，非常方便！ 3、zsh-syntax-highlighting 这个插件为 zsh 提供语法高亮功能。它可以在用户在交互式终端的 zsh 提示符中输入命令时进行高亮显示。这有助于在运行命令之前审查命令，特别是在捕捉语法错误方面。 即使在命令输入过程中，这个插件也能对命令进行高亮显示，使用户能够更清晰地看到命令的结构和语法。这对于编写复杂的命令或避免常见的语法错误非常有帮助。 4、colored-man-pages 这个插件为手册添加了颜色，在查阅手册时更加的清晰明了。 您也可以尝试在其他页面上涂色，方法是在相应的命令前面加上colored colored git help clone","categories":[],"tags":[]},{"title":"Git更新单个文件","slug":"Github更新单个文件","date":"2023-02-21T14:17:15.000Z","updated":"2023-11-30T14:15:25.864Z","comments":true,"path":"article/e6b112c3ca15.html","permalink":"https://exusiai.top/article/e6b112c3ca15.html","excerpt":"使用git fetch命令从远程仓库获取最新的变更，但不会自动合并到本地分支。 git fetch origin 使用git checkout命令切换到你想更新的本地分支。 git checkout &lt;branch-name&gt; 使用git checkout命令将远程仓库中的指定文件覆盖到你的本地工作区。","text":"使用git fetch命令从远程仓库获取最新的变更，但不会自动合并到本地分支。 git fetch origin 使用git checkout命令切换到你想更新的本地分支。 git checkout &lt;branch-name&gt; 使用git checkout命令将远程仓库中的指定文件覆盖到你的本地工作区。 git checkout origin&#x2F;&lt;branch-name&gt; -- &lt;path&#x2F;to&#x2F;file&gt; 在上面的命令中，将&lt;branch-name&gt;替换为远程仓库中包含要更新文件的分支名称，将&lt;path/to/file&gt;替换为文件的路径和名称。 例如，如果要更新main分支上的src/example.js文件，命令将如下所示： git checkout origin&#x2F;main -- src&#x2F;example.js # 这将覆盖本地的 src&#x2F;example.js 文件，使其与远程仓库中的最新版本一致。","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://exusiai.top/tags/Git/"}]},{"title":"Linux上创建和使用SWAP","slug":"Linux上创建和使用swapfile","date":"2023-02-17T07:01:14.000Z","updated":"2023-03-01T05:57:15.000Z","comments":true,"path":"article/160754cd38eb.html","permalink":"https://exusiai.top/article/160754cd38eb.html","excerpt":"什么是SWAP 一般来说swap指的是一个交换分区或文件，其功能是主要是在内存不够用的时候，将部分内存上的数据交换到swap空间上，以便让系统不会因内存不够用而导致oom或者更致命的情况出现。","text":"什么是SWAP 一般来说swap指的是一个交换分区或文件，其功能是主要是在内存不够用的时候，将部分内存上的数据交换到swap空间上，以便让系统不会因内存不够用而导致oom或者更致命的情况出现。 创建SWAP 1.创建一个交换文件 在Linux上创建交换文件非常简单，可以使用dd命令来创建一个指定大小的文件，然后使用mkswap命令将其标记为交换空间。例如，我们可以使用以下命令创建一个大小为1GB的交换文件： sudo dd if=/dev/zero of=/swapfile bs=1024 count=1048576 这个命令的意思是用 dd 工具从 /dev/zero 读取数据，然后写入到 /swapfile 文件中。/dev/zero 是一个特殊的设备文件，它会提供无限的零字节。bs=1024 指定了每次读写的块大小为 1024 字节，也就是 1 KB。count=1048576 指定了总共要读写的块数为 1048576，也就是 1 MB。所以这个命令会创建一个大小为 1 GB 的文件，里面全是零字节。这个文件通常用来作为交换分区，用来扩展系统的内存。 上面的指令也可以写成sudo dd if=/dev/zero of=/swapfile bs=1G count=1，这两个命令的效果是一样的，只是读写的块大小和块数不同 bs的值会影响dd命令的性能，因为它决定了每次读写的数据量。如果bs的值太小，那么dd命令就需要进行更多的系统调用，这会增加开销和延迟。如果bs的值太大，那么dd命令就可能遇到缓冲区溢出或者内存不足的问题，这也会降低性能。一般来说，bs的值应该根据不同的硬件和操作系统的特点来选择，比如磁盘扇区大小、内存大小、缓存大小等。你可以尝试不同的bs的值，并且用SIGUS1信号来查看dd命令的状态报告，从而找到一个合适的bs的值。 2.准备交换空间 创建好交换文件后，我们需要将其标记为交换空间。可以使用mkswap命令： sudo mkswap /swapfile （可选） 默认权限过于宽松，我们可以限制它们，以便只有 root 用户可以使用 swapfile。 sudo chmod 600 /swapfile 3.使用交换空间 标记好交换文件后，我们需要将其挂载为交换空间。可以使用swapon命令： sudo swapon /swapfile 4.持久化交换空间 如果我们希望在系统重启后仍然可以使用交换空间，需要将其持久化。可以将swapfile添加到/etc/fstab文件中，这样系统在启动时会自动挂载交换文件。例如，我们可以使用以下命令将swapfile添加到/etc/fstab文件中： echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab 这个命令会将/swapfile添加到/etc/fstab文件中，并设置其为交换空间，你也可以手动把/swapfile none swap sw 0 0给追加到/etc/fstab的最后一行。 参数解释： &#x2F;swapfile：这是要挂载的文件系统的路径，也就是我们之前创建的交换分区文件。 none：这是要挂载到的目标路径，对于交换分区来说，不需要指定具体的路径，所以用 none 表示。 swap：这是要挂载的文件系统的类型。 sw：这是挂载选项，sw 表示交换空间。 0 0：这是 dump 和 fsck 的参数，dump是要挂载的文件系统的备份频率，对于交换分区来说，不需要备份，所以用 0 表示；fsck是文件系统检查的优先级，对于交换分区来说，不需要检查，所以用 0 表示。 5.检查交换空间使用情况 使用指令swapon --show可以查看当前系统中的交换空间使用情况，如下图所示： 参考链接：How to Create a Swap File on Linux","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://exusiai.top/tags/Linux/"}]},{"title":"Navicat无限重置试用","slug":"Navicat无限重置试用","date":"2023-01-05T10:24:45.000Z","updated":"2023-02-01T07:51:53.303Z","comments":true,"path":"article/4fb5dd7025e0.html","permalink":"https://exusiai.top/article/4fb5dd7025e0.html","excerpt":"使用清除注册表方法来达到无限试用Navicat Premium 16的效果，bat文件如下。可以设置定时任务来自动进行注册表清除。","text":"使用清除注册表方法来达到无限试用Navicat Premium 16的效果，bat文件如下。可以设置定时任务来自动进行注册表清除。 @echo off ​ echo Delete HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium\\Registration[version and language] for &#x2F;f %%i in (&#39;&quot;REG QUERY &quot;HKEY_CURRENT_USER\\Software\\PremiumSoft\\NavicatPremium&quot; &#x2F;s | findstr &#x2F;L Registration&quot;&#39;) do ( reg delete %%i &#x2F;va &#x2F;f ) echo. ​ echo Delete Info folder under HKEY_CURRENT_USER\\Software\\Classes\\CLSID for &#x2F;f %%i in (&#39;&quot;REG QUERY &quot;HKEY_CURRENT_USER\\Software\\Classes\\CLSID&quot; &#x2F;s | findstr &#x2F;E Info&quot;&#39;) do ( reg delete %%i &#x2F;va &#x2F;f ) echo. ​ echo Finish ​ pause","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"linux修改环境变量的几种方法","slug":"linux修改环境变量的几种方法","date":"2022-12-11T12:05:01.000Z","updated":"2023-02-17T07:02:02.272Z","comments":true,"path":"article/e12de754c110.html","permalink":"https://exusiai.top/article/e12de754c110.html","excerpt":"修改方法一： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：立即生效 有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置 用户局限：仅对当前用户","text":"修改方法一： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：立即生效 有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置 用户局限：仅对当前用户 修改方法二： 通过修改.bashrc文件: vim ~/.bashrc //在最后一行添上： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：（有以下两种） 1、关闭当前终端窗口，重新打开一个新终端窗口就能生效 2、输入“source ~/.bashrc”命令，立即生效 有效期限：永久有效 用户局限：仅对当前用户 修改方法三: 通过修改profile文件: vim /etc/profile /export PATH //找到设置PATH的行，添加 export PATH=/usr/local/mongodb/bin:$PATH 生效方法：系统重启 有效期限：永久有效 用户局限：对所有用户 修改方法四: 通过修改environment文件: vim /etc/environment 在PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"中加入“:/usr/local/mongodb/bin” 生效方法：系统重启 有效期限：永久有效","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://exusiai.top/tags/Linux/"}]},{"title":"vscode的一些配置","slug":"vscode的一些配置","date":"2022-11-18T02:21:14.000Z","updated":"2023-02-01T07:52:21.780Z","comments":true,"path":"article/2c7139de27ce.html","permalink":"https://exusiai.top/article/2c7139de27ce.html","excerpt":"记录一下自己的配置文件","text":"记录一下自己的配置文件 &#x2F;&#x2F; setting.json &#123; &quot;files.defaultLanguage&quot;: &quot;cpp&quot;, &#x2F;&#x2F; ctrl+N新建文件后默认的语言 &quot;editor.formatOnType&quot;: false, &#x2F;&#x2F; 输入分号(C&#x2F;C++的语句结束标识)后自动格式化当前这一行的代码 &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false, &#x2F;&#x2F; clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了 &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;, &#x2F;&#x2F; 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense &#x2F;&#x2F; &quot;editor.snippetSuggestions&quot;: &quot;maxx&quot;, &#x2F;&#x2F; （可选）snippets显示在补全列表顶端，默认是inline &quot;code-runner.runInTerminal&quot;: true, &#x2F;&#x2F; 设置成false会在“输出”中输出，无法输入 &quot;code-runner.executorMap&quot;: &#123; &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -g -O2 -static-libgcc -std&#x3D;c11 -fexec-charset&#x3D;GBK &amp;&amp; &amp;&#39;$dir$fileNameWithoutExt&#39;&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -g -O2 -static-libgcc -std&#x3D;c++17 -fexec-charset&#x3D;GBK &amp;&amp; &amp;&#39;$dir$fileNameWithoutExt&#39;&quot; &#x2F;&#x2F; &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc -std&#x3D;c11 -fexec-charset&#x3D;GBK &amp;&amp; $dir$fileNameWithoutExt&quot;, &#x2F;&#x2F; &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc -std&#x3D;c++17 -fexec-charset&#x3D;GBK &amp;&amp; $dir$fileNameWithoutExt&quot; &#125;, &#x2F;&#x2F; 右键run code时运行的命令；未注释的仅适用于PowerShell（Win10默认），文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认），PS和bash也能用，但文件名中有空格时无法运行 &quot;code-runner.saveFileBeforeRun&quot;: true, &#x2F;&#x2F; run code前保存 &quot;code-runner.preserveFocus&quot;: false, &#x2F;&#x2F; 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false &quot;code-runner.clearPreviousOutput&quot;: false, &#x2F;&#x2F; 每次run code前清空属于code runner的终端消息，默认false &quot;code-runner.ignoreSelection&quot;: true, &#x2F;&#x2F; 默认为false，效果是鼠标选中一块代码后可以单独执行，但C是编译型语言，不适合这样用 &#x2F;&#x2F;屏蔽一些文件试目录更加简洁 &quot;files.exclude&quot;: &#123; &quot;**&#x2F;.git&quot;: true, &quot;**&#x2F;.svn&quot;: true, &quot;**&#x2F;.hg&quot;: true, &quot;**&#x2F;CVS&quot;: true, &quot;**&#x2F;.DS_Store&quot;: true, &#x2F;&#x2F; &quot;**&#x2F;.vscode&quot;: true, &quot;**&#x2F;*.exe&quot;: true, &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;D:\\\\Program\\\\anaconda\\\\pkgs\\\\requests-2.27.1-pyhd3eb1b0_0&quot;, &quot;C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python310\\\\Lib\\\\site-packages&quot;, &quot;D:\\\\Program\\\\anaconda\\\\Lib\\\\site-packages&quot; ], &quot;C_Cpp.clang_format_sortIncludes&quot;: true, &quot;files.associations&quot;: &#123; &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;unordered_set&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;regex&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;csetjmp&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;scoped_allocator&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;stdio.h&quot;: &quot;c&quot;, &quot;process.h&quot;: &quot;c&quot;, &quot;stdlib.h&quot;: &quot;c&quot;, &quot;string.h&quot;: &quot;c&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;charconv&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;cuchar&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;queue&quot;: &quot;cpp&quot;, &quot;linklist.c&quot;: &quot;cpp&quot;, &quot;linkstack.c&quot;: &quot;cpp&quot;, &quot;stack&quot;: &quot;cpp&quot; &#125;, &quot;C_Cpp.errorSquiggles&quot;: &quot;Enabled&quot;, &quot;python.testing.pytestArgs&quot;: [ &quot;.&quot; ], &quot;python.testing.unittestEnabled&quot;: false, &quot;python.testing.pytestEnabled&quot;: true, &#x2F;&#x2F; 格式化时调整include的顺序（按字母排序） &#125;","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"windows下配置Oh My Posh","slug":"windows下配置Oh My Posh","date":"2022-11-07T09:04:40.000Z","updated":"2023-11-26T14:08:13.610Z","comments":true,"path":"article/139029992c61.html","permalink":"https://exusiai.top/article/139029992c61.html","excerpt":"Oh My Posh允许用户使用颜色定义和呈现提示，从而允许使用终端的全彩色调色板。它提供了对现有主题的轻松定制或个性化主题的创建，范围从标准细分到自定义实现。配置可以从一个shell或机器无缝地转移到另一个shell或机器，从而确保无论用户在哪里工作都有一致的提示。","text":"Oh My Posh允许用户使用颜色定义和呈现提示，从而允许使用终端的全彩色调色板。它提供了对现有主题的轻松定制或个性化主题的创建，范围从标准细分到自定义实现。配置可以从一个shell或机器无缝地转移到另一个shell或机器，从而确保无论用户在哪里工作都有一致的提示。 安装oh-my-posh 使用winget安装 winget install JanDeDobbeleer.OhMyPosh -s winget 使用scoop安装 scoop install https:&#x2F;&#x2F;github.com&#x2F;JanDeDobbeleer&#x2F;oh-my-posh&#x2F;releases&#x2F;latest&#x2F;download&#x2F;oh-my-posh.json 普通安装 Set-ExecutionPolicy Bypass -Scope Process -Force; Invoke-Expression ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;ohmyposh.dev&#x2F;install.ps1&#39;)) 推荐使用scoop安装，如果没有scoop，也可以去Microsoft Store安装oh-my-posh。 下载一个字体 在管理员权限的命令行中输入以下指令，选择一个字体进行下载，如果频繁下载失败可以自行去网络搜索字体下载安装。 oh-my-posh font install 安装字体后，需要配置 Windows 终端才能使用它。这可以通过修改Windows终端设置（默认快捷方式：CTRL + SHIFT + ，）打开settings.json 文件，在配置文件中的默认属性下添加 font.face 属性。 &#123; &quot;profiles&quot;: &#123; &quot;defaults&quot;: &#123; &quot;font&quot;: &#123; &quot;face&quot;: &quot;MesloLGM NF&quot; &#125; &#125; &#125; &#125; 更改命令行主题 一般来说windows下推荐使用powershell，所以在powershell中输入以下指令，提示没有文件则点击新建文件。 notepad $PROFILE 在文件中输入 oh-my-posh init pwsh | Invoke-Expression 添加之后，重新加载配置文件以使更改生效。 . $PROFILE 做完以上步骤之后，就可以在powershell中使用oh-my-posh了。 更改主题 在powershell中输入以下指令，可以查看主题。 Get-PoshThemes 在最底部有主题文件的位置，记录下你想修改的主题路径。 以我的主题1_shell为例，输入指令修改文件 notepad $profile 将之前的文件内容替换为以下内容便可以使用自己的主题了。 oh-my-posh init pwsh --config \"$env:POSH_THEMES_PATH\\1_shell.omp.json\"。","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"服务器操作","slug":"服务器操作","date":"2022-10-25T00:38:16.000Z","updated":"2022-10-26T05:57:15.000Z","comments":true,"path":"article/346f6ed0e474.html","permalink":"https://exusiai.top/article/346f6ed0e474.html","excerpt":"服务器操作指令总结 个人用，写的比较杂碎。","text":"服务器操作指令总结 个人用，写的比较杂碎。 下载服务器文件到本地 scp 用户名@IP:目标文件的地址 下载到本地的路径 scp root@192.168.202.101:&#x2F;data&#x2F;share&#x2F;target.txt &#x2F;Users&#x2F;target.txt # 文件夹使用scp -r即可 查看文件大小 du -h --max-depth&#x3D;1 # 查看当前文件夹目录各个文件大小 du -h --max-depth&#x3D;1&#x2F;path # 查看指定目录 du -h - . # 查看当前目录下所有目录及子目录大小 &#39;.&#39;代表当前目录下。也可以换成一个明确的路径 -h表示用K、M、G的形式显示 更新apt源 刷新软件源信息 sudo apt update 更新软件 sudo apt upgrade 文件压缩 &#x2F;&#x2F; 压缩为zip zip -r fileName.zip 文件夹名 &#x2F;&#x2F;tar命令 单个文件压缩打包 tar czvf my.tar file1 多个文件压缩打包 tar czvf my.tar file1 file2,... 单个目录压缩打包 tar czvf my.tar dir1 多个目录压缩打包 tar czvf my.tar dir1 dir2 解包至当前目录：tar xzvf my.tar","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://exusiai.top/tags/Linux/"}]},{"title":"操作系统PV操作的理解","slug":"操作系统PV操作的理解","date":"2022-10-21T14:08:46.000Z","updated":"2022-10-21T13:57:15.000Z","comments":true,"path":"article/44f6a199d4a4.html","permalink":"https://exusiai.top/article/44f6a199d4a4.html","excerpt":"PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。 并发进程分为两种： ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。 ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。 临界区：并发进程中与共享变量有关的程序段都称为临界区。","text":"PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。 并发进程分为两种： ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。 ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。 临界区：并发进程中与共享变量有关的程序段都称为临界区。 P操作：申请资源操作。 V操作：释放资源操作。 信号量S：用来记录资源数量，看是否能满足申请资源的操作。例如：S=3 表示三个可用空闲资源，S&lt;0表示可用空闲资源无，进程申请要进入等待队列中。 P(S)：S &lt;—— S - 1 ​ 如果S &gt;= 0，进程继续执行 ​ 如果S &lt; 0，进程停止执行，放入信号量等待队列中。 V(S)：S &lt;—— S +1 ​ 如果S &gt; 0，进程继续执行； ​ 如果S &lt;= 0，唤醒等待队列中的一个进程。 例题 应试做题方法： 从左到右、从上到下的将所有信号量标注在前驱图的箭头上，出发点是V操作，结束点是P操作，按照图选择答案即可。 所以易得答案CAA","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://exusiai.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"软件设计师学习笔记","slug":"软件设计师学习笔记","date":"2022-10-18T06:46:29.000Z","updated":"2022-11-08T05:57:15.000Z","comments":true,"path":"article/008c28a5a50a.html","permalink":"https://exusiai.top/article/008c28a5a50a.html","excerpt":"现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 喜报，因为疫情没去考成（悲","text":"现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 喜报，因为疫情没去考成（悲 Flynn分类法 CISC与RISC 流水线（重要） 流程： 取指——分析——执行 流水线周期指所有流程中执行时间最长的一段 流水线吞吐率计算： 流水线的加速比计算： 流水线的效率计算： 计算机层次化存储结构： Catch的基本概念： 除了寄存器外catch是最快的 计算 局部性原理： 主存的分类： 编址 （1）：","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"数据库笔记","slug":"数据库笔记","date":"2022-10-17T02:45:16.000Z","updated":"2022-10-18T13:57:15.000Z","comments":true,"path":"article/468d368bc2e5.html","permalink":"https://exusiai.top/article/468d368bc2e5.html","excerpt":"跟着PHP课程重新记录一下MySQL的笔记","text":"跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名; create database 数据库名 charset&#x3D;字符集; #设定默认字符集 create database 数据库名 default cheoharacter set 字符集; #设定默认字符集 删除数据库 drop database 数据库名; 使用数据库 use 数据库名; 查询当前正在使用的数据库 select database(); 设置数据库字符集 alter database 数据库名 character set 字符集; 2.数据表操作 创建表 create table 表名 (字段名 字段类型 [NOT NULL]); 查询数据库的表格个数 # 第一种写法 show tables from 数据库名; # 第二种写法,如果已经选择了使用的数据库则可以直接 show tables; 修改表名 rename table 旧表名 to 新表名; 查看表格的详细信息 show create table 表名; 查看字段 desc 表名; 插入数据 # 两种写法into都可以省略 insert into 表名 values(数据1, 数据2...) (数据1, 数据2...) # 可同时插入多组数据 insert into 表名 (字段1,字段2...) values (数据1, 数据2...) # 这种写法可以跳过部分字段 查询数据 select 字段1,字段2 from 表名 [where...][limit n][offset m] # LIMIT 属性来设定返回的记录数。 # OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 更新数据 update 表名 set 字段1 &#x3D; 值1,字段2 &#x3D; 值2 [where...] 删除数据 delete from 表名 [where...] 3.筛选条件 去重(distinct) 例：select distinct job from user; # 查询user表中所有不重复的job名 经常使用（count(distinct id)）来返回不重复字段的条数 NULL # 可以在语句中加入is null 和is not null来筛选字段数据 例：select * from user where job is not null; # 查询user表中所有有工作的人的信息 between select * from user where age between 20 and 30; #包含范围两端 in # in运算符允许确定指定的值是否与列表中的值或子查询中的任何值匹配。 也可以搭配not使用 select 字段1,字段2 from 表名 where (expr|column_1) in (值1,值2); as # 设置字段的别名 select 字段名 as &quot;别名&quot; from 表名; # 最完整的写法 as和引号都可以省略 例如: select 字段名 &quot;别名&quot; from 表名; select 字段名 别名 from 表名; like # 匹配的字符串必须加单引号或双引号 # 通配符% 它能代表任何长度的字符串，字符串的长度可以为 0 # 通配符_ 它只能代表单个字符，字符串的长度不能为 0 例:select * from user where name like &#39;王%&#39;; #查询所有以王姓开头的用户 # 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字 例:select * from user where name like binary &#39;t%&#39;; # 这样就不会查询到 T 开头的名字了 tips: 1. % 通配符可以到匹配任意字符，但是不能匹配 NULL。 2. mysql通配符的处理会比其他操作符花费更长的时间,如果其它操作符能达到相同的目的，应该使用其它操作符。 3. 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 4. 如果查询内容中包含通配符，可以使用&quot;\\&quot;转义符。 排序**[ASC|DESC]** select 字段名 from 表名 [where...] order by 字段名 [ASC|DESC]; # ASC代表升序、DESC代表降序 不跟默认升序 # order by 后面可以跟多个条件，例如 order by age, id desc; 分页查询(LIMIT) 格式：limit 偏移量,取出的数据条数 # 偏移量不写默认为0 limit 跳过的条数,请求的条数(每一页的条数) # 跳过的条数 &#x3D; (请求的页数-1) * 请求的条数 tips:分页查询一般和排序组合使用 聚合函数 max, min, avg, sum, count 分组查询(GROUP BY) 格式：group by 分组字段名 HAVING # 和where的区别 having：后面跟聚合函数，可以单独使用 where：后面跟普通字段条件，不能包含聚合函数 4.子查询(嵌套查询) 在SQL语言中，一个 SELECT-FROM-WHERE 语句称为一个查询块。将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。 # 查询工资大于二号部门平均工资的员工信息 select * from emp where sal &gt; (select avg(sal) from emp where dept_id &#x3D; 2); tips: 1.子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。 5.关联查询(同时查询多表) 完善中… 1. 等值连接|笛卡尔积 # 查询工资高于2000的员工姓名和部门名 select emp.name,dept.name from dept, emp where emp.sal &gt; 2000 and emp.dept_id &#x3D; dept.id; 2. 内连接 select 字段1,字段2 from 表名1 join 表名2 on 关联关系 [where...] 3. 外连接 # 外连接有三种：左外连接、右外连接、全外连接，左&#x2F;右外连接没有本质区别 select 字段1,字段2 from 表名1 left&#x2F;right 表名2 on 关联关系 [where...] 6.奇技淫巧 修改正在使用被外键约束的列 # 原本不允许进行修改，因为这个操作违反了外键约束，破坏了数据库完整性。 # 但是万能的mysql提供了一个方法，临时关闭外键约束，当修改完成之后再将外键约束加回来。 SET FOREIGN_KEY_CHECKS &#x3D; 0; ...... ...... SET FOREIGN_KEY_CHECKS &#x3D; 1; SQL语句书写顺序 # 完善中 select 字段 from 表名 where 普通字段条件 group by 分组字段 having 聚合函数条件 order by 排序字段名 limit 跳过的条数，请求的条数","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://exusiai.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Hexo-GitHub搭建教程","slug":"Hexo-Github搭建教程","date":"2022-10-16T07:56:22.000Z","updated":"2024-01-07T09:42:10.469Z","comments":true,"path":"article/4604b40b56ce.html","permalink":"https://exusiai.top/article/4604b40b56ce.html","excerpt":"注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io","text":"注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io 2.本地安装Hexo程序 安装 Node.js ,一路next即可 使用指令npm install -g hexo-cli安装 ,mac用户需要在指令前加上sudo,这一步请耐心等待 在本地新建一个用于存放博客文件的文件夹，例如blog文件夹，在此文件夹进入Git Bash 初始化博客文件并安装组件 hexo init # 初始化 npm install # 安装组件 完成后便可以在本地进行预览了，启动预览后修改文章内容不需要重新生成页面，保持预览即可，hexo会持续监听文件变化。 hexo g # 生成页面 hexo s # 启动预览 在浏览器中输入localhost:4000进行预览，出现Hexo的默认页面则本地博客安装成功！ 如果无法预览则可能是端口被占用，可以找出占用端口的程序并关闭，或者也可以修改Hexo启动的端口,这里改为5000端口 hexo s -p 5000 3.部署 Hexo 到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改_config.yml文件末尾的 Deployment 部分，修改成如下 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 运行hexo d部署网站，成功后便可以在https://用户名.github.io看到自己的博客了 报错记录 Permission denied. You can’t use port 4000. 原因尚未查明，虽然提示的是权限不足，但是切换管理员依旧无法在4000端口跑服务，查看端口占用也没有别的服务在使用4000，修改hexo端口就能正常跑起来，触发时就先暂时先手动指定端口使用。 hexo s -p 5000 突然发现NAT服务可能对端口有影响，所以启停一下NAT就恢复正常了，所以是为什么呢？ 更新中······","categories":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"https://exusiai.top/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://exusiai.top/tags/Hexo/"}]},{"title":"2022年第十三届蓝桥杯省赛个人题解","slug":"2022年第十三届蓝桥杯省赛个人题解","date":"2022-05-09T11:24:22.000Z","updated":"2023-02-03T13:34:06.502Z","comments":true,"path":"article/08de5da3f1ee.html","permalink":"https://exusiai.top/article/08de5da3f1ee.html","excerpt":"A: 九进制转十进制（5分） 题目描述: 九进制正整数 转换成十进制等于多少？ AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; int k = 9; //进制 string num = \"2022\"; //数字 int ans = 0; ll temp = 1; int len = num.size(); for (int i = len - 1; i &gt;= 0; --i) { ans += temp * (num[i] - '0'); temp *= k; } cout &lt;&lt; ans; return 0; }","text":"A: 九进制转十进制（5分） 题目描述: 九进制正整数 转换成十进制等于多少？ AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; int k = 9; //进制 string num = \"2022\"; //数字 int ans = 0; ll temp = 1; int len = num.size(); for (int i = len - 1; i &gt;= 0; --i) { ans += temp * (num[i] - '0'); temp *= k; } cout &lt;&lt; ans; return 0; } B: 顺子日期（5分） 题目描述: 小明特别喜欢顺子。顺子指的就是连续的三个数字：123、456 等。顺子日期指的就是在日期的 yyyymmdd 表示法中，存在任意连续的三位数是一个顺子的日期。例如 20220123 就是一个顺子日期，因为它出现了一个顺子：123；而 20221023 则不是一个顺子日期，它一个顺子也没有。小明想知道在整个 2022 年份中，一共有多少个顺子日期。 思路 不清楚0开头算不算顺子，算的话就是14，不算为4。 C: 刷题统计（10分） 题目描述: 小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天做 道题目，周六和周日每天做 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 题？ 输入格式： 输入一行包含三个整数 和. 输出格式： 输出一个整数代表天数。 输入样例： 10 20 99 输出样例： 8 评测用例规模与约定 对于 50% 的评测用例， 对于 100% 的评测用例， 思路 略 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { IOS; ll a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; ll ans = n / (5 * a + 2 * b) * 7; ll t = ans / 7 * (5 * a + 2 * b); for (int i = 1; i &lt;= 7; i++) { if (t &gt;= n) break; if (i &lt; 6) t += a, ans++; else t += b, ans++; } cout &lt;&lt; ans &lt;&lt; endl; return 0; } D: 修剪灌木（10分） 题目描述: 爱丽丝要完成一项修剪灌木的工作。 有 N 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晚会修剪一棵灌木，让灌木的高度变为 0 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。 灌木每天从早上到傍晚会长高 1 厘米，而其余时间不会长高。在第一天的早晨，所有灌木的高度都是 0 厘米。爱丽丝想知道每棵灌木最高长到多高。 输入格式： 一个正整数 ，含义如题面所述。 输出格式： 输出 行，每行一个整数，第行表示从左到右第 棵树最高能长到多高。 输入样例： 3 输出样例： 4 2 4 评测用例规模与约定 对于 30% 的数据，. 对于 100% 的数据，. 思路 略 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { IOS; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; 2 * max(n - i, i - 1) &lt;&lt; endl; return 0; } E: X 进制减法（15分） 题目描述: 进制规定了数字在数位上逢几进一。 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某 种 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 进制数 转换为十进制数为 。 现在有两个 进制表示的整数 和 ，但是其具体每一数位的进制还不确 定，只知道 和 B 是同一进制规则，且每一数位最高为 进制，最低为二进 制。请你算出 的结果最小可能是多少。 请注意，你需要保证 和 在 进制下都是合法的，即每一数位上的数 字要小于其进制。 输入格式： 第一行一个正整数 ，含义如题面所述。 第二行一个正整数 ，表示 进制数 的位数。 第三行 个用空格分开的整数，表示 进制数 按从高位到低位顺序各 个数位上的数字在十进制下的表示。 第四行一个正整数 ，表示 进制数 的位数。 第五行 个用空格分开的整数，表示 进制数 按从高位到低位顺序各 个数位上的数字在十进制下的表示。 请注意，输入中的所有数字都是十进制的。 输出格式： 输出一行一个整数，表示 进制数 的结果的最小可能值转换为十进 制后再模 的结果。 输入样例： 11 3 10 4 0 3 1 2 0 输出样例： 94 评测用例规模与约定 对于 30% 的数据，. 对于 100% 的数据，. F: 统计子矩阵（15分） 题目描述: 给定一个 的矩阵 A，请你统计有多少个子矩阵 (最小 ，最大 ) 满足子矩阵中所有数的和不超过给定的整数 ? 输入格式： 第一行包含三个整数 和. 之后 行每行包含 个整数，代表矩阵 输出格式： 一个整数代表答案。 输入样例： 3 4 10 1 2 3 4 5 6 7 8 9 10 11 12 输出样例： 19 评测用例规模与约定 对于 30% 的数据，. 对于 70% 的数据，. 对于 100% 的数据，. 思路 先建立二维前缀和数组。 先枚举两条竖着的直线，为矩阵的左边和右边，然后从上到下双指针扫描，把二维问题变成一维问题。即给定一个一维数组，求连续一段区间和小于等于k的区间数量 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; const int N = 510; int a[N][N], b[N][N]; int main() { IOS; int n, m, k; ll ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; a[i][j]; b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j]; } } for (int l = 1; l &lt;= m; l++) //枚举矩阵的左边 { for (int r = l; r &lt;= m; r++) //枚举矩阵的右边 { for (int i = 1, j = 1; i &lt;= n; i++) //有了左右边界，从上到下扫描 { while (j &lt;= i &amp;&amp; (b[i][r] - b[i][l - 1] - b[j - 1][r] + b[j - 1][l - 1]) &gt; k) j++; if (j &lt;= i) //有可能最小的矩阵都不满足，此时j&gt;i ans += (i - j + 1); } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } G: 积木画（20分） 题目描述: 小明最近迷上了积木画，有这么两种类型的积木，分别为 型（大小为 2个单位面积）和 型（大小为 3 个单位面积） 同时，小明有一块面积大小为 的画布，画布由 个 区域构成。小明需要用以上两种积木将画布拼满，他想知道总共有多少种不同的方式？积木可以任意旋转，且画布的方向固定。 输入格式： 输入一个整数 ，表示画布大小。 输出格式： 输出一个整数表示答案。由于答案可能很大，所以输出其对 取模后的值 输入样例： 3 输出样例： 5 评测用例规模与约定 对于所有测试用例，. 思路： 线性DP。 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; const int N = 1e7 + 10; const int mod = 1e9 + 7; ll dp[N][4]; // 1填上面 2填下面 3全填 int main() { int n; cin &gt;&gt; n; dp[0][3] = 1; for (int i = 1; i &lt;= n; i++) { dp[i][1] = (dp[i - 1][2] + dp[i - 2][3]) % mod; dp[i][2] = (dp[i - 1][1] + dp[i - 2][3]) % mod; dp[i][3] = ((dp[i - 1][3] + dp[i - 1][1]) % mod + (dp[i - 1][2] + dp[i - 2][3]) % mod) % mod; //不分开求和会超int，1e7没法用LL } cout &lt;&lt; dp[n][3] % mod; } I: 李白打酒加强版（25分） 题目描述: 话说大诗人李白，一生好饮。幸好他从不开车。 一天，他提着酒壶，从家里出来，酒壶中有酒 2 斗。他边走边唱： 无事街上走，提壶去打酒。逢店加一倍，遇花喝一斗。 这一路上，他一共遇到店 次，遇到花 次。已知最后一次遇到的是花， 他正好把酒喝光了。 请你计算李白这一路遇到店和花的顺序，有多少种不同的可能？ 注意：壶里没酒 ( 0 斗) 时遇店是合法的，加倍后还是没酒；但是没酒时遇 花是不合法的。 输入格式： 第一行包含两个整数 和 . 输出格式： 输出一个整数表示答案。由于答案可能很大，输出模 1000000007 的结果。 输入样例： 5 10 输出样例： 14 评测用例规模与约定 对于 40% 的评测用例：。 对于 100% 的评测用例：。 思路 一眼dp，dp方案为 如果最后一步是到店，那么j应该大于0，因为至少有最后一步到店，到花同理， 如果最后一步是到店，那么上一步手里有的酒应该是k / 2，也是因此我们的k应该整除于2 如果最后一步是到花，那么上一步手里有的酒应该是k + 1。 打印答案的时候不是打印 dp[n][m][0] ,因为这么打印是无法区分最后是到花还是到店， 所以往前推一步，如果最后到花，那么喝完的上一步应该是dp[n - 1][m][1]。 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; const int mod = 1e9 + 7; const int N = 110; int dp[N][N][N]; //三维分别为店、花、酒 int main() { IOS; int n, m; cin &gt;&gt; n &gt;&gt; m; dp[0][0][2] = 1; //初始状态 for (int i = 0; i &lt;= n; i++) { for (int j = 0; j &lt;= m; j++) { for (int k = 0; k &lt;= m; k++) { if (i &amp;&amp; k % 2 == 0) dp[i][j][k] += dp[i - 1][j][k / 2] % mod; //遇到店 if (j) dp[i][j][k] += dp[i][j - 1][k + 1] % mod; //遇到花 } } } cout &lt;&lt; dp[n][m - 1][1] &lt;&lt; endl; //最后遇到的一个一定是花 return 0; }","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://exusiai.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1526B","slug":"CF1526B","date":"2022-05-07T14:18:59.000Z","updated":"2023-01-06T14:54:54.316Z","comments":true,"path":"article/fa6d9139e2d8.html","permalink":"https://exusiai.top/article/fa6d9139e2d8.html","excerpt":"传送门：CF1526B 题目描述 给你一个数x，问你这个数能不能被11,111,1111，……（最少两个1）此类数字构成。（比如33=11+11+11,144=111+11+11+11） 输入格式： 第一行一个正整数T（(1≤T≤10000)）表示案例数，接下来每行一个正整数x(1≤x≤10^9) 输出格式： 对于每一行的x，如果能满足题意，输出“YES”，否则输出“NO”。 输入样例：","text":"传送门：CF1526B 题目描述 给你一个数x，问你这个数能不能被11,111,1111，……（最少两个1）此类数字构成。（比如33=11+11+11,144=111+11+11+11） 输入格式： 第一行一个正整数T（(1≤T≤10000)）表示案例数，接下来每行一个正整数x(1≤x≤10^9) 输出格式： 对于每一行的x，如果能满足题意，输出“YES”，否则输出“NO”。 输入样例： 4 33 144 121 69 输出样例： YES YES YES NO 思路 因为1111，11111,111111等都可以由11，111组成，所以只用看该数字能不能用11，111组成即可。 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) using namespace std; int main() &#123; int n, a; cin &gt;&gt; n; for (int i &#x3D; 0; i &lt; n; i++) &#123; cin &gt;&gt; a; int cot &#x3D; a &#x2F; 111; if (a % 11 &lt;&#x3D; cot) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0; &#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://exusiai.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-05-05T13:55:34.000Z","updated":"2023-02-03T13:34:12.208Z","comments":true,"path":"article/fbadbb2e4f2e.html","permalink":"https://exusiai.top/article/fbadbb2e4f2e.html","excerpt":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足或。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力","text":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足或。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力 模板 bool isprime(int n) { if (n == 1) return false; else if (n == 2 || n == 3) return true; //不满足六倍原理，一定不是素数 else if (n % 6 != 1 &amp;&amp; n % 6 != 5) return false; //只判断6倍的邻数 for (int i = 5; i &lt;= sqrt(n); i += 6) { if (n % i == 0 || n % (i + 2) == 0) return false; } return true; } 埃氏筛法 原理：要得到自然数以内的全部素数，必须把不大于根号的所有素数的倍数剔除，剩下的就是素数。 时间复杂度： 有的写法内层循环不同时间复杂度可能是 模板 bool is_prime[1000]; //标记是否是素数 for (int i = 0; i &lt;= n; i++) is_prime[i] = true; //初始化所有的数为素数 is_prime[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) { //从第一个素数2开始筛选 if (is_prime[i]) { //如果是素数 for (int j = i * i; j &lt;= n; j += i) //一个小优化，从i * i开始而不是从 i + i开始 { //则剔除掉它的倍数 is_prime[j] = false; } } } 欧拉筛法（线性筛） 原理：使用埃式筛法时，同一个数字会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多的时间。欧拉筛正是埃式筛的优化。即让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 时间复杂度： 模板 //求小于等于n的素数的个数，并输出每个素数 #include &lt;cstring&gt; #include &lt;iostream&gt; using namespace std; const int N = 1e5; int prime[N]; //存素数 bool vis[N]; //保证不做素数的倍数 int main() { int n, cnt = 0; cin &gt;&gt; n; memset(vis, false, sizeof(vis)); //初始化 memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= n; i++) { if (!vis[i]) //未被标记 prime[cnt++] = i; //则找到素数 for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; j++) { vis[i * prime[j]] = true; //标记找到的素数的倍数 if (i % prime[j] == 0) break; //线性的关键！！ } } cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) cout &lt;&lt; prime[i] &lt;&lt; \" \"; //输出每个素数 return 0; } 个人学习记录，非教程，所以不太注重以上算法原理的解释","categories":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"2022天梯赛个人题解","slug":"2022天梯赛个人题解","date":"2022-04-26T06:26:37.000Z","updated":"2023-02-03T13:33:00.423Z","comments":true,"path":"article/151fa4fba518.html","permalink":"https://exusiai.top/article/151fa4fba518.html","excerpt":"L1-1 今天我要赢(5分) 题目描述 2018 年我们曾经出过一题，是输出“2018 我们要赢”。今年是 2022 年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。 输入格式： 本题没有输入。 输出格式： 输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用 年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是 2022-04-22。 输入样例：","text":"L1-1 今天我要赢(5分) 题目描述 2018 年我们曾经出过一题，是输出“2018 我们要赢”。今年是 2022 年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。 输入格式： 本题没有输入。 输出格式： 输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用 年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是 2022-04-22。 输入样例： 无 输出样例（第二行的内容要你自己想一想，这里不给出）： I’m gonna win! Today! 这一行的内容我不告诉你…… 你要自己输出正确的日期呀~ 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; cout &lt;&lt; \"I'm gonna win! Today!\" &lt;&lt; endl; cout &lt;&lt; \"2022-04-23\"; return 0; } L1-2 种钻石(5分) 题目描述 2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗 1 克拉大小的钻石。 本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。 输入格式： 输入在一行中给出钻石的需求量 （不超过 的正整数，以微克拉为单位）和人工培育钻石的速度 （，以微克拉/天为单位的整数）。 输出格式： 在一行中输出培育 微克拉钻石需要的整数天数。不到一天的时间不算在内。 输入样例： 102000 130 输出样例： 784 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;cstring&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;cmath&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { //IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a / b; return 0; } L1-3 谁能进图书馆(10分) 题目描述 为了保障安静的阅读环境，有些公共图书馆对儿童入馆做出了限制。例如“12 岁以下儿童禁止入馆，除非有 18 岁以上（包括 18 岁）的成人陪同”。现在有两位小/大朋友跑来问你，他们能不能进去？请你写个程序自动给他们一个回复。 输入格式： 输入在一行中给出 4 个整数： 禁入年龄线 陪同年龄线 询问者1的年龄 询问者2的年龄 这里的禁入年龄线是指严格小于该年龄的儿童禁止入馆；陪同年龄线是指大于等于该年龄的人士可以陪同儿童入馆。默认两个询问者的编号依次分别为 1 和 2；年龄和年龄线都是 [1, 200] 区间内的整数，并且保证 陪同年龄线 严格大于 禁入年龄线。 输出格式： 在一行中输出对两位询问者的回答，如果可以进就输出 年龄-Y，否则输出 年龄-N，中间空 1 格，行首尾不得有多余空格。 在第二行根据两个询问者的情况输出一句话： 如果两个人必须一起进，则输出 qing X zhao gu hao Y，其中 X 是陪同人的编号， Y 是小孩子的编号； 如果两个人都可以进但不是必须一起的，则输出 huan ying ru guan； 如果两个人都进不去，则输出 zhang da zai lai ba； 如果一个人能进一个不能，则输出 X: huan ying ru guan，其中 X 是可以入馆的那个人的编号。 输入样例1： 12 18 18 8 输出样例1： 18-Y 8-Y qing 1 zhao gu hao 2 输入样例 2： 12 18 10 15 输出样例 2： 10-N 15-Y 2: huan ying ru guan 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; int y1, y2, a, b; cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; a &gt;&gt; b; if (a &gt; b) { if (b &gt;= y1) { cout &lt;&lt; a &lt;&lt; \"-Y \" &lt;&lt; b &lt;&lt; \"-Y\" &lt;&lt; endl; cout &lt;&lt; \"huan ying ru guan\" &lt;&lt; endl; } else if (b &lt; y1 &amp;&amp; a &gt;= y2) { cout &lt;&lt; a &lt;&lt; \"-Y \" &lt;&lt; b &lt;&lt; \"-Y\" &lt;&lt; endl; cout &lt;&lt; \"qing 1 zhao gu hao 2\" &lt;&lt; endl; } else if (a &lt; y1) { cout &lt;&lt; a &lt;&lt; \"-N \" &lt;&lt; b &lt;&lt; \"-N\" &lt;&lt; endl; cout &lt;&lt; \"zhang da zai lai ba\" &lt;&lt; endl; } else if (b &lt; y1 &amp;&amp; a &lt; y2) { cout &lt;&lt; a &lt;&lt; \"-Y \" &lt;&lt; b &lt;&lt; \"-N\" &lt;&lt; endl; cout &lt;&lt; \"1: huan ying ru guan\" &lt;&lt; endl; } } else { if (a &gt;= y1) { cout &lt;&lt; a &lt;&lt; \"-Y \" &lt;&lt; b &lt;&lt; \"-Y\" &lt;&lt; endl; cout &lt;&lt; \"huan ying ru guan\" &lt;&lt; endl; } else if (a &lt; y1 &amp;&amp; b &gt;= y2) { cout &lt;&lt; a &lt;&lt; \"-Y \" &lt;&lt; b &lt;&lt; \"-Y\" &lt;&lt; endl; cout &lt;&lt; \"qing 2 zhao gu hao 1\" &lt;&lt; endl; } else if (b &lt; y1) { cout &lt;&lt; a &lt;&lt; \"-N \" &lt;&lt; b &lt;&lt; \"-N\" &lt;&lt; endl; cout &lt;&lt; \"zhang da zai lai ba\" &lt;&lt; endl; } else if (a &lt; y1 &amp;&amp; b &lt; y2) { cout &lt;&lt; a &lt;&lt; \"-N \" &lt;&lt; b &lt;&lt; \"-Y\" &lt;&lt; endl; cout &lt;&lt; \"2: huan ying ru guan\" &lt;&lt; endl; } } return 0; } L1-4 拯救外星人(10分) 题目描述 你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 的阶乘记为 “”，是从到 的连乘积。所以当他不知道“”等于多少时，如果你告诉他等于“”，他就写出了“”这个答案。 本题就请你写程序模仿外星人的行为。 输入格式： 输入在一行中给出两个正整数 和 。 输出格式： 在一行中输出 的阶乘。题目保证 的值小于 。 输入样例： 3 6 输出样例： 362880 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; int sum = 1; for (int i = 2; i &lt;= a + b; i++) sum *= i; cout &lt;&lt; sum; return 0; } L1-5 试试手气(15分) 题目描述 我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件： 1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同； 2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。 那么你应该可以预知自己第 次（）摇出的结果。 输入格式： 输入第一行给出 个骰子的初始点数，即 之间的整数，数字间以空格分隔；第二行给出摇的次数 （）。 输出格式： 在一行中顺序列出第 次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。 输入样例： 3 6 5 4 1 4 3 输出样例： 4 3 3 3 4 3 分析 可以硬模拟，也可以用数学推一推，但是模拟太好写了就直接无脑模了。 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int a[7], b[7]; int main() { // IOS; for (int i = 1; i &lt;= 6; i++) { cin &gt;&gt; a[i]; b[i] = a[i];//记录原始状态 if (a[i] != 6) a[i] = 6; else a[i] = 5; } int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) for (int i = 1; i &lt;= 6; i++) { a[i]--; if (a[i] == b[i]) a[i]--; } for (int i = 1; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; \" \";//万恶的格式控制 cout &lt;&lt; a[6]; return 0; } L1-6 斯德哥尔摩火车上的题(15分) 题目描述 上图是新浪微博上的一则趣闻，是瑞典斯德哥尔摩火车上的一道题，看上去是段伪代码： s = ‘’ a = ‘1112031584’ for (i = 1; i &lt; length(a); i++) { if (a[i] % 2 == a[i-1] % 2) { s += max(a[i], a[i-1]) } } goto_url(‘www.multisoft.se/’ + s) 其中字符串的 + 操作是连接两个字符串的意思。所以这道题其实是让大家访问网站 www.multisoft.se/112358（注意：比赛中千万不要访问这个网址！！！）。 当然，能通过上述算法得到 112358 的原始字符串 a 是不唯一的。本题就请你判断，两个给定的原始字符串，能否通过上述算法得到相同的输出？ 输入样例 1： 1112031584 011102315849 输出样例 1： 112358 输入样例 2： 111203158412334 12341112031584 输出样例 2： 1123583 112358 分析 字符串处理题，伪代码都给出来了，属于是送分。 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int main() { // IOS; string s1 = \"\", s2 = \"\"; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt; a.size(); i++) if (a[i] % 2 == a[i - 1] % 2) s1 += max(a[i], a[i - 1]); for (int i = 1; i &lt; b.size(); i++) if (b[i] % 2 == b[i - 1] % 2) s2 += max(b[i], b[i - 1]); if(s1 == s2) cout &lt;&lt; s1; else cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2; return 0; } L1-7 机工士姆斯塔迪奥(20分) 题目描述 在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS 机工士姆斯塔迪奥将会接受玩家的挑战。 你需要处理这个副本其中的一个机制： 大小的地图被拆分为了 个 的格子，BOSS 会选择若干行或/及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。 给定 BOSS 所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。 输入格式: 输入第一行是三个整数 ，，表示地图为 行 列大小以及选择的行/列数量。 接下来 行，每行两个数 ,，其中 表示 BOSS 选择的是一整行， 表示选择的是整列，为选择的行号/列号。行和列的编号均从 开始。 输出格式: 输出一个数，表示安全格子的数量。 输入样例: 5 5 3 0 2 0 4 1 3 输出样例: 12 分析 很简单的题意，主要坑点就是有可能BOSS技能的位置会有重复输入，重复的数据不处理就好 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; const int N = 1e5 + 10; int vis[2][N]; int main() { IOS; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int t, c; while (q--) { cin &gt;&gt; t &gt;&gt; c; if (!vis[t][c]) //第一次遇见才处理 { vis[t][c] = 1; if (t) m--; else n--; } } cout &lt;&lt; n * m; return 0; } L1-8 静静的推荐(20分) 题目描述 天梯赛结束后，某企业的人力资源部希望组委会能推荐一批优秀的学生，这个整理推荐名单的任务就由静静姐负责。企业接受推荐的流程是这样的： 只考虑得分不低于 175 分的学生； 一共接受 批次的推荐名单； 同一批推荐名单上的学生的成绩原则上应严格递增； 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 给定全体参赛学生的成绩和他们的 PAT 考试成绩，请你帮静静姐算一算，她最多能向企业推荐多少学生？ 输入格式： 输入第一行给出 3 个正整数：（）为参赛学生人数，（）为企业接受的推荐批次，（）为该企业的 PAT 面试分数线。 随后 行，每行给出两个分数，依次为一位学生的天梯赛分数（最高分 290）和 PAT 分数（最高分 100）。 输出格式： 在一行中输出静静姐最多能向企业推荐的学生人数。 输入样例： 10 2 90 203 0 169 91 175 88 175 0 175 90 189 0 189 0 189 95 189 89 256 100 输出样例： 8 样例解释： 第一批可以选择 175、189、203、256 这四个分数的学生各一名，此外 175 分 PAT 分数达到 90 分的学生和 189 分 PAT 分数达到 95 分的学生可以额外进入名单。第二批就只剩下 175、189 两个分数的学生各一名可以进入名单了。最终一共 8 人进入推荐名单。 分析 很有意思的一个题，第一次做这个题很容易纠结在 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 ”这句话里面的与前一个人相同，可能会不断扫描所有学生，写出一个模拟来判断前一个人的分数。可事实上这个人是哪个人并不重要，问的是人数，又没问推哪个人。 那么其实就可以将175~290的每个分数映射到数组下标，然后从175一直遍历到290。其中有个小细节就是如果天梯赛满足175并且PTA也达到了企业的要求，那么其实这一批人就可以全部跟着上一个分数相同但是PTA不达标的人一起进入同一个推荐名单。 如果样例数据是这样的 175 0 175 90 175 91 175 92 175 93 这批五个175分的学生其实就可以在同一个推荐名单里面 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int stu[300]; int pta[300]; int main() { IOS; int n, k, s; //人数，批次，分数线 cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int a, b; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a &gt;&gt; b; if (a &gt;= 175) //天梯赛175以上是硬性规定，不满足的可以不用考虑 { stu[a]++; //天梯赛分数为a的学生人数+1 if (b &gt;= s) pta[a]++; //可以特招的天梯赛分数为a的学生人数+1 } } int ans = 0; for (int i = 175; i &lt;= 290; i++) { if (stu[i]) { ans += pta[i]; //特招是一定可以全部推荐走的 stu[i] -= pta[i]; if (stu[i]) //如果还剩下的有天梯赛到175分而PTA不到企业规定分数的，则只能按照K个批次来推荐 ans += min(stu[i], k); //所以ans再次加上可以推荐的人数 } } cout &lt;&lt; ans &lt;&lt; endl; return 0; } L2-1 插松枝(25分) 题目描述 人造松枝加工场的工人需要将各种尺寸的塑料松针插到松枝干上，做成大大小小的松枝。他们的工作流程（并不）是这样的： 每人手边有一只小盒子，初始状态为空。 每人面前有用不完的松枝干和一个推送器，每次推送一片随机型号的松针片。 工人首先捡起一根空的松枝干，从小盒子里摸出最上面的一片松针 —— 如果小盒子是空的，就从推送器上取一片松针。将这片松针插到枝干的最下面。 工人在插后面的松针时，需要保证，每一步插到一根非空松枝干上的松针片，不能比前一步插上的松针片大。如果小盒子中最上面的松针满足要求，就取之插好；否则去推送器上取一片。如果推送器上拿到的仍然不满足要求，就把拿到的这片堆放到小盒子里，继续去推送器上取下一片。注意这里假设小盒子里的松针片是按放入的顺序堆叠起来的，工人每次只能取出最上面（即最后放入）的一片。 当下列三种情况之一发生时，工人会结束手里的松枝制作，开始做下一个： （1）小盒子已经满了，但推送器上取到的松针仍然不满足要求。此时将手中的松枝放到成品篮里，推送器上取到的松针压回推送器，开始下一根松枝的制作。 （2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。此时将手中的松枝放到成品篮里，开始下一根松枝的制作。 （3）手中的松枝干上已经插满了松针，将之放到成品篮里，开始下一根松枝的制作。 现在给定推送器上顺序传过来的 片松针的大小，以及小盒子和松枝的容量，请你编写程序自动列出每根成品松枝的信息。 输入格式： 输入在第一行中给出 个正整数：（），为推送器上松针片的数量；（）为小盒子能存放的松针片的最大数量；（）为一根松枝干上能插的松针片的最大数量。 随后一行给出 个不超过 的正整数，为推送器上顺序推出的松针片的大小。 输出格式： 每支松枝成品的信息占一行，顺序给出自底向上每片松针的大小。数字间以 个空格分隔，行首尾不得有多余空格。 输入样例： 8 3 4 20 25 15 18 20 18 8 5 输出样例： 20 15 20 18 18 8 25 5 分析 开两个容器硬模拟推送器和小盒子，注意一下条件不然可能出现段错误 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; queue&lt;int&gt; que; //推送器 stack&lt;int&gt; st; //盒子 int main() { int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) { int x; cin &gt;&gt; x; que.push(x); } while (que.size() || st.size()) { vector&lt;int&gt; ans; int s; if (!st.empty()) { s = st.top(); st.pop(); ans.push_back(s); } else if (!que.empty()) { s = que.front(); que.pop(); ans.push_back(s); } while (true) { if (!st.empty() &amp;&amp; st.top() &lt;= ans.back()) { s = st.top(); st.pop(); ans.push_back(s); } else if (!que.empty() &amp;&amp; que.front() &lt;= ans.back()) { s = que.front(); que.pop(); ans.push_back(s); } else if (!st.empty() &amp;&amp; st.top() &gt; ans.back() &amp;&amp; que.empty()) break; else if (st.size() &lt; m &amp;&amp; que.front() &gt; ans.back()) { s = que.front(); que.pop(); st.push(s); } else if (st.size() == m &amp;&amp; que.front() &gt; ans.back()) break; if (que.empty() &amp;&amp; st.empty()) break; else if (ans.size() == k) break; } cout &lt;&lt; ans[0]; //又是我最讨厌的控制格式 for (int t1 = 1; t1 &lt; ans.size(); t1++) cout &lt;&lt; \" \" &lt;&lt; ans[t1]; cout &lt;&lt; endl; } return 0; } L2-2 老板的作息表(25分) 题目描述 新浪微博上有人发了某老板的作息时间表，表示其每天 4:30 就起床了。但立刻有眼尖的网友问：这时间表不完整啊，早上九点到下午一点干啥了？ 本题就请你编写程序，检查任意一张时间表，找出其中没写出来的时间段。 输入格式： 输入第一行给出一个正整数 ，为作息表上列出的时间段的个数。随后 行，每行给出一个时间段，格式为： hh:mm:ss - hh:mm:ss 其中 hh、mm、ss 分别是两位数表示的小时、分钟、秒。第一个时间是开始时间，第二个是结束时间。题目保证所有时间都在一天之内（即从 00:00:00 到 23:59:59）；每个区间间隔至少 1 秒；并且任意两个给出的时间区间最多只在一个端点有重合，没有区间重叠的情况。 输出格式： 按照时间顺序列出时间表中没有出现的区间，每个区间占一行，格式与输入相同。题目保证至少存在一个区间需要输出。 输入样例： 8 13:00:00 - 18:00:00 00:00:00 - 01:00:05 08:00:00 - 09:00:00 07:10:59 - 08:00:00 01:00:05 - 04:30:00 06:30:00 - 07:10:58 05:30:00 - 06:30:00 18:00:00 - 19:00:00 输出样例： 04:30:00 - 05:30:00 07:10:58 - 07:10:59 09:00:00 - 13:00:00 19:00:00 - 23:59:59 分析 考点很简单就是排序（但是我第一反应是一个不需要排序的邪道写法最后还A了 ） 将所有的时间存起来然后排序再扫描一遍即可，排序可以手写重载也可以用vector的默认排序，数据量大建议手写，容器自带的排序还是慢了点。 代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; string s[100000]; //没给范围第一次数组开小了一直段错误超 bool cmp(string a, string b) { for (int i = 0; i &lt; a.size(); i++) { if (a[i] != b[i]) return a[i] &lt; b[i]; } } int main() { // IOS; int n; cin &gt;&gt; n; cin.get(); for (int i = 0; i &lt; n; i++) getline(cin, s[i]); sort(s, s + n, cmp); string temp = \"00:00:00\"; for (int i = 0; i &lt; n; i++) { if (temp != s[i].substr(0, 8)) cout &lt;&lt; temp &lt;&lt; \" - \" &lt;&lt; s[i].substr(0, 8) &lt;&lt; endl; temp = s[i].substr(11, 8); } if (temp != \"23:59:59\") cout &lt;&lt; temp &lt;&lt; \" - 23:59:59\" &lt;&lt; endl; return 0; } 剩下有空了再摸","categories":[{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://exusiai.top/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"二分总结","slug":"二分总结","date":"2022-01-07T09:31:37.000Z","updated":"2022-01-08T05:57:15.000Z","comments":true,"path":"article/a1bbfb3e34b5.html","permalink":"https://exusiai.top/article/a1bbfb3e34b5.html","excerpt":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; }","text":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } 为什么需要补上一个呢？ 因为整数的除法是向下取整，我们需要在运算时+1时它变成向上取整，否则的话会因为边界问题导致while无限循环。 举个例子，在区间只有两个数的时候，比如，，，这时候如果check成功，那么会执行，然后问题就来了，和本来就都等于3，然后就会无限循环下去，和的值永远不会更新。所以在的更新方式下，我们需要将运算时成为向上取整才不会死循环。 第二种 这种情况代码如下 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; } 为什么在这里不需要补上一个呢？ 因为边界问题不会影响到值的更新，还是用上面那个例子，，，。 此时如果check成功，那么，更新成功。如果check失败，则，同样更新成功。由此可以看出，在的更新方式下，不需要对进行任何操作。 以上是整数二分的两种固定写法。那么什么时候用哪种方法呢，这就要根据具体的题目进行分析了。 例题—— 分巧克力 题目描述 儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 和 。 输入保证每位小朋友至少能获得一块 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 输入输出样例 输入#1 2 10 6 5 5 6 输出#1 2 AC代码 #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;queue&gt; #include &lt;stack&gt; typedef long long ll; #define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define max(a, b) (a &gt; b ? a : b) #define min(a, b) (a &lt; b ? a : b) #define endl '\\n' using namespace std; int n, k; const int N = 1e5 + 10; int h[N], w[N]; bool check(int x) { int cnt = 0; for (int i = 0; i &lt; n; i++) { cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; } return false; } int main() { IOS; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i] &gt;&gt; w[i]; int l = 0, r = N; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; return 0; } 题目很简单是二分的板子题，主要是说为什么要用第一种求方法呢。 为什么二分里面不能写成 int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; //这样写跑样例答案是3 else r = mid; 推导一遍发现，如果成立后，说明当前的值也是在答案范围中，所以答案只能在之中取。理所当然无法用上面那种写法，如果用上面那种方法，会直接更新成，会越过这个值，所以在一些情况就会出现错误，比如题面的样例就会成为，越过了这个可能的答案值，恰好就是最大的一个答案，导致答案错误。 总结 这次弄明白了二分的写法属实是不易，留文一篇防止日后遗忘 以后写二分的时候记得注意一下区间情况","categories":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/categories/%E7%AE%97%E6%B3%95/"},{"name":"教程","slug":"教程","permalink":"https://exusiai.top/categories/%E6%95%99%E7%A8%8B/"},{"name":"碎碎念","slug":"碎碎念","permalink":"https://exusiai.top/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"},{"name":"学习","slug":"学习","permalink":"https://exusiai.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://exusiai.top/tags/%E7%AE%97%E6%B3%95/"},{"name":"Git","slug":"Git","permalink":"https://exusiai.top/tags/Git/"},{"name":"hexo","slug":"hexo","permalink":"https://exusiai.top/tags/hexo/"},{"name":"node","slug":"node","permalink":"https://exusiai.top/tags/node/"},{"name":"Linux","slug":"Linux","permalink":"https://exusiai.top/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"https://exusiai.top/tags/%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"https://exusiai.top/tags/Hexo/"},{"name":"题解","slug":"题解","permalink":"https://exusiai.top/tags/%E9%A2%98%E8%A7%A3/"},{"name":"操作系统","slug":"操作系统","permalink":"https://exusiai.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://exusiai.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"GitHub","slug":"GitHub","permalink":"https://exusiai.top/tags/GitHub/"}]}
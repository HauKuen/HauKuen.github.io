{"meta":{"title":"时砾逐光","subtitle":"愿前路无止境","description":"个人博客","author":"Hiroshi","url":"http://example.com","root":"/"},"pages":[{"title":"Repositories","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-10-15T11:13:46.452Z","updated":"2022-10-15T11:13:46.452Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"软件设计师学习笔记 一","slug":"软件设计师学习笔记 一","date":"2022-10-18T06:46:29.000Z","updated":"2022-10-19T06:01:25.436Z","comments":true,"path":"2022/10/18/软件设计师学习笔记 一/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E4%B8%80/","excerpt":"","text":"#现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 Flynn分类法 CISC与RISC 流水线（重要） 流程： 取指——分析——执行 流水线周期指所有流程中执行时间最长的一段 流水线吞吐率计算： 流水线的加速比计算： 流水线的效率计算： 计算机层次化存储结构： Catch的基本概念： 除了寄存器外catch是最快的 计算 局部性原理： 主存的分类： 编址 （1）：","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据库笔记","slug":"数据库笔记","date":"2022-10-17T02:45:16.000Z","updated":"2022-10-20T04:15:34.327Z","comments":true,"path":"2022/10/17/数据库笔记/","link":"","permalink":"http://example.com/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"","text":"# 跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名;create database 数据库名 charset=字符集; #设定默认字符集create database 数据库名 default cheoharacter set 字符集; #设定默认字符集 删除数据库 drop database 数据库名; 使用数据库 use 数据库名; 查询当前正在使用的数据库 select database(); 设置数据库字符集 alter database 数据库名 character set 字符集; 2.数据表操作 创建表 create table 表名 (字段名 字段类型 [NOT NULL]); 查询数据库的表格个数 # 第一种写法show tables from 数据库名;# 第二种写法,如果已经选择了使用的数据库则可以直接show tables; 修改表名 rename table 旧表名 to 新表名; 查看表格的详细信息 show create table 表名; 查看字段 desc 表名; 插入数据 # 两种写法into都可以省略insert into 表名 values(数据1, 数据2...) (数据1, 数据2...) # 可同时插入多组数据insert into 表名 (字段1,字段2...) values (数据1, 数据2...) # 这种写法可以跳过部分字段 查询数据 select 字段1,字段2 from 表名 [where...][limit n][offset m]# LIMIT 属性来设定返回的记录数。# OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 更新数据 update 表名 set 字段1 = 值1,字段2 = 值2 [where...] 删除数据 delete from 表名 [where...] 3.筛选条件 去重(distinct) 例：select distinct job from user; # 查询user表中所有不重复的job名经常使用（count(distinct id)）来返回不重复字段的条数 NULL # 可以在语句中加入is null 和is not null来筛选字段数据例：select * from user where job is not null; # 查询user表中所有有工作的人的信息 between select * from user where age between 20 and 30; #包含范围两端 in # in运算符允许确定指定的值是否与列表中的值或子查询中的任何值匹配。 也可以搭配not使用select 字段1,字段2 from 表名 where (expr|column_1) in (值1,值2); as # 设置字段的别名select 字段名 as &quot;别名&quot; from 表名; # 最完整的写法 as和引号都可以省略例如:select 字段名 &quot;别名&quot; from 表名;select 字段名 别名 from 表名; like # 匹配的字符串必须加单引号或双引号# 通配符% 它能代表任何长度的字符串，字符串的长度可以为 0# 通配符_ 它只能代表单个字符，字符串的长度不能为 0例:select * from user where name like &#x27;王%&#x27;; #查询所有以王姓开头的用户# 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字例:select * from user where name like binary &#x27;t%&#x27;;# 这样就不会查询到 T 开头的名字了tips:1. % 通配符可以到匹配任意字符，但是不能匹配 NULL。2. mysql通配符的处理会比其他操作符花费更长的时间,如果其它操作符能达到相同的目的，应该使用其它操作符。3. 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。4. 如果查询内容中包含通配符，可以使用&quot;\\&quot;转义符。 排序**[ASC|DESC]** select 字段名 from 表名 [where...] order by 字段名 [ASC|DESC];# ASC代表升序、DESC代表降序 不跟默认升序# order by 后面可以跟多个条件，例如 order by age, id desc; 分页查询(LIMIT) 格式：limit 偏移量,取出的数据条数 # 偏移量不写默认为0limit 跳过的条数,请求的条数(每一页的条数) # 跳过的条数 = (请求的页数-1) * 请求的条数tips:分页查询一般和排序组合使用 聚合函数 max, min, avg, sum, count 分组查询(GROUP BY) 格式：group by 分组字段名 HAVING # 和where的区别having：后面跟聚合函数，可以单独使用where：后面跟普通字段条件，不能包含聚合函数 4.子查询(嵌套查询) 在SQL语言中，一个 SELECT-FROM-WHERE 语句称为一个查询块。将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。 # 查询工资大于二号部门平均工资的员工信息select * from emp where sal &gt; (select avg(sal) from emp where dept_id = 2);tips:1.子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。 5.关联查询(同时查询多表) 完善中… 1. 等值连接|笛卡尔积# 查询工资高于2000的员工姓名和部门名select emp.name,dept.name from dept, emp where emp.sal &gt; 2000 and emp.dept_id = dept.id;2. 内连接select 字段1,字段2 from 表名1 join 表名2 on 关联关系 [where...]3. 外连接# 外连接有三种：左外连接、右外连接、全外连接，左/右外连接没有本质区别select 字段1,字段2 from 表名1 left/right 表名2 on 关联关系 [where...] 6.奇技淫巧 修改正在使用被外键约束的列 # 原本不允许进行修改，因为这个操作违反了外键约束，破坏了数据库完整性。# 但是万能的mysql提供了一个方法，临时关闭外键约束，当修改完成之后再将外键约束加回来。 SET FOREIGN_KEY_CHECKS = 0;............SET FOREIGN_KEY_CHECKS = 1; SQL语句书写顺序 # 完善中select 字段 from 表名 where 普通字段条件 group by 分组字段 having 聚合函数条件 order by 排序字段名 limit 跳过的条数，请求的条数","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo-GitHub搭建教程","slug":"Hexo-Github搭建教程","date":"2022-10-16T07:56:22.000Z","updated":"2022-10-19T06:18:19.489Z","comments":true,"path":"2022/10/16/Hexo-Github搭建教程/","link":"","permalink":"http://example.com/2022/10/16/Hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"","text":"#注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io 2.本地安装Hexo程序 安装Node.js,一路next即可 Node.js：https://nodejs.org/zh-cn 使用指令npm install -g hexo-cli安装 ,mac用户需要在指令前加上sudo,这一步请耐心等待 在本地新建一个用于存放博客文件的文件夹，例如blog文件夹，在此文件夹进入Git Bash 初始化博客文件并安装组件 hexo init # 初始化npm install # 安装组件 完成后便可以在本地进行预览了（输入指令后不要关闭窗口） hexo g # 生成页面 hexo s # 启动预览 在浏览器中输入localhost:4000进行预览，出现Hexo的默认页面则本地博客安装成功！ 如果无法预览则可能是端口被占用，可以找出占用端口的程序并关闭，或者也可以修改Hexo启动的端口,这里改为5000端口 hexo s -p 5000 3.部署 Hexo 到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改_config.yml文件末尾的 Deployment 部分，修改成如下 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 运行hexo d部署网站，成功后便可以在https://用户名.github.io看到自己的博客了 更新中······","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-05-05T13:55:34.000Z","updated":"2022-10-19T06:14:53.168Z","comments":true,"path":"2022/05/05/素数筛/","link":"","permalink":"http://example.com/2022/05/05/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"","text":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足$6n+1$或$6n-1$。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力 模板 bool isprime(int n)&#123; if (n == 1) return false; else if (n == 2 || n == 3) return true; //不满足六倍原理，一定不是素数 else if (n % 6 != 1 &amp;&amp; n % 6 != 5) return false; //只判断6倍的邻数 for (int i = 5; i &lt;= sqrt(n); i += 6) &#123; if (n % i == 0 || n % (i + 2) == 0) return false; &#125; return true;&#125; 埃氏筛法 原理：要得到自然数$n$以内的全部素数，必须把不大于根号$n$的所有素数的倍数剔除，剩下的就是素数。 时间复杂度：$O(nlog(logn))$ 有的写法内层循环不同时间复杂度可能是$O(nlogn)$ 模板 bool is_prime[1000]; //标记是否是素数for (int i = 0; i &lt;= n; i++) is_prime[i] = true; //初始化所有的数为素数 is_prime[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; //从第一个素数2开始筛选 if (is_prime[i]) &#123; //如果是素数 for (int j = i * i; j &lt;= n; j += i) //一个小优化，从i * i开始而不是从 i + i开始 &#123; //则剔除掉它的倍数 is_prime[j] = false; &#125; &#125; &#125; 欧拉筛法（线性筛） 原理：使用埃式筛法时，同一个数字会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多的时间。欧拉筛正是埃式筛的优化。即让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 时间复杂度：$O(n)$ 模板 //求小于等于n的素数的个数，并输出每个素数#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5;int prime[N]; //存素数bool vis[N]; //保证不做素数的倍数int main()&#123; int n, cnt = 0; cin &gt;&gt; n; memset(vis, false, sizeof(vis)); //初始化 memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) //未被标记 prime[cnt++] = i; //则找到素数 for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = true; //标记找到的素数的倍数 if (i % prime[j] == 0) break; //线性的关键！！ &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) cout &lt;&lt; prime[i] &lt;&lt; &quot; &quot;; //输出每个素数 return 0;&#125; 个人学习记录，非教程，所以不太注重以上算法原理的解释","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"2022天梯赛个人题解","slug":"2022天梯赛个人题解","date":"2022-04-26T06:26:37.000Z","updated":"2022-10-21T13:28:17.331Z","comments":true,"path":"2022/04/26/2022天梯赛个人题解/","link":"","permalink":"http://example.com/2022/04/26/2022%E5%A4%A9%E6%A2%AF%E8%B5%9B%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/","excerpt":"","text":"L1-1 今天我要赢(5分) 题目描述 2018 年我们曾经出过一题，是输出“2018 我们要赢”。今年是 2022 年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。 输入格式： 本题没有输入。 输出格式： 输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用 年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是 2022-04-22。 输入样例： 无 输出样例（第二行的内容要你自己想一想，这里不给出）： I’m gonna win! Today! 这一行的内容我不告诉你…… 你要自己输出正确的日期呀~ 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; cout &lt;&lt; &quot;I&#x27;m gonna win! Today!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2022-04-23&quot;; return 0;&#125; L1-2 种钻石(5分) 题目描述 2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗 1 克拉大小的钻石。 本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。 输入格式： 输入在一行中给出钻石的需求量 $N$（不超过 $10^7$的正整数，以微克拉为单位）和人工培育钻石的速度 $v$（$1≤v≤200$，以微克拉/天为单位的整数）。 输出格式： 在一行中输出培育 $N$ 微克拉钻石需要的整数天数。不到一天的时间不算在内。 输入样例： 102000 130 输出样例： 784 代码 #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cmath&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std; int main()&#123; //IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a / b; return 0;&#125; L1-3 谁能进图书馆(10分) 题目描述 为了保障安静的阅读环境，有些公共图书馆对儿童入馆做出了限制。例如“12 岁以下儿童禁止入馆，除非有 18 岁以上（包括 18 岁）的成人陪同”。现在有两位小/大朋友跑来问你，他们能不能进去？请你写个程序自动给他们一个回复。 输入格式： 输入在一行中给出 4 个整数： 禁入年龄线 陪同年龄线 询问者1的年龄 询问者2的年龄 这里的禁入年龄线是指严格小于该年龄的儿童禁止入馆；陪同年龄线是指大于等于该年龄的人士可以陪同儿童入馆。默认两个询问者的编号依次分别为 1 和 2；年龄和年龄线都是 [1, 200] 区间内的整数，并且保证 陪同年龄线 严格大于 禁入年龄线。 输出格式： 在一行中输出对两位询问者的回答，如果可以进就输出 年龄-Y，否则输出 年龄-N，中间空 1 格，行首尾不得有多余空格。 在第二行根据两个询问者的情况输出一句话： 如果两个人必须一起进，则输出 qing X zhao gu hao Y，其中 X 是陪同人的编号， Y 是小孩子的编号； 如果两个人都可以进但不是必须一起的，则输出 huan ying ru guan； 如果两个人都进不去，则输出 zhang da zai lai ba； 如果一个人能进一个不能，则输出 X: huan ying ru guan，其中 X 是可以入馆的那个人的编号。 输入样例1： 12 18 18 8 输出样例1： 18-Y 8-Y qing 1 zhao gu hao 2 输入样例 2： 12 18 10 15 输出样例 2： 10-N 15-Y 2: huan ying ru guan 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int y1, y2, a, b; cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; a &gt;&gt; b; if (a &gt; b) &#123; if (b &gt;= y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;huan ying ru guan&quot; &lt;&lt; endl; &#125; else if (b &lt; y1 &amp;&amp; a &gt;= y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;qing 1 zhao gu hao 2&quot; &lt;&lt; endl; &#125; else if (a &lt; y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;zhang da zai lai ba&quot; &lt;&lt; endl; &#125; else if (b &lt; y1 &amp;&amp; a &lt; y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1: huan ying ru guan&quot; &lt;&lt; endl; &#125; &#125; else &#123; if (a &gt;= y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;huan ying ru guan&quot; &lt;&lt; endl; &#125; else if (a &lt; y1 &amp;&amp; b &gt;= y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;qing 2 zhao gu hao 1&quot; &lt;&lt; endl; &#125; else if (b &lt; y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;zhang da zai lai ba&quot; &lt;&lt; endl; &#125; else if (a &lt; y1 &amp;&amp; b &lt; y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2: huan ying ru guan&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; L1-4 拯救外星人(10分) 题目描述 你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 $N$ 的阶乘记为 “$N!$”，是从$1$到$N$ 的连乘积。所以当他不知道“$5+7$”等于多少时，如果你告诉他等于“$12!$”，他就写出了“$479001600$”这个答案。 本题就请你写程序模仿外星人的行为。 输入格式： 输入在一行中给出两个正整数 $A$和 $B$。 输出格式： 在一行中输出 $(A+B)$的阶乘。题目保证 $(A+B)$ 的值小于 $12$。 输入样例： 3 6 输出样例： 362880 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; int sum = 1; for (int i = 2; i &lt;= a + b; i++) sum *= i; cout &lt;&lt; sum; return 0;&#125; L1-5 试试手气(15分) 题目描述 我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件： 1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同； 2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。 那么你应该可以预知自己第 $n$ 次$（1≤n≤5）$摇出的结果。 输入格式： 输入第一行给出 $6$ 个骰子的初始点数，即 $[1,6]$ 之间的整数，数字间以空格分隔；第二行给出摇的次数 $n$$（1≤n≤5）$。 输出格式： 在一行中顺序列出第 $n $次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。 输入样例： 3 6 5 4 1 4 3 输出样例： 4 3 3 3 4 3 分析 可以硬模拟，也可以用数学推一推，但是模拟太好写了就直接无脑模了。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int a[7], b[7];int main()&#123; // IOS; for (int i = 1; i &lt;= 6; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i];//记录原始状态 if (a[i] != 6) a[i] = 6; else a[i] = 5; &#125; int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) for (int i = 1; i &lt;= 6; i++) &#123; a[i]--; if (a[i] == b[i]) a[i]--; &#125; for (int i = 1; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;//万恶的格式控制 cout &lt;&lt; a[6]; return 0;&#125; L1-6 斯德哥尔摩火车上的题(15分) 题目描述 上图是新浪微博上的一则趣闻，是瑞典斯德哥尔摩火车上的一道题，看上去是段伪代码： s = ‘’ a = ‘1112031584’ for (i = 1; i &lt; length(a); i++) { if (a[i] % 2 == a[i-1] % 2) { s += max(a[i], a[i-1]) } } goto_url(‘www.multisoft.se/’ + s) 其中字符串的 + 操作是连接两个字符串的意思。所以这道题其实是让大家访问网站 www.multisoft.se/112358（注意：比赛中千万不要访问这个网址！！！）。 当然，能通过上述算法得到 112358 的原始字符串 a 是不唯一的。本题就请你判断，两个给定的原始字符串，能否通过上述算法得到相同的输出？ 输入样例 1： 1112031584 011102315849 输出样例 1： 112358 输入样例 2： 111203158412334 12341112031584 输出样例 2： 1123583 112358 分析 字符串处理题，伪代码都给出来了，属于是送分。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; string s1 = &quot;&quot;, s2 = &quot;&quot;; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt; a.size(); i++) if (a[i] % 2 == a[i - 1] % 2) s1 += max(a[i], a[i - 1]); for (int i = 1; i &lt; b.size(); i++) if (b[i] % 2 == b[i - 1] % 2) s2 += max(b[i], b[i - 1]); if(s1 == s2) cout &lt;&lt; s1; else cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2; return 0;&#125; L1-7 机工士姆斯塔迪奥(20分) 题目描述 在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS 机工士姆斯塔迪奥将会接受玩家的挑战。 你需要处理这个副本其中的一个机制：$N×M$ 大小的地图被拆分为了 $N×M$ 个 $1×1$ 的格子，BOSS 会选择若干行或/及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。 给定 BOSS 所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。 输入格式: 输入第一行是三个整数 $N,M,Q (1≤N×M≤10^5，0≤Q≤1000)$，表示地图为 $N$行 $M$列大小以及选择的行/列数量。 接下来 $Q$行，每行两个数 $T_i$ ,$C _i$，其中 $T_i=0$ 表示 BOSS 选择的是一整行，$T_i =1$ 表示选择的是整列，$C _i$为选择的行号/列号。行和列的编号均从 $1$ 开始。 输出格式: 输出一个数，表示安全格子的数量。 输入样例: 5 5 3 0 2 0 4 1 3 输出样例: 12 分析 很简单的题意，主要坑点就是有可能BOSS技能的位置会有重复输入，重复的数据不处理就好 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;const int N = 1e5 + 10;int vis[2][N];int main()&#123; IOS; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int t, c; while (q--) &#123; cin &gt;&gt; t &gt;&gt; c; if (!vis[t][c]) //第一次遇见才处理 &#123; vis[t][c] = 1; if (t) m--; else n--; &#125; &#125; cout &lt;&lt; n * m; return 0;&#125; L1-8 静静的推荐(20分) 题目描述 天梯赛结束后，某企业的人力资源部希望组委会能推荐一批优秀的学生，这个整理推荐名单的任务就由静静姐负责。企业接受推荐的流程是这样的： 只考虑得分不低于 175 分的学生； 一共接受 $K$ 批次的推荐名单； 同一批推荐名单上的学生的成绩原则上应严格递增； 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 给定全体参赛学生的成绩和他们的 PAT 考试成绩，请你帮静静姐算一算，她最多能向企业推荐多少学生？ 输入格式： 输入第一行给出 3 个正整数：$N（≤10^5）$为参赛学生人数，$K（≤5×10^3）$为企业接受的推荐批次，$S（≤100）$为该企业的 PAT 面试分数线。 随后 $N$ 行，每行给出两个分数，依次为一位学生的天梯赛分数（最高分 290）和 PAT 分数（最高分 100）。 输出格式： 在一行中输出静静姐最多能向企业推荐的学生人数。 输入样例： 10 2 90 203 0 169 91 175 88 175 0 175 90 189 0 189 0 189 95 189 89 256 100 输出样例： 8 样例解释： 第一批可以选择 175、189、203、256 这四个分数的学生各一名，此外 175 分 PAT 分数达到 90 分的学生和 189 分 PAT 分数达到 95 分的学生可以额外进入名单。第二批就只剩下 175、189 两个分数的学生各一名可以进入名单了。最终一共 8 人进入推荐名单。 分析 很有意思的一个题，第一次做这个题很容易纠结在 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 ”这句话里面的与前一个人相同，可能会不断扫描所有学生，写出一个模拟来判断前一个人的分数。可事实上这个人是哪个人并不重要，问的是人数，又没问推哪个人。 那么其实就可以将175~290的每个分数映射到数组下标，然后从175一直遍历到290。其中有个小细节就是如果天梯赛满足175并且PTA也达到了企业的要求，那么其实这一批人就可以全部跟着上一个分数相同但是PTA不达标的人一起进入同一个推荐名单。 如果样例数据是这样的 175 0 175 90 175 91 175 92 175 93 这批五个175分的学生其实就可以在同一个推荐名单里面 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int stu[300];int pta[300];int main()&#123; IOS; int n, k, s; //人数，批次，分数线 cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int a, b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt;= 175) //天梯赛175以上是硬性规定，不满足的可以不用考虑 &#123; stu[a]++; //天梯赛分数为a的学生人数+1 if (b &gt;= s) pta[a]++; //可以特招的天梯赛分数为a的学生人数+1 &#125; &#125; int ans = 0; for (int i = 175; i &lt;= 290; i++) &#123; if (stu[i]) &#123; ans += pta[i]; //特招是一定可以全部推荐走的 stu[i] -= pta[i]; if (stu[i]) //如果还剩下的有天梯赛到175分而PTA不到企业规定分数的，则只能按照K个批次来推荐 ans += min(stu[i], k); //所以ans再次加上可以推荐的人数 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; L2-1 插松枝(25分) 题目描述 人造松枝加工场的工人需要将各种尺寸的塑料松针插到松枝干上，做成大大小小的松枝。他们的工作流程（并不）是这样的： 每人手边有一只小盒子，初始状态为空。 每人面前有用不完的松枝干和一个推送器，每次推送一片随机型号的松针片。 工人首先捡起一根空的松枝干，从小盒子里摸出最上面的一片松针 —— 如果小盒子是空的，就从推送器上取一片松针。将这片松针插到枝干的最下面。 工人在插后面的松针时，需要保证，每一步插到一根非空松枝干上的松针片，不能比前一步插上的松针片大。如果小盒子中最上面的松针满足要求，就取之插好；否则去推送器上取一片。如果推送器上拿到的仍然不满足要求，就把拿到的这片堆放到小盒子里，继续去推送器上取下一片。注意这里假设小盒子里的松针片是按放入的顺序堆叠起来的，工人每次只能取出最上面（即最后放入）的一片。 当下列三种情况之一发生时，工人会结束手里的松枝制作，开始做下一个： （1）小盒子已经满了，但推送器上取到的松针仍然不满足要求。此时将手中的松枝放到成品篮里，推送器上取到的松针压回推送器，开始下一根松枝的制作。 （2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。此时将手中的松枝放到成品篮里，开始下一根松枝的制作。 （3）手中的松枝干上已经插满了松针，将之放到成品篮里，开始下一根松枝的制作。 现在给定推送器上顺序传过来的 $N$ 片松针的大小，以及小盒子和松枝的容量，请你编写程序自动列出每根成品松枝的信息。 输入格式： 输入在第一行中给出 $3$ 个正整数：$N（≤10^3）$，为推送器上松针片的数量；$M（≤20）$为小盒子能存放的松针片的最大数量；$K（≤5）$为一根松枝干上能插的松针片的最大数量。 随后一行给出 $N$ 个不超过 $100$ 的正整数，为推送器上顺序推出的松针片的大小。 输出格式： 每支松枝成品的信息占一行，顺序给出自底向上每片松针的大小。数字间以 $1$ 个空格分隔，行首尾不得有多余空格。 输入样例： 8 3 4 20 25 15 18 20 18 8 5 输出样例： 20 15 20 18 18 8 25 5 分析 开两个容器硬模拟推送器和小盒子，注意一下条件不然可能或出现段错误 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;queue&lt;int&gt; que; //推送器stack&lt;int&gt; st; //盒子int main()&#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; que.push(x); &#125; while (que.size() || st.size()) &#123; vector&lt;int&gt; ans; int s; if (!st.empty()) &#123; s = st.top(); st.pop(); ans.push_back(s); &#125; else if (!que.empty()) &#123; s = que.front(); que.pop(); ans.push_back(s); &#125; while (true) &#123; if (!st.empty() &amp;&amp; st.top() &lt;= ans.back()) &#123; s = st.top(); st.pop(); ans.push_back(s); &#125; else if (!que.empty() &amp;&amp; que.front() &lt;= ans.back()) &#123; s = que.front(); que.pop(); ans.push_back(s); &#125; else if (!st.empty() &amp;&amp; st.top() &gt; ans.back() &amp;&amp; que.empty()) break; else if (st.size() &lt; m &amp;&amp; que.front() &gt; ans.back()) &#123; s = que.front(); que.pop(); st.push(s); &#125; else if (st.size() == m &amp;&amp; que.front() &gt; ans.back()) break; if (que.empty() &amp;&amp; st.empty()) break; else if (ans.size() == k) break; &#125; cout &lt;&lt; ans[0]; //又是我最讨厌的控制格式 for (int t1 = 1; t1 &lt; ans.size(); t1++) cout &lt;&lt; &quot; &quot; &lt;&lt; ans[t1]; cout &lt;&lt; endl; &#125; return 0;&#125; L2-2 老板的作息表(25分) 题目描述 新浪微博上有人发了某老板的作息时间表，表示其每天 4:30 就起床了。但立刻有眼尖的网友问：这时间表不完整啊，早上九点到下午一点干啥了？ 本题就请你编写程序，检查任意一张时间表，找出其中没写出来的时间段。 输入格式： 输入第一行给出一个正整数 $N$，为作息表上列出的时间段的个数。随后 $N$ 行，每行给出一个时间段，格式为： hh:mm:ss - hh:mm:ss 其中 hh、mm、ss 分别是两位数表示的小时、分钟、秒。第一个时间是开始时间，第二个是结束时间。题目保证所有时间都在一天之内（即从 00:00:00 到 23:59:59）；每个区间间隔至少 1 秒；并且任意两个给出的时间区间最多只在一个端点有重合，没有区间重叠的情况。 输出格式： 按照时间顺序列出时间表中没有出现的区间，每个区间占一行，格式与输入相同。题目保证至少存在一个区间需要输出。 输入样例： 8 13:00:00 - 18:00:00 00:00:00 - 01:00:05 08:00:00 - 09:00:00 07:10:59 - 08:00:00 01:00:05 - 04:30:00 06:30:00 - 07:10:58 05:30:00 - 06:30:00 18:00:00 - 19:00:00 输出样例： 04:30:00 - 05:30:00 07:10:58 - 07:10:59 09:00:00 - 13:00:00 19:00:00 - 23:59:59 分析 考点很简单就是排序（但是我第一反应是一个不需要排序的邪道写法最后还A了 ） 将所有的时间存起来然后排序再扫描一遍即可，排序可以手写重载也可以用vector的默认排序，数据量大建议手写，容器自带的排序还是慢了点。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;string s[100000]; //没给范围第一次数组开小了一直段错误超bool cmp(string a, string b)&#123; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] != b[i]) return a[i] &lt; b[i]; &#125;&#125;int main()&#123; // IOS; int n; cin &gt;&gt; n; cin.get(); for (int i = 0; i &lt; n; i++) getline(cin, s[i]); sort(s, s + n, cmp); string temp = &quot;00:00:00&quot;; for (int i = 0; i &lt; n; i++) &#123; if (temp != s[i].substr(0, 8)) cout &lt;&lt; temp &lt;&lt; &quot; - &quot; &lt;&lt; s[i].substr(0, 8) &lt;&lt; endl; temp = s[i].substr(11, 8); &#125; if (temp != &quot;23:59:59&quot;) cout &lt;&lt; temp &lt;&lt; &quot; - 23:59:59&quot; &lt;&lt; endl; return 0;&#125; 剩下有空了再摸","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"二分总结","slug":"二分总结","date":"2022-01-07T09:31:37.000Z","updated":"2022-10-19T06:18:25.069Z","comments":true,"path":"2022/01/07/二分总结/","link":"","permalink":"http://example.com/2022/01/07/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } 为什么需要补上一个呢？ 因为整数的除法是向下取整，我们需要在运算时+1时它变成向上取整，否则的话会因为边界问题导致while无限循环。 举个例子，在区间只有两个数的时候，比如，，，这时候如果check成功，那么会执行，然后问题就来了，和本来就都等于3，然后就会无限循环下去，和的值永远不会更新。所以在的更新方式下，我们需要将运算时成为向上取整才不会死循环。 第二种 这种情况代码如下 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; } 为什么在这里不需要补上一个呢？ 因为边界问题不会影响到值的更新，还是用上面那个例子，，，。 此时如果check成功，那么，更新成功。如果check失败，则，同样更新成功。由此可以看出，在的更新方式下，不需要对进行任何操作。 以上是整数二分的两种固定写法。那么什么时候用哪种方法呢，这就要根据具体的题目进行分析了。 例题—— 分巧克力 题目描述 儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 和 。 输入保证每位小朋友至少能获得一块 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 输入输出样例 输入#1 2 10 6 5 5 6 输出#1 2 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl '\\n'using namespace std;int n, k;const int N = 1e5 + 10;int h[N], w[N];bool check(int x){ int cnt = 0; for (int i = 0; i &lt; n; i++) { cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; } return false;}int main(){ IOS; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i] &gt;&gt; w[i]; int l = 0, r = N; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; return 0;} 题目很简单是二分的板子题，主要是说为什么要用第一种求方法呢。 为什么二分里面不能写成 int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; //这样写跑样例答案是3 else r = mid; 推导一遍发现，如果成立后，说明当前的值也是在答案范围中，所以答案只能在之中取。理所当然无法用上面那种写法，如果用上面那种方法，会直接更新成，会越过这个值，所以在一些情况就会出现错误，比如题面的样例就会成为，越过了这个可能的答案值，恰好就是最大的一个答案，导致答案错误。 总结 这次弄明白了二分的写法属实是不易，留文一篇防止日后遗忘 以后写二分的时候记得注意一下区间情况","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]}
{"meta":{"title":"时砾逐光","subtitle":"愿前路无止境","description":"个人博客","author":"Hiroshi","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-11-20T08:55:23.712Z","updated":"2022-11-20T08:55:23.712Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-11-20T08:53:51.108Z","updated":"2022-11-20T08:53:51.108Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-11-20T08:53:47.544Z","updated":"2022-11-20T08:53:47.544Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-10-15T11:13:46.453Z","updated":"2022-10-15T11:13:46.453Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"linux修改环境变量的几种方法","slug":"linux修改环境变量的几种方法","date":"2022-12-11T12:05:01.000Z","updated":"2022-12-24T07:17:26.114Z","comments":true,"path":"2022/12/11/linux修改环境变量的几种方法/","link":"","permalink":"http://example.com/2022/12/11/linux%E4%BF%AE%E6%94%B9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"修改方法一： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：立即生效 有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置 用户局限：仅对当前用户 修改方法二： 通过修改.bashrc文件: vim ~/.bashrc //在最后一行添上： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：（有以下两种） 1、关闭当前终端窗口，重新打开一个新终端窗口就能生效 2、输入“source ~/.bashrc”命令，立即生效 有效期限：永久有效 用户局限：仅对当前用户 修改方法三:","text":"修改方法一： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：立即生效 有效期限：临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置 用户局限：仅对当前用户 修改方法二： 通过修改.bashrc文件: vim ~/.bashrc //在最后一行添上： export PATH=/usr/local/mongodb/bin:$PATH 生效方法：（有以下两种） 1、关闭当前终端窗口，重新打开一个新终端窗口就能生效 2、输入“source ~/.bashrc”命令，立即生效 有效期限：永久有效 用户局限：仅对当前用户 修改方法三: 通过修改profile文件: vim /etc/profile /export PATH //找到设置PATH的行，添加 export PATH=/usr/local/mongodb/bin:$PATH 生效方法：系统重启 有效期限：永久有效 用户局限：对所有用户 修改方法四: 通过修改environment文件: vim /etc/environment 在PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;中加入“:/usr/local/mongodb/bin” 生效方法：系统重启 有效期限：永久有效","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"vscode的一些配置","slug":"vscode的一些配置","date":"2022-11-18T02:21:14.000Z","updated":"2022-11-18T09:42:52.534Z","comments":true,"path":"2022/11/18/vscode的一些配置/","link":"","permalink":"http://example.com/2022/11/18/vscode%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/","excerpt":"","text":"记录一下自己的配置文件 // setting.json&#123; &quot;files.defaultLanguage&quot;: &quot;cpp&quot;, // ctrl+N新建文件后默认的语言 &quot;editor.formatOnType&quot;: false, // 输入分号(C/C++的语句结束标识)后自动格式化当前这一行的代码 &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false, // clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了 &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;, // 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense // &quot;editor.snippetSuggestions&quot;: &quot;maxx&quot;, // （可选）snippets显示在补全列表顶端，默认是inline &quot;code-runner.runInTerminal&quot;: true, // 设置成false会在“输出”中输出，无法输入 &quot;code-runner.executorMap&quot;: &#123; &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc &#x27;$fileName&#x27; -o &#x27;$fileNameWithoutExt.exe&#x27; -Wall -g -O2 -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;&#x27;$dir$fileNameWithoutExt&#x27;&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ &#x27;$fileName&#x27; -o &#x27;$fileNameWithoutExt.exe&#x27; -Wall -g -O2 -static-libgcc -std=c++17 -fexec-charset=GBK &amp;&amp; &amp;&#x27;$dir$fileNameWithoutExt&#x27;&quot; // &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt&quot;, // &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt.exe -Wall -g -O2 -static-libgcc -std=c++17 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt&quot; &#125;, // 右键run code时运行的命令；未注释的仅适用于PowerShell（Win10默认），文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认），PS和bash也能用，但文件名中有空格时无法运行 &quot;code-runner.saveFileBeforeRun&quot;: true, // run code前保存 &quot;code-runner.preserveFocus&quot;: false, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false &quot;code-runner.clearPreviousOutput&quot;: false, // 每次run code前清空属于code runner的终端消息，默认false &quot;code-runner.ignoreSelection&quot;: true, // 默认为false，效果是鼠标选中一块代码后可以单独执行，但C是编译型语言，不适合这样用 //屏蔽一些文件试目录更加简洁 &quot;files.exclude&quot;: &#123; &quot;**/.git&quot;: true, &quot;**/.svn&quot;: true, &quot;**/.hg&quot;: true, &quot;**/CVS&quot;: true, &quot;**/.DS_Store&quot;: true, // &quot;**/.vscode&quot;: true, &quot;**/*.exe&quot;: true, &#125;, &quot;python.analysis.extraPaths&quot;: [ &quot;D:\\\\Program\\\\anaconda\\\\pkgs\\\\requests-2.27.1-pyhd3eb1b0_0&quot;, &quot;C:\\\\Users\\\\Administrator\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python310\\\\Lib\\\\site-packages&quot;, &quot;D:\\\\Program\\\\anaconda\\\\Lib\\\\site-packages&quot; ], &quot;C_Cpp.clang_format_sortIncludes&quot;: true, &quot;files.associations&quot;: &#123; &quot;array&quot;: &quot;cpp&quot;, &quot;atomic&quot;: &quot;cpp&quot;, &quot;*.tcc&quot;: &quot;cpp&quot;, &quot;cctype&quot;: &quot;cpp&quot;, &quot;clocale&quot;: &quot;cpp&quot;, &quot;cmath&quot;: &quot;cpp&quot;, &quot;cstdarg&quot;: &quot;cpp&quot;, &quot;cstddef&quot;: &quot;cpp&quot;, &quot;cstdint&quot;: &quot;cpp&quot;, &quot;cstdio&quot;: &quot;cpp&quot;, &quot;cstdlib&quot;: &quot;cpp&quot;, &quot;cwchar&quot;: &quot;cpp&quot;, &quot;cwctype&quot;: &quot;cpp&quot;, &quot;deque&quot;: &quot;cpp&quot;, &quot;unordered_map&quot;: &quot;cpp&quot;, &quot;vector&quot;: &quot;cpp&quot;, &quot;exception&quot;: &quot;cpp&quot;, &quot;algorithm&quot;: &quot;cpp&quot;, &quot;memory&quot;: &quot;cpp&quot;, &quot;memory_resource&quot;: &quot;cpp&quot;, &quot;optional&quot;: &quot;cpp&quot;, &quot;string&quot;: &quot;cpp&quot;, &quot;string_view&quot;: &quot;cpp&quot;, &quot;system_error&quot;: &quot;cpp&quot;, &quot;tuple&quot;: &quot;cpp&quot;, &quot;type_traits&quot;: &quot;cpp&quot;, &quot;utility&quot;: &quot;cpp&quot;, &quot;fstream&quot;: &quot;cpp&quot;, &quot;initializer_list&quot;: &quot;cpp&quot;, &quot;iosfwd&quot;: &quot;cpp&quot;, &quot;iostream&quot;: &quot;cpp&quot;, &quot;istream&quot;: &quot;cpp&quot;, &quot;limits&quot;: &quot;cpp&quot;, &quot;new&quot;: &quot;cpp&quot;, &quot;ostream&quot;: &quot;cpp&quot;, &quot;sstream&quot;: &quot;cpp&quot;, &quot;stdexcept&quot;: &quot;cpp&quot;, &quot;streambuf&quot;: &quot;cpp&quot;, &quot;typeinfo&quot;: &quot;cpp&quot;, &quot;forward_list&quot;: &quot;cpp&quot;, &quot;list&quot;: &quot;cpp&quot;, &quot;unordered_set&quot;: &quot;cpp&quot;, &quot;functional&quot;: &quot;cpp&quot;, &quot;future&quot;: &quot;cpp&quot;, &quot;mutex&quot;: &quot;cpp&quot;, &quot;thread&quot;: &quot;cpp&quot;, &quot;regex&quot;: &quot;cpp&quot;, &quot;valarray&quot;: &quot;cpp&quot;, &quot;cstring&quot;: &quot;cpp&quot;, &quot;bitset&quot;: &quot;cpp&quot;, &quot;cfenv&quot;: &quot;cpp&quot;, &quot;chrono&quot;: &quot;cpp&quot;, &quot;cinttypes&quot;: &quot;cpp&quot;, &quot;complex&quot;: &quot;cpp&quot;, &quot;condition_variable&quot;: &quot;cpp&quot;, &quot;csetjmp&quot;: &quot;cpp&quot;, &quot;csignal&quot;: &quot;cpp&quot;, &quot;ctime&quot;: &quot;cpp&quot;, &quot;ratio&quot;: &quot;cpp&quot;, &quot;iomanip&quot;: &quot;cpp&quot;, &quot;numeric&quot;: &quot;cpp&quot;, &quot;scoped_allocator&quot;: &quot;cpp&quot;, &quot;typeindex&quot;: &quot;cpp&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;stdio.h&quot;: &quot;c&quot;, &quot;process.h&quot;: &quot;c&quot;, &quot;stdlib.h&quot;: &quot;c&quot;, &quot;string.h&quot;: &quot;c&quot;, &quot;map&quot;: &quot;cpp&quot;, &quot;charconv&quot;: &quot;cpp&quot;, &quot;codecvt&quot;: &quot;cpp&quot;, &quot;cuchar&quot;: &quot;cpp&quot;, &quot;iterator&quot;: &quot;cpp&quot;, &quot;set&quot;: &quot;cpp&quot;, &quot;shared_mutex&quot;: &quot;cpp&quot;, &quot;queue&quot;: &quot;cpp&quot;, &quot;linklist.c&quot;: &quot;cpp&quot;, &quot;linkstack.c&quot;: &quot;cpp&quot;, &quot;stack&quot;: &quot;cpp&quot; &#125;, &quot;C_Cpp.errorSquiggles&quot;: &quot;Enabled&quot;, &quot;python.testing.pytestArgs&quot;: [ &quot;.&quot; ], &quot;python.testing.unittestEnabled&quot;: false, &quot;python.testing.pytestEnabled&quot;: true, // 格式化时调整include的顺序（按字母排序）&#125;","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"powershell美化和集成git","slug":"powershell美化和集成git","date":"2022-11-07T09:04:40.000Z","updated":"2022-11-18T01:39:29.263Z","comments":true,"path":"2022/11/07/powershell美化和集成git/","link":"","permalink":"http://example.com/2022/11/07/powershell%E7%BE%8E%E5%8C%96%E5%92%8C%E9%9B%86%E6%88%90git/","excerpt":"1.安装posh-git 在powershell运行 Install-Module posh-git 此时部分指令是无法使用的，因为powershell默认禁止运行签名脚本，所以再次运行 Set-ExecutionPolicy RemoteSigned","text":"1.安装posh-git 在powershell运行 Install-Module posh-git 此时部分指令是无法使用的，因为powershell默认禁止运行签名脚本，所以再次运行 Set-ExecutionPolicy RemoteSigned 这样就可以允许运行签名脚本啦！ 2.美化powershell 在Microsoft Store里搜索Windows Terminal，然后下载|打开，在设置—&gt;启动—&gt;默认终端应用程序里选择Windows终端即可。以后启动cmd或者powershell都会从Windows Terminal启动了。 剩余内容日后再更","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"服务器操作","slug":"服务器操作","date":"2022-10-25T00:38:16.000Z","updated":"2022-12-11T12:28:39.591Z","comments":true,"path":"2022/10/25/服务器操作/","link":"","permalink":"http://example.com/2022/10/25/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C/","excerpt":"服务器操作指令总结 个人用，写的比较杂碎。 下载服务器文件到本地 scp 用户名@IP:目标文件的地址 下载到本地的路径scp root@192.168.202.101:/data/share/target.txt /Users/target.txt # 文件夹使用scp -r即可 查看文件大小","text":"服务器操作指令总结 个人用，写的比较杂碎。 下载服务器文件到本地 scp 用户名@IP:目标文件的地址 下载到本地的路径scp root@192.168.202.101:/data/share/target.txt /Users/target.txt # 文件夹使用scp -r即可 查看文件大小 du -h --max-depth=1 # 查看当前文件夹目录各个文件大小du -h --max-depth=1/path # 查看指定目录du -h - . # 查看当前目录下所有目录及子目录大小 &#x27;.&#x27;代表当前目录下。也可以换成一个明确的路径 -h表示用K、M、G的形式显示 更新apt源 刷新软件源信息sudo apt update更新软件sudo apt upgrade 文件压缩 // 压缩为zipzip -r fileName.zip 文件夹名//tar命令单个文件压缩打包 tar czvf my.tar file1多个文件压缩打包 tar czvf my.tar file1 file2,...单个目录压缩打包 tar czvf my.tar dir1多个目录压缩打包 tar czvf my.tar dir1 dir2解包至当前目录：tar xzvf my.tar","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"HTML笔记","slug":"HTML笔记","date":"2022-10-24T11:58:31.000Z","updated":"2022-10-24T15:20:18.486Z","comments":true,"path":"2022/10/24/HTML笔记/","link":"","permalink":"http://example.com/2022/10/24/HTML%E7%AC%94%E8%AE%B0/","excerpt":"记录一下上课学的html p元素 &lt;!--定义了html文档的段落--&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt; body元素 &lt;!--&lt;body&gt; 元素定义了 HTML 文档的主体--&gt;&lt;body&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt;","text":"记录一下上课学的html p元素 &lt;!--定义了html文档的段落--&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt; body元素 &lt;!--&lt;body&gt; 元素定义了 HTML 文档的主体--&gt;&lt;body&gt;&lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt; html元素 &lt;html&gt;&lt;body&gt; &lt;p&gt;这是第一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; html标题 &lt;!--定义了html文档的标题--&gt;&lt;h1&gt;这是一个标题。&lt;/h1&gt;&lt;h2&gt;这是一个标题。&lt;/h2&gt;&lt;h3&gt;这是一个标题。&lt;/h3&gt; tips:不要仅仅是为了生成粗体或大号的文本而使用标题。 html水平线 &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt;&lt;hr&gt;&lt;p&gt;这是一个段落。&lt;/p&gt; html注释 &lt;!-- 这是一个注释 --&gt; html超链接 &lt;a href=&quot;url&quot;&gt;显示文本&lt;/a&gt;&lt;!--target属性--&gt;&lt;!--_blank表示会在新窗口打开链接--&gt;&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot;&gt;bilibili&lt;/a&gt;&lt;!--_self表示会在本窗口打开链接--&gt;&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_self&quot;&gt;bilibili&lt;/a&gt; head元素 &lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt; 和 &lt;base&gt;。 实例 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt; &lt;body&gt;文档内容......&lt;/body&gt; &lt;/html&gt; base元素 &lt;!--&lt;base&gt; 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接--&gt;&lt;head&gt; &lt;base href=&quot;http://www.exusiai.top/&quot; target=&quot;_blank&quot;&gt;&lt;/head&gt;","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"操作系统PV操作的理解","slug":"操作系统PV操作的理解","date":"2022-10-21T14:08:46.000Z","updated":"2022-11-22T12:01:52.202Z","comments":true,"path":"2022/10/21/操作系统PV操作的理解/","link":"","permalink":"http://example.com/2022/10/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FPV%E6%93%8D%E4%BD%9C%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。 并发进程分为两种： ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。 ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。 临界区：并发进程中与共享变量有关的程序段都称为临界区。","text":"PV操作概念：操作系统中的一种同步机制，实现对于并发进程中临界区的管理。 并发进程分为两种： ①无交互的并发进程：每个进程是相互独立的，谁也不影响谁，基本不会用到PV操作。 ②有交互的并发进程：多个进程共享资源，一个进程的运行，有可能会被外界的原因而中断，且断点不固定。进程执行的相对速度不能由进程自己来控制，于是就会导致并发进程在共享资源的时出现与时间有关的错误。 临界区：并发进程中与共享变量有关的程序段都称为临界区。 P操作：申请资源操作。 V操作：释放资源操作。 信号量S：用来记录资源数量，看是否能满足申请资源的操作。例如：S=3 表示三个可用空闲资源，S&lt;0表示可用空闲资源无，进程申请要进入等待队列中。 P(S)：S &lt;—— S - 1 ​ 如果S &gt;= 0，进程继续执行 ​ 如果S &lt; 0，进程停止执行，放入信号量等待队列中。 V(S)：S &lt;—— S +1 ​ 如果S &gt; 0，进程继续执行； ​ 如果S &lt;= 0，唤醒等待队列中的一个进程。 例题 应试做题方法： 从左到右、从上到下的将所有信号量标注在前驱图的箭头上，出发点是V操作，结束点是P操作，按照图选择答案即可。 所以易得答案CAA","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"软件设计师学习笔记","slug":"软件设计师学习笔记","date":"2022-10-18T06:46:29.000Z","updated":"2022-11-22T12:03:00.708Z","comments":true,"path":"2022/10/18/软件设计师学习笔记/","link":"","permalink":"http://example.com/2022/10/18/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"#现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 喜报，因为疫情没去考成（悲 Flynn分类法 CISC与RISC","text":"#现在是2022/10/18 ，11/05就开始考试了，这两周课还贼多。慌了，赶忙开始看网课 喜报，因为疫情没去考成（悲 Flynn分类法 CISC与RISC 流水线（重要） 流程： 取指——分析——执行 流水线周期指所有流程中执行时间最长的一段 流水线吞吐率计算： 流水线的加速比计算： 流水线的效率计算： 计算机层次化存储结构： Catch的基本概念： 除了寄存器外catch是最快的 计算 局部性原理： 主存的分类： 编址 （1）：","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"数据库笔记","slug":"数据库笔记","date":"2022-10-17T02:45:16.000Z","updated":"2022-10-20T04:15:34.327Z","comments":true,"path":"2022/10/17/数据库笔记/","link":"","permalink":"http://example.com/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/","excerpt":"# 跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名;create database 数据库名 charset=字符集; #设定默认字符集create database 数据库名 default cheoharacter set 字符集; #设定默认字符集 删除数据库","text":"# 跟着PHP课程重新记录一下MySQL的笔记 1.数据库操作： 创建数据库 create database 数据库名;create database 数据库名 charset=字符集; #设定默认字符集create database 数据库名 default cheoharacter set 字符集; #设定默认字符集 删除数据库 drop database 数据库名; 使用数据库 use 数据库名; 查询当前正在使用的数据库 select database(); 设置数据库字符集 alter database 数据库名 character set 字符集; 2.数据表操作 创建表 create table 表名 (字段名 字段类型 [NOT NULL]); 查询数据库的表格个数 # 第一种写法show tables from 数据库名;# 第二种写法,如果已经选择了使用的数据库则可以直接show tables; 修改表名 rename table 旧表名 to 新表名; 查看表格的详细信息 show create table 表名; 查看字段 desc 表名; 插入数据 # 两种写法into都可以省略insert into 表名 values(数据1, 数据2...) (数据1, 数据2...) # 可同时插入多组数据insert into 表名 (字段1,字段2...) values (数据1, 数据2...) # 这种写法可以跳过部分字段 查询数据 select 字段1,字段2 from 表名 [where...][limit n][offset m]# LIMIT 属性来设定返回的记录数。# OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。 更新数据 update 表名 set 字段1 = 值1,字段2 = 值2 [where...] 删除数据 delete from 表名 [where...] 3.筛选条件 去重(distinct) 例：select distinct job from user; # 查询user表中所有不重复的job名经常使用（count(distinct id)）来返回不重复字段的条数 NULL # 可以在语句中加入is null 和is not null来筛选字段数据例：select * from user where job is not null; # 查询user表中所有有工作的人的信息 between select * from user where age between 20 and 30; #包含范围两端 in # in运算符允许确定指定的值是否与列表中的值或子查询中的任何值匹配。 也可以搭配not使用select 字段1,字段2 from 表名 where (expr|column_1) in (值1,值2); as # 设置字段的别名select 字段名 as &quot;别名&quot; from 表名; # 最完整的写法 as和引号都可以省略例如:select 字段名 &quot;别名&quot; from 表名;select 字段名 别名 from 表名; like # 匹配的字符串必须加单引号或双引号# 通配符% 它能代表任何长度的字符串，字符串的长度可以为 0# 通配符_ 它只能代表单个字符，字符串的长度不能为 0例:select * from user where name like &#x27;王%&#x27;; #查询所有以王姓开头的用户# 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字例:select * from user where name like binary &#x27;t%&#x27;;# 这样就不会查询到 T 开头的名字了tips:1. % 通配符可以到匹配任意字符，但是不能匹配 NULL。2. mysql通配符的处理会比其他操作符花费更长的时间,如果其它操作符能达到相同的目的，应该使用其它操作符。3. 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。4. 如果查询内容中包含通配符，可以使用&quot;\\&quot;转义符。 排序**[ASC|DESC]** select 字段名 from 表名 [where...] order by 字段名 [ASC|DESC];# ASC代表升序、DESC代表降序 不跟默认升序# order by 后面可以跟多个条件，例如 order by age, id desc; 分页查询(LIMIT) 格式：limit 偏移量,取出的数据条数 # 偏移量不写默认为0limit 跳过的条数,请求的条数(每一页的条数) # 跳过的条数 = (请求的页数-1) * 请求的条数tips:分页查询一般和排序组合使用 聚合函数 max, min, avg, sum, count 分组查询(GROUP BY) 格式：group by 分组字段名 HAVING # 和where的区别having：后面跟聚合函数，可以单独使用where：后面跟普通字段条件，不能包含聚合函数 4.子查询(嵌套查询) 在SQL语言中，一个 SELECT-FROM-WHERE 语句称为一个查询块。将一个查询块嵌套在另一个查询块的 WHERE 子句或 HAVING 短语的条件中的查询称为 嵌套查询。 # 查询工资大于二号部门平均工资的员工信息select * from emp where sal &gt; (select avg(sal) from emp where dept_id = 2);tips:1.子查询的SELECT语句中不能使用 ORDER BY 子句，因为 ORDER BY 子句只能对最终查询结果排序。 5.关联查询(同时查询多表) 完善中… 1. 等值连接|笛卡尔积# 查询工资高于2000的员工姓名和部门名select emp.name,dept.name from dept, emp where emp.sal &gt; 2000 and emp.dept_id = dept.id;2. 内连接select 字段1,字段2 from 表名1 join 表名2 on 关联关系 [where...]3. 外连接# 外连接有三种：左外连接、右外连接、全外连接，左/右外连接没有本质区别select 字段1,字段2 from 表名1 left/right 表名2 on 关联关系 [where...] 6.奇技淫巧 修改正在使用被外键约束的列 # 原本不允许进行修改，因为这个操作违反了外键约束，破坏了数据库完整性。# 但是万能的mysql提供了一个方法，临时关闭外键约束，当修改完成之后再将外键约束加回来。 SET FOREIGN_KEY_CHECKS = 0;............SET FOREIGN_KEY_CHECKS = 1; SQL语句书写顺序 # 完善中select 字段 from 表名 where 普通字段条件 group by 分组字段 having 聚合函数条件 order by 排序字段名 limit 跳过的条数，请求的条数","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"Hexo-GitHub搭建教程","slug":"Hexo-Github搭建教程","date":"2022-10-16T07:56:22.000Z","updated":"2022-10-21T14:24:16.846Z","comments":true,"path":"2022/10/16/Hexo-Github搭建教程/","link":"","permalink":"http://example.com/2022/10/16/Hexo-Github%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","excerpt":"#注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io","text":"#注意事项 默认已有git基础且本机已连接GitHub 1.创建GitHub Pages 仓库 在GitHub主页右上角点击+号，再点击New repository创建仓库。 接着在Repository name内输入[你的用户名].github.io 点击Create repository就创建成功 创建成功后博客地址为：https://[你的用户名].github.io 2.本地安装Hexo程序 安装Node.js,一路next即可 Node.js：https://nodejs.org/zh-cn 使用指令npm install -g hexo-cli安装 ,mac用户需要在指令前加上sudo,这一步请耐心等待 在本地新建一个用于存放博客文件的文件夹，例如blog文件夹，在此文件夹进入Git Bash 初始化博客文件并安装组件 hexo init # 初始化npm install # 安装组件 完成后便可以在本地进行预览了（输入指令后不要关闭窗口） hexo g # 生成页面 hexo s # 启动预览 在浏览器中输入localhost:4000进行预览，出现Hexo的默认页面则本地博客安装成功！ 如果无法预览则可能是端口被占用，可以找出占用端口的程序并关闭，或者也可以修改Hexo启动的端口,这里改为5000端口 hexo s -p 5000 3.部署 Hexo 到 GitHub Pages 安装 hexo-deployer-git npm install hexo-deployer-git --save 修改_config.yml文件末尾的 Deployment 部分，修改成如下 deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 运行hexo d部署网站，成功后便可以在https://用户名.github.io看到自己的博客了 更新中······","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"GitHub","slug":"GitHub","permalink":"http://example.com/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"2022年第十三届蓝桥杯省赛个人题解","slug":"2022年第十三届蓝桥杯省赛个人题解","date":"2022-05-09T11:24:22.000Z","updated":"2022-11-22T12:03:51.750Z","comments":true,"path":"2022/05/09/2022年第十三届蓝桥杯省赛个人题解/","link":"","permalink":"http://example.com/2022/05/09/2022%E5%B9%B4%E7%AC%AC%E5%8D%81%E4%B8%89%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9B%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/","excerpt":"A: 九进制转十进制（5分） 题目描述: 九进制正整数 $(2022)_9$ 转换成十进制等于多少？ AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int k = 9; //进制 string num = &quot;2022&quot;; //数字 int ans = 0; ll temp = 1; int len = num.size(); for (int i = len - 1; i &gt;= 0; --i) &#123; ans += temp * (num[i] - &#x27;0&#x27;); temp *= k; &#125; cout &lt;&lt; ans; return 0;&#125;","text":"A: 九进制转十进制（5分） 题目描述: 九进制正整数 $(2022)_9$ 转换成十进制等于多少？ AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int k = 9; //进制 string num = &quot;2022&quot;; //数字 int ans = 0; ll temp = 1; int len = num.size(); for (int i = len - 1; i &gt;= 0; --i) &#123; ans += temp * (num[i] - &#x27;0&#x27;); temp *= k; &#125; cout &lt;&lt; ans; return 0;&#125; B: 顺子日期（5分） 题目描述: 小明特别喜欢顺子。顺子指的就是连续的三个数字：123、456 等。顺子日期指的就是在日期的 yyyymmdd 表示法中，存在任意连续的三位数是一个顺子的日期。例如 20220123 就是一个顺子日期，因为它出现了一个顺子：123；而 20221023 则不是一个顺子日期，它一个顺子也没有。小明想知道在整个 2022 年份中，一共有多少个顺子日期。 思路 不清楚0开头算不算顺子，算的话就是14，不算为4。 C: 刷题统计（10分） 题目描述: 小明决定从下周一开始努力刷题准备蓝桥杯竞赛。他计划周一至周五每天做$a$ 道题目，周六和周日每天做 $b$ 道题目。请你帮小明计算，按照计划他将在第几天实现做题数大于等于 $n$ 题？ 输入格式： 输入一行包含三个整数 $a, b$ 和$n$. 输出格式： 输出一个整数代表天数。 输入样例： 10 20 99 输出样例： 8 评测用例规模与约定 对于 50% 的评测用例，$1 ≤ a, b, n ≤ 10^6$ 对于 100% 的评测用例，$1 ≤ a, b, n ≤ 10^{18}$ 思路 略 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; IOS; ll a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; ll ans = n / (5 * a + 2 * b) * 7; ll t = ans / 7 * (5 * a + 2 * b); for (int i = 1; i &lt;= 7; i++) &#123; if (t &gt;= n) break; if (i &lt; 6) t += a, ans++; else t += b, ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; D: 修剪灌木（10分） 题目描述: 爱丽丝要完成一项修剪灌木的工作。 有 N 棵灌木整齐的从左到右排成一排。爱丽丝在每天傍晚会修剪一棵灌木，让灌木的高度变为 0 厘米。爱丽丝修剪灌木的顺序是从最左侧的灌木开始，每天向右修剪一棵灌木。当修剪了最右侧的灌木后，她会调转方向，下一天开始向左修剪灌木。直到修剪了最左的灌木后再次调转方向。然后如此循环往复。 灌木每天从早上到傍晚会长高 1 厘米，而其余时间不会长高。在第一天的早晨，所有灌木的高度都是 0 厘米。爱丽丝想知道每棵灌木最高长到多高。 输入格式： 一个正整数$N$ ，含义如题面所述。 输出格式： 输出 $N$ 行，每行一个整数，第行表示从左到右第 $i$ 棵树最高能长到多高。 输入样例： 3 输出样例： 4 2 4 评测用例规模与约定 对于 30% 的数据，$N ≤ 10$. 对于 100% 的数据，$1 &lt; N ≤ 10000$. 思路 略 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; IOS; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cout &lt;&lt; 2 * max(n - i, i - 1) &lt;&lt; endl; return 0;&#125; E: X 进制减法（15分） 题目描述: 进制规定了数字在数位上逢几进一。 $X$ 进制是一种很神奇的进制，因为其每一数位的进制并不固定！例如说某 种 $X$ 进制数，最低数位为二进制，第二数位为十进制，第三数位为八进制，则 $X$ 进制数 $321$ 转换为十进制数为 $65$。 现在有两个 $X$ 进制表示的整数 $A$ 和 $B$，但是其具体每一数位的进制还不确 定，只知道 $A$ 和 B 是同一进制规则，且每一数位最高为 $N$ 进制，最低为二进 制。请你算出 $A − B$ 的结果最小可能是多少。 请注意，你需要保证 $A$ 和 $B$ 在 $X$ 进制下都是合法的，即每一数位上的数 字要小于其进制。 输入格式： 第一行一个正整数 $N$，含义如题面所述。 第二行一个正整数 $M_a$，表示 $X$ 进制数 $A$ 的位数。 第三行 $M_a$ 个用空格分开的整数，表示$X$ 进制数 $A$按从高位到低位顺序各 个数位上的数字在十进制下的表示。 第四行一个正整数 $M_b$，表示 $X$ 进制数 $B$ 的位数。 第五行 $M_b$ 个用空格分开的整数，表示 $X$ 进制数 $B$ 按从高位到低位顺序各 个数位上的数字在十进制下的表示。 请注意，输入中的所有数字都是十进制的。 输出格式： 输出一行一个整数，表示 $X$ 进制数$A − B$ 的结果的最小可能值转换为十进 制后再模 $1000000007$ 的结果。 输入样例： 11 3 10 4 0 3 1 2 0 输出样例： 94 评测用例规模与约定 对于 30% 的数据，$N ≤ 10; Ma, Mb ≤ 8$. 对于 100% 的数据，$2 ≤ N ≤ 1000; 1 ≤ Ma, Mb ≤ 100000; A ≥ B$. F: 统计子矩阵（15分） 题目描述: 给定一个 $N × M$ 的矩阵 A，请你统计有多少个子矩阵 (最小 $1 × 1$，最大 $N × M$) 满足子矩阵中所有数的和不超过给定的整数 $K$? 输入格式： 第一行包含三个整数 $N, M 和 K$. 之后 $N$行每行包含 $M$个整数，代表矩阵 $A$ 输出格式： 一个整数代表答案。 输入样例： 3 4 10 1 2 3 4 5 6 7 8 9 10 11 12 输出样例： 19 评测用例规模与约定 对于 30% 的数据，$N, M ≤ 20$. 对于 70% 的数据，$N, M ≤ 100$. 对于 100% 的数据，$1 ≤ N, M ≤ 500; 0 ≤ A_{ij} ≤ 1000; 1 ≤ K ≤ 250000000$. 思路 先建立二维前缀和数组。 先枚举两条竖着的直线，为矩阵的左边和右边，然后从上到下双指针扫描，把二维问题变成一维问题。即给定一个一维数组，求连续一段区间和小于等于k的区间数量 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;const int N = 510;int a[N][N], b[N][N];int main()&#123; IOS; int n, m, k; ll ans = 0; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; a[i][j]; b[i][j] = b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1] + a[i][j]; &#125; &#125; for (int l = 1; l &lt;= m; l++) //枚举矩阵的左边 &#123; for (int r = l; r &lt;= m; r++) //枚举矩阵的右边 &#123; for (int i = 1, j = 1; i &lt;= n; i++) //有了左右边界，从上到下扫描 &#123; while (j &lt;= i &amp;&amp; (b[i][r] - b[i][l - 1] - b[j - 1][r] + b[j - 1][l - 1]) &gt; k) j++; if (j &lt;= i) //有可能最小的矩阵都不满足，此时j&gt;i ans += (i - j + 1); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; G: 积木画（20分） 题目描述: 小明最近迷上了积木画，有这么两种类型的积木，分别为 $I$ 型（大小为 2个单位面积）和 $L$ 型（大小为 3 个单位面积） 同时，小明有一块面积大小为 $2 × N$ 的画布，画布由 $2 × N 个 1 × 1$ 区域构成。小明需要用以上两种积木将画布拼满，他想知道总共有多少种不同的方式？积木可以任意旋转，且画布的方向固定。 输入格式： 输入一个整数 $N$，表示画布大小。 输出格式： 输出一个整数表示答案。由于答案可能很大，所以输出其对 $1000000007$ 取模后的值 输入样例： 3 输出样例： 5 评测用例规模与约定 对于所有测试用例，$1 ≤ N ≤ 10000000$. 思路： 线性DP。 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;const int N = 1e7 + 10;const int mod = 1e9 + 7;ll dp[N][4];// 1填上面 2填下面 3全填int main()&#123; int n; cin &gt;&gt; n; dp[0][3] = 1; for (int i = 1; i &lt;= n; i++) &#123; dp[i][1] = (dp[i - 1][2] + dp[i - 2][3]) % mod; dp[i][2] = (dp[i - 1][1] + dp[i - 2][3]) % mod; dp[i][3] = ((dp[i - 1][3] + dp[i - 1][1]) % mod + (dp[i - 1][2] + dp[i - 2][3]) % mod) % mod; //不分开求和会超int，1e7没法用LL &#125; cout &lt;&lt; dp[n][3] % mod;&#125; I: 李白打酒加强版（25分） 题目描述: 话说大诗人李白，一生好饮。幸好他从不开车。 一天，他提着酒壶，从家里出来，酒壶中有酒 2 斗。他边走边唱： $$无事街上走，提壶去打酒。逢店加一倍，遇花喝一斗。$$ 这一路上，他一共遇到店 $N$ 次，遇到花 $M$ 次。已知最后一次遇到的是花， 他正好把酒喝光了。 请你计算李白这一路遇到店和花的顺序，有多少种不同的可能？ 注意：壶里没酒 ( 0 斗) 时遇店是合法的，加倍后还是没酒；但是没酒时遇 花是不合法的。 输入格式： 第一行包含两个整数 $N$和 $M$. 输出格式： 输出一个整数表示答案。由于答案可能很大，输出模 1000000007 的结果。 输入样例： 5 10 输出样例： 14 评测用例规模与约定 对于 40% 的评测用例：$1 ≤ N, M ≤ 10$。 对于 100% 的评测用例：$1 ≤ N, M ≤ 100$。 思路 一眼dp，dp方案为 如果最后一步是到店，那么j应该大于0，因为至少有最后一步到店，到花同理， 如果最后一步是到店，那么上一步手里有的酒应该是k / 2，也是因此我们的k应该整除于2 如果最后一步是到花，那么上一步手里有的酒应该是k + 1。 打印答案的时候不是打印 dp[n][m][0] ,因为这么打印是无法区分最后是到花还是到店， 所以往前推一步，如果最后到花，那么喝完的上一步应该是dp[n - 1][m][1]。 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;const int mod = 1e9 + 7;const int N = 110;int dp[N][N][N]; //三维分别为店、花、酒int main()&#123; IOS; int n, m; cin &gt;&gt; n &gt;&gt; m; dp[0][0][2] = 1; //初始状态 for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= m; j++) &#123; for (int k = 0; k &lt;= m; k++) &#123; if (i &amp;&amp; k % 2 == 0) dp[i][j][k] += dp[i - 1][j][k / 2] % mod; //遇到店 if (j) dp[i][j][k] += dp[i][j - 1][k + 1] % mod; //遇到花 &#125; &#125; &#125; cout &lt;&lt; dp[n][m - 1][1] &lt;&lt; endl; //最后遇到的一个一定是花 return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1526B","slug":"CF1526B","date":"2022-05-07T14:18:59.000Z","updated":"2022-10-25T07:06:15.443Z","comments":true,"path":"2022/05/07/CF1526B/","link":"","permalink":"http://example.com/2022/05/07/CF1526B/","excerpt":"传送门：CF1526B 题目描述 给你一个数x，问你这个数能不能被11,111,1111，……（最少两个1）此类数字构成。（比如33=11+11+11,144=111+11+11+11） 输入格式： 第一行一个正整数T（(1≤T≤10000)）表示案例数，接下来每行一个正整数x(1≤x≤10^9) 输出格式： 对于每一行的x，如果能满足题意，输出“YES”，否则输出“NO”。 输入样例：","text":"传送门：CF1526B 题目描述 给你一个数x，问你这个数能不能被11,111,1111，……（最少两个1）此类数字构成。（比如33=11+11+11,144=111+11+11+11） 输入格式： 第一行一个正整数T（(1≤T≤10000)）表示案例数，接下来每行一个正整数x(1≤x≤10^9) 输出格式： 对于每一行的x，如果能满足题意，输出“YES”，否则输出“NO”。 输入样例： 4 33 144 121 69 输出样例： YES YES YES NO 思路 因为1111，11111,111111等都可以由11，111组成，所以只用看该数字能不能用11，111组成即可。 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; int n, a; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; int cot = a / 111; if (a % 11 &lt;= cot) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"素数筛","slug":"素数筛","date":"2022-05-05T13:55:34.000Z","updated":"2022-10-21T14:11:56.656Z","comments":true,"path":"2022/05/05/素数筛/","link":"","permalink":"http://example.com/2022/05/05/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足$6n+1$或$6n-1$。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力","text":"素数 素数又称质数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做素数；否则称为合数（规定1既不是质数也不是合数）。 六倍原理 原理：除了2和3以外，其余素数都与6的倍数相邻，也就是也就是说大于3的质数一定满足$6n+1$或$6n-1$。 用途 忘了筛法的时候可以使暴力写法变得不那么暴力 模板 bool isprime(int n)&#123; if (n == 1) return false; else if (n == 2 || n == 3) return true; //不满足六倍原理，一定不是素数 else if (n % 6 != 1 &amp;&amp; n % 6 != 5) return false; //只判断6倍的邻数 for (int i = 5; i &lt;= sqrt(n); i += 6) &#123; if (n % i == 0 || n % (i + 2) == 0) return false; &#125; return true;&#125; 埃氏筛法 原理：要得到自然数$n$以内的全部素数，必须把不大于根号$n$的所有素数的倍数剔除，剩下的就是素数。 时间复杂度：$O(n* log(logn))$ 有的写法内层循环不同时间复杂度可能是$O(n*logn)$ 模板 bool is_prime[1000]; //标记是否是素数for (int i = 0; i &lt;= n; i++) is_prime[i] = true; //初始化所有的数为素数 is_prime[1] = false; for (int i = 2; i &lt;= sqrt(n); i++) &#123; //从第一个素数2开始筛选 if (is_prime[i]) &#123; //如果是素数 for (int j = i * i; j &lt;= n; j += i) //一个小优化，从i * i开始而不是从 i + i开始 &#123; //则剔除掉它的倍数 is_prime[j] = false; &#125; &#125; &#125; 欧拉筛法（线性筛） 原理：使用埃式筛法时，同一个数字会被筛选多次，比如6先被2筛选一次，再被3筛选一次，这样就浪费了很多的时间。欧拉筛正是埃式筛的优化。即让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。 时间复杂度：$O(n)$ 模板 //求小于等于n的素数的个数，并输出每个素数#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1e5;int prime[N]; //存素数bool vis[N]; //保证不做素数的倍数int main()&#123; int n, cnt = 0; cin &gt;&gt; n; memset(vis, false, sizeof(vis)); //初始化 memset(prime, 0, sizeof(prime)); for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) //未被标记 prime[cnt++] = i; //则找到素数 for (int j = 0; j &lt; cnt &amp;&amp; i * prime[j] &lt;= n; j++) &#123; vis[i * prime[j]] = true; //标记找到的素数的倍数 if (i % prime[j] == 0) break; //线性的关键！！ &#125; &#125; cout &lt;&lt; cnt &lt;&lt; endl; for (int i = 0; i &lt; cnt; i++) cout &lt;&lt; prime[i] &lt;&lt; &quot; &quot;; //输出每个素数 return 0;&#125; 个人学习记录，非教程，所以不太注重以上算法原理的解释","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"2022天梯赛个人题解","slug":"2022天梯赛个人题解","date":"2022-04-26T06:26:37.000Z","updated":"2022-12-05T03:11:44.333Z","comments":true,"path":"2022/04/26/2022天梯赛个人题解/","link":"","permalink":"http://example.com/2022/04/26/2022%E5%A4%A9%E6%A2%AF%E8%B5%9B%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/","excerpt":"L1-1 今天我要赢(5分) 题目描述 2018 年我们曾经出过一题，是输出“2018 我们要赢”。今年是 2022 年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。 输入格式： 本题没有输入。 输出格式： 输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用 年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是 2022-04-22。 输入样例：","text":"L1-1 今天我要赢(5分) 题目描述 2018 年我们曾经出过一题，是输出“2018 我们要赢”。今年是 2022 年，你要输出的句子变成了“我要赢！就在今天！”然后以比赛当天的日期落款。 输入格式： 本题没有输入。 输出格式： 输出分 2 行。在第一行中输出 I’m gonna win! Today!，在第二行中用 年年年年-月月-日日 的格式输出比赛当天的日期。已知比赛的前一天是 2022-04-22。 输入样例： 无 输出样例（第二行的内容要你自己想一想，这里不给出）： I’m gonna win! Today! 这一行的内容我不告诉你…… 你要自己输出正确的日期呀~ 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; cout &lt;&lt; &quot;I&#x27;m gonna win! Today!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2022-04-23&quot;; return 0;&#125; L1-2 种钻石(5分) 题目描述 2019年10月29日，中央电视台专题报道，中国科学院在培育钻石领域，取得科技突破。科学家们用金刚石的籽晶片作为种子，利用甲烷气体在能量作用下形成碳的等离子体，慢慢地沉积到钻石种子上，一周“种”出了一颗 1 克拉大小的钻石。 本题给出钻石的需求量和人工培育钻石的速度，请你计算出货需要的时间。 输入格式： 输入在一行中给出钻石的需求量 $N$（不超过 $10^7$的正整数，以微克拉为单位）和人工培育钻石的速度 $v$（$1≤v≤200$，以微克拉/天为单位的整数）。 输出格式： 在一行中输出培育 $N$ 微克拉钻石需要的整数天数。不到一天的时间不算在内。 输入样例： 102000 130 输出样例： 784 代码 #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;cmath&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std; int main()&#123; //IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a / b; return 0;&#125; L1-3 谁能进图书馆(10分) 题目描述 为了保障安静的阅读环境，有些公共图书馆对儿童入馆做出了限制。例如“12 岁以下儿童禁止入馆，除非有 18 岁以上（包括 18 岁）的成人陪同”。现在有两位小/大朋友跑来问你，他们能不能进去？请你写个程序自动给他们一个回复。 输入格式： 输入在一行中给出 4 个整数： 禁入年龄线 陪同年龄线 询问者1的年龄 询问者2的年龄 这里的禁入年龄线是指严格小于该年龄的儿童禁止入馆；陪同年龄线是指大于等于该年龄的人士可以陪同儿童入馆。默认两个询问者的编号依次分别为 1 和 2；年龄和年龄线都是 [1, 200] 区间内的整数，并且保证 陪同年龄线 严格大于 禁入年龄线。 输出格式： 在一行中输出对两位询问者的回答，如果可以进就输出 年龄-Y，否则输出 年龄-N，中间空 1 格，行首尾不得有多余空格。 在第二行根据两个询问者的情况输出一句话： 如果两个人必须一起进，则输出 qing X zhao gu hao Y，其中 X 是陪同人的编号， Y 是小孩子的编号； 如果两个人都可以进但不是必须一起的，则输出 huan ying ru guan； 如果两个人都进不去，则输出 zhang da zai lai ba； 如果一个人能进一个不能，则输出 X: huan ying ru guan，其中 X 是可以入馆的那个人的编号。 输入样例1： 12 18 18 8 输出样例1： 18-Y 8-Y qing 1 zhao gu hao 2 输入样例 2： 12 18 10 15 输出样例 2： 10-N 15-Y 2: huan ying ru guan 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int y1, y2, a, b; cin &gt;&gt; y1 &gt;&gt; y2 &gt;&gt; a &gt;&gt; b; if (a &gt; b) &#123; if (b &gt;= y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;huan ying ru guan&quot; &lt;&lt; endl; &#125; else if (b &lt; y1 &amp;&amp; a &gt;= y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;qing 1 zhao gu hao 2&quot; &lt;&lt; endl; &#125; else if (a &lt; y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;zhang da zai lai ba&quot; &lt;&lt; endl; &#125; else if (b &lt; y1 &amp;&amp; a &lt; y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1: huan ying ru guan&quot; &lt;&lt; endl; &#125; &#125; else &#123; if (a &gt;= y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;huan ying ru guan&quot; &lt;&lt; endl; &#125; else if (a &lt; y1 &amp;&amp; b &gt;= y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-Y &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;qing 2 zhao gu hao 1&quot; &lt;&lt; endl; &#125; else if (b &lt; y1) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-N&quot; &lt;&lt; endl; cout &lt;&lt; &quot;zhang da zai lai ba&quot; &lt;&lt; endl; &#125; else if (a &lt; y1 &amp;&amp; b &lt; y2) &#123; cout &lt;&lt; a &lt;&lt; &quot;-N &quot; &lt;&lt; b &lt;&lt; &quot;-Y&quot; &lt;&lt; endl; cout &lt;&lt; &quot;2: huan ying ru guan&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; L1-4 拯救外星人(10分) 题目描述 你的外星人朋友不认得地球上的加减乘除符号，但是会算阶乘 —— 正整数 $N$ 的阶乘记为 “$N!$”，是从$1$到$N$ 的连乘积。所以当他不知道“$5+7$”等于多少时，如果你告诉他等于“$12!$”，他就写出了“$479001600$”这个答案。 本题就请你写程序模仿外星人的行为。 输入格式： 输入在一行中给出两个正整数 $A$和 $B$。 输出格式： 在一行中输出 $(A+B)$的阶乘。题目保证 $(A+B)$ 的值小于 $12$。 输入样例： 3 6 输出样例： 362880 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; int a, b; cin &gt;&gt; a &gt;&gt; b; int sum = 1; for (int i = 2; i &lt;= a + b; i++) sum *= i; cout &lt;&lt; sum; return 0;&#125; L1-5 试试手气(15分) 题目描述 我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件： 1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同； 2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。 那么你应该可以预知自己第 $n$ 次$（1≤n≤5）$摇出的结果。 输入格式： 输入第一行给出 $6$ 个骰子的初始点数，即 $[1,6]$ 之间的整数，数字间以空格分隔；第二行给出摇的次数 $n$$（1≤n≤5）$。 输出格式： 在一行中顺序列出第 $n $次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。 输入样例： 3 6 5 4 1 4 3 输出样例： 4 3 3 3 4 3 分析 可以硬模拟，也可以用数学推一推，但是模拟太好写了就直接无脑模了。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int a[7], b[7];int main()&#123; // IOS; for (int i = 1; i &lt;= 6; i++) &#123; cin &gt;&gt; a[i]; b[i] = a[i];//记录原始状态 if (a[i] != 6) a[i] = 6; else a[i] = 5; &#125; int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) for (int i = 1; i &lt;= 6; i++) &#123; a[i]--; if (a[i] == b[i]) a[i]--; &#125; for (int i = 1; i &lt; 6; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;//万恶的格式控制 cout &lt;&lt; a[6]; return 0;&#125; L1-6 斯德哥尔摩火车上的题(15分) 题目描述 上图是新浪微博上的一则趣闻，是瑞典斯德哥尔摩火车上的一道题，看上去是段伪代码： s = ‘’ a = ‘1112031584’ for (i = 1; i &lt; length(a); i++) { if (a[i] % 2 == a[i-1] % 2) { s += max(a[i], a[i-1]) } } goto_url(‘www.multisoft.se/’ + s) 其中字符串的 + 操作是连接两个字符串的意思。所以这道题其实是让大家访问网站 www.multisoft.se/112358（注意：比赛中千万不要访问这个网址！！！）。 当然，能通过上述算法得到 112358 的原始字符串 a 是不唯一的。本题就请你判断，两个给定的原始字符串，能否通过上述算法得到相同的输出？ 输入样例 1： 1112031584 011102315849 输出样例 1： 112358 输入样例 2： 111203158412334 12341112031584 输出样例 2： 1123583 112358 分析 字符串处理题，伪代码都给出来了，属于是送分。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int main()&#123; // IOS; string s1 = &quot;&quot;, s2 = &quot;&quot;; string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt; a.size(); i++) if (a[i] % 2 == a[i - 1] % 2) s1 += max(a[i], a[i - 1]); for (int i = 1; i &lt; b.size(); i++) if (b[i] % 2 == b[i - 1] % 2) s2 += max(b[i], b[i - 1]); if(s1 == s2) cout &lt;&lt; s1; else cout &lt;&lt; s1 &lt;&lt; endl &lt;&lt; s2; return 0;&#125; L1-7 机工士姆斯塔迪奥(20分) 题目描述 在 MMORPG《最终幻想14》的副本“乐欲之所瓯博讷修道院”里，BOSS 机工士姆斯塔迪奥将会接受玩家的挑战。 你需要处理这个副本其中的一个机制：$N×M$ 大小的地图被拆分为了 $N×M$ 个 $1×1$ 的格子，BOSS 会选择若干行或/及若干列释放技能，玩家不能站在释放技能的方格上，否则就会被击中而失败。 给定 BOSS 所有释放技能的行或列信息，请你计算出最后有多少个格子是安全的。 输入格式: 输入第一行是三个整数 $N,M,Q (1≤N×M≤10^5，0≤Q≤1000)$，表示地图为 $N$行 $M$列大小以及选择的行/列数量。 接下来 $Q$行，每行两个数 $T_i$ ,$C _i$，其中 $T_i=0$ 表示 BOSS 选择的是一整行，$T_i =1$ 表示选择的是整列，$C _i$为选择的行号/列号。行和列的编号均从 $1$ 开始。 输出格式: 输出一个数，表示安全格子的数量。 输入样例: 5 5 3 0 2 0 4 1 3 输出样例: 12 分析 很简单的题意，主要坑点就是有可能BOSS技能的位置会有重复输入，重复的数据不处理就好 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;const int N = 1e5 + 10;int vis[2][N];int main()&#123; IOS; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; int t, c; while (q--) &#123; cin &gt;&gt; t &gt;&gt; c; if (!vis[t][c]) //第一次遇见才处理 &#123; vis[t][c] = 1; if (t) m--; else n--; &#125; &#125; cout &lt;&lt; n * m; return 0;&#125; L1-8 静静的推荐(20分) 题目描述 天梯赛结束后，某企业的人力资源部希望组委会能推荐一批优秀的学生，这个整理推荐名单的任务就由静静姐负责。企业接受推荐的流程是这样的： 只考虑得分不低于 175 分的学生； 一共接受 $K$ 批次的推荐名单； 同一批推荐名单上的学生的成绩原则上应严格递增； 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 给定全体参赛学生的成绩和他们的 PAT 考试成绩，请你帮静静姐算一算，她最多能向企业推荐多少学生？ 输入格式： 输入第一行给出 3 个正整数：$N（≤10^5）$为参赛学生人数，$K（≤5×10^3）$为企业接受的推荐批次，$S（≤100）$为该企业的 PAT 面试分数线。 随后 $N$ 行，每行给出两个分数，依次为一位学生的天梯赛分数（最高分 290）和 PAT 分数（最高分 100）。 输出格式： 在一行中输出静静姐最多能向企业推荐的学生人数。 输入样例： 10 2 90 203 0 169 91 175 88 175 0 175 90 189 0 189 0 189 95 189 89 256 100 输出样例： 8 样例解释： 第一批可以选择 175、189、203、256 这四个分数的学生各一名，此外 175 分 PAT 分数达到 90 分的学生和 189 分 PAT 分数达到 95 分的学生可以额外进入名单。第二批就只剩下 175、189 两个分数的学生各一名可以进入名单了。最终一共 8 人进入推荐名单。 分析 很有意思的一个题，第一次做这个题很容易纠结在 如果有的学生天梯赛成绩虽然与前一个人相同，但其参加过 PAT 考试，且成绩达到了该企业的面试分数线，则也可以接受。 ”这句话里面的与前一个人相同，可能会不断扫描所有学生，写出一个模拟来判断前一个人的分数。可事实上这个人是哪个人并不重要，问的是人数，又没问推哪个人。 那么其实就可以将175~290的每个分数映射到数组下标，然后从175一直遍历到290。其中有个小细节就是如果天梯赛满足175并且PTA也达到了企业的要求，那么其实这一批人就可以全部跟着上一个分数相同但是PTA不达标的人一起进入同一个推荐名单。 如果样例数据是这样的 175 0 175 90 175 91 175 92 175 93 这批五个175分的学生其实就可以在同一个推荐名单里面 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;int stu[300];int pta[300];int main()&#123; IOS; int n, k, s; //人数，批次，分数线 cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; int a, b; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt;= 175) //天梯赛175以上是硬性规定，不满足的可以不用考虑 &#123; stu[a]++; //天梯赛分数为a的学生人数+1 if (b &gt;= s) pta[a]++; //可以特招的天梯赛分数为a的学生人数+1 &#125; &#125; int ans = 0; for (int i = 175; i &lt;= 290; i++) &#123; if (stu[i]) &#123; ans += pta[i]; //特招是一定可以全部推荐走的 stu[i] -= pta[i]; if (stu[i]) //如果还剩下的有天梯赛到175分而PTA不到企业规定分数的，则只能按照K个批次来推荐 ans += min(stu[i], k); //所以ans再次加上可以推荐的人数 &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; L2-1 插松枝(25分) 题目描述 人造松枝加工场的工人需要将各种尺寸的塑料松针插到松枝干上，做成大大小小的松枝。他们的工作流程（并不）是这样的： 每人手边有一只小盒子，初始状态为空。 每人面前有用不完的松枝干和一个推送器，每次推送一片随机型号的松针片。 工人首先捡起一根空的松枝干，从小盒子里摸出最上面的一片松针 —— 如果小盒子是空的，就从推送器上取一片松针。将这片松针插到枝干的最下面。 工人在插后面的松针时，需要保证，每一步插到一根非空松枝干上的松针片，不能比前一步插上的松针片大。如果小盒子中最上面的松针满足要求，就取之插好；否则去推送器上取一片。如果推送器上拿到的仍然不满足要求，就把拿到的这片堆放到小盒子里，继续去推送器上取下一片。注意这里假设小盒子里的松针片是按放入的顺序堆叠起来的，工人每次只能取出最上面（即最后放入）的一片。 当下列三种情况之一发生时，工人会结束手里的松枝制作，开始做下一个： （1）小盒子已经满了，但推送器上取到的松针仍然不满足要求。此时将手中的松枝放到成品篮里，推送器上取到的松针压回推送器，开始下一根松枝的制作。 （2）小盒子中最上面的松针不满足要求，但推送器上已经没有松针了。此时将手中的松枝放到成品篮里，开始下一根松枝的制作。 （3）手中的松枝干上已经插满了松针，将之放到成品篮里，开始下一根松枝的制作。 现在给定推送器上顺序传过来的 $N$ 片松针的大小，以及小盒子和松枝的容量，请你编写程序自动列出每根成品松枝的信息。 输入格式： 输入在第一行中给出 $3$ 个正整数：$N（≤10^3）$，为推送器上松针片的数量；$M（≤20）$为小盒子能存放的松针片的最大数量；$K（≤5）$为一根松枝干上能插的松针片的最大数量。 随后一行给出 $N$ 个不超过 $100$ 的正整数，为推送器上顺序推出的松针片的大小。 输出格式： 每支松枝成品的信息占一行，顺序给出自底向上每片松针的大小。数字间以 $1$ 个空格分隔，行首尾不得有多余空格。 输入样例： 8 3 4 20 25 15 18 20 18 8 5 输出样例： 20 15 20 18 18 8 25 5 分析 开两个容器硬模拟推送器和小盒子，注意一下条件不然可能出现段错误 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;queue&lt;int&gt; que; //推送器stack&lt;int&gt; st; //盒子int main()&#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; que.push(x); &#125; while (que.size() || st.size()) &#123; vector&lt;int&gt; ans; int s; if (!st.empty()) &#123; s = st.top(); st.pop(); ans.push_back(s); &#125; else if (!que.empty()) &#123; s = que.front(); que.pop(); ans.push_back(s); &#125; while (true) &#123; if (!st.empty() &amp;&amp; st.top() &lt;= ans.back()) &#123; s = st.top(); st.pop(); ans.push_back(s); &#125; else if (!que.empty() &amp;&amp; que.front() &lt;= ans.back()) &#123; s = que.front(); que.pop(); ans.push_back(s); &#125; else if (!st.empty() &amp;&amp; st.top() &gt; ans.back() &amp;&amp; que.empty()) break; else if (st.size() &lt; m &amp;&amp; que.front() &gt; ans.back()) &#123; s = que.front(); que.pop(); st.push(s); &#125; else if (st.size() == m &amp;&amp; que.front() &gt; ans.back()) break; if (que.empty() &amp;&amp; st.empty()) break; else if (ans.size() == k) break; &#125; cout &lt;&lt; ans[0]; //又是我最讨厌的控制格式 for (int t1 = 1; t1 &lt; ans.size(); t1++) cout &lt;&lt; &quot; &quot; &lt;&lt; ans[t1]; cout &lt;&lt; endl; &#125; return 0;&#125; L2-2 老板的作息表(25分) 题目描述 新浪微博上有人发了某老板的作息时间表，表示其每天 4:30 就起床了。但立刻有眼尖的网友问：这时间表不完整啊，早上九点到下午一点干啥了？ 本题就请你编写程序，检查任意一张时间表，找出其中没写出来的时间段。 输入格式： 输入第一行给出一个正整数 $N$，为作息表上列出的时间段的个数。随后 $N$ 行，每行给出一个时间段，格式为： hh:mm:ss - hh:mm:ss 其中 hh、mm、ss 分别是两位数表示的小时、分钟、秒。第一个时间是开始时间，第二个是结束时间。题目保证所有时间都在一天之内（即从 00:00:00 到 23:59:59）；每个区间间隔至少 1 秒；并且任意两个给出的时间区间最多只在一个端点有重合，没有区间重叠的情况。 输出格式： 按照时间顺序列出时间表中没有出现的区间，每个区间占一行，格式与输入相同。题目保证至少存在一个区间需要输出。 输入样例： 8 13:00:00 - 18:00:00 00:00:00 - 01:00:05 08:00:00 - 09:00:00 07:10:59 - 08:00:00 01:00:05 - 04:30:00 06:30:00 - 07:10:58 05:30:00 - 06:30:00 18:00:00 - 19:00:00 输出样例： 04:30:00 - 05:30:00 07:10:58 - 07:10:59 09:00:00 - 13:00:00 19:00:00 - 23:59:59 分析 考点很简单就是排序（但是我第一反应是一个不需要排序的邪道写法最后还A了 ） 将所有的时间存起来然后排序再扫描一遍即可，排序可以手写重载也可以用vector的默认排序，数据量大建议手写，容器自带的排序还是慢了点。 代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl &#x27;\\n&#x27;using namespace std;string s[100000]; //没给范围第一次数组开小了一直段错误超bool cmp(string a, string b)&#123; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] != b[i]) return a[i] &lt; b[i]; &#125;&#125;int main()&#123; // IOS; int n; cin &gt;&gt; n; cin.get(); for (int i = 0; i &lt; n; i++) getline(cin, s[i]); sort(s, s + n, cmp); string temp = &quot;00:00:00&quot;; for (int i = 0; i &lt; n; i++) &#123; if (temp != s[i].substr(0, 8)) cout &lt;&lt; temp &lt;&lt; &quot; - &quot; &lt;&lt; s[i].substr(0, 8) &lt;&lt; endl; temp = s[i].substr(11, 8); &#125; if (temp != &quot;23:59:59&quot;) cout &lt;&lt; temp &lt;&lt; &quot; - 23:59:59&quot; &lt;&lt; endl; return 0;&#125; 剩下有空了再摸","categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"二分总结","slug":"二分总结","date":"2022-01-07T09:31:37.000Z","updated":"2022-12-05T07:18:41.711Z","comments":true,"path":"2022/01/07/二分总结/","link":"","permalink":"http://example.com/2022/01/07/%E4%BA%8C%E5%88%86%E6%80%BB%E7%BB%93/","excerpt":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; }","text":"序 以前学习二分的时候一直没有搞清楚什么时候，什么时候，更新的时候是还是，但是一直迷迷糊糊的也能写对题，后面也没有多管。这个寒假重新学一遍基础算法，才明白为什么会有这两种情况。 整数二分的两种情况 第一种 这种情况代码如下 while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } 为什么需要补上一个呢？ 因为整数的除法是向下取整，我们需要在运算时+1时它变成向上取整，否则的话会因为边界问题导致while无限循环。 举个例子，在区间只有两个数的时候，比如，，，这时候如果check成功，那么会执行，然后问题就来了，和本来就都等于3，然后就会无限循环下去，和的值永远不会更新。所以在的更新方式下，我们需要将运算时成为向上取整才不会死循环。 第二种 这种情况代码如下 while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; } 为什么在这里不需要补上一个呢？ 因为边界问题不会影响到值的更新，还是用上面那个例子，，，。 此时如果check成功，那么，更新成功。如果check失败，则，同样更新成功。由此可以看出，在的更新方式下，不需要对进行任何操作。 以上是整数二分的两种固定写法。那么什么时候用哪种方法呢，这就要根据具体的题目进行分析了。 例题—— 分巧克力 题目描述 儿童节那天有 K 位小朋友到小明家做客。 小明拿出了珍藏的巧克力招待小朋友们。 小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。 为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。 切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同 例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。 当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？ 输入格式 第一行包含两个整数 N 和 K。 以下 N 行每行包含两个整数 和 。 输入保证每位小朋友至少能获得一块 的巧克力。 输出格式 输出切出的正方形巧克力最大可能的边长。 输入输出样例 输入#1 2 10 6 5 5 6 输出#1 2 AC代码 #include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;typedef long long ll;#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)#define max(a, b) (a &gt; b ? a : b)#define min(a, b) (a &lt; b ? a : b)#define endl '\\n'using namespace std;int n, k;const int N = 1e5 + 10;int h[N], w[N];bool check(int x){ int cnt = 0; for (int i = 0; i &lt; n; i++) { cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; } return false;}int main(){ IOS; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) cin &gt;&gt; h[i] &gt;&gt; w[i]; int l = 0, r = N; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l &lt;&lt; endl; return 0;} 题目很简单是二分的板子题，主要是说为什么要用第一种求方法呢。 为什么二分里面不能写成 int mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1; //这样写跑样例答案是3 else r = mid; 推导一遍发现，如果成立后，说明当前的值也是在答案范围中，所以答案只能在之中取。理所当然无法用上面那种写法，如果用上面那种方法，会直接更新成，会越过这个值，所以在一些情况就会出现错误，比如题面的样例就会成为，越过了这个可能的答案值，恰好就是最大的一个答案，导致答案错误。 总结 这次弄明白了二分的写法属实是不易，留文一篇防止日后遗忘 以后写二分的时候记得注意一下区间情况","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"},{"name":"学习","slug":"学习","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"GitHub","slug":"GitHub","permalink":"http://example.com/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"题解","slug":"题解","permalink":"http://example.com/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}